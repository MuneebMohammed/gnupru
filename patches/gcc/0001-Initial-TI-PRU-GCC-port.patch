From 0f9c0ea7303ed2c7baa9cde1641f1dc08e4a848e Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dinuxbg@gmail.com>
Date: Mon, 30 Dec 2013 23:47:32 +0200
Subject: [PATCH 1/2] Initial TI PRU GCC port

Signed-off-by: Dimitar Dimitrov <dinuxbg@gmail.com>
---
 .gitignore                                         |    3 +
 config.sub                                         |    2 +
 configure                                          |    4 +
 configure.ac                                       |    4 +
 gcc/common/config/pru/pru-common.c                 |   44 +
 gcc/config.gcc                                     |   10 +
 gcc/config/pru/constraints.md                      |   68 +
 gcc/config/pru/predicates.md                       |  211 +
 gcc/config/pru/pru-ldst-multiple.md                | 5998 ++++++++++++++++++++
 gcc/config/pru/pru-ldst-multiple.ml                |  145 +
 gcc/config/pru/pru-modes.def                       |   29 +
 gcc/config/pru/pru-pragma.c                        |   96 +
 gcc/config/pru/pru-protos.h                        |   60 +
 gcc/config/pru/pru.c                               | 1766 ++++++
 gcc/config/pru/pru.h                               |  418 ++
 gcc/config/pru/pru.md                              |  579 ++
 gcc/config/pru/pru.opt                             |   27 +
 gcc/config/pru/t-pru                               |   25 +
 gcc/doc/extend.texi                                |   20 +
 gcc/doc/md.texi                                    |   19 +
 gcc/testsuite/gcc.c-torture/execute/20101011-1.c   |    3 +
 gcc/testsuite/gcc.dg/20020312-2.c                  |    2 +
 gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-1.c   |    2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c         |    2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c         |    2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c         |    2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c         |    2 +-
 .../gcc.target/pru/pru-pragma-ctable_entry.c       |   22 +
 gcc/testsuite/gcc.target/pru/pru.exp               |   41 +
 gcc/testsuite/lib/gcc-dg.exp                       |    5 +
 gcc/testsuite/lib/target-supports.exp              |    7 +-
 gcc/testsuite/lib/target-utils.exp                 |    3 +
 libgcc/config.host                                 |    6 +
 libgcc/config/pru/lib2bitcountHI.c                 |   43 +
 libgcc/config/pru/lib2divHI.c                      |   42 +
 libgcc/config/pru/lib2divQI.c                      |   43 +
 libgcc/config/pru/lib2divSI.c                      |   42 +
 libgcc/config/pru/lib2shift.c                      |   48 +
 libgcc/config/pru/muldi3.S                         |   60 +
 libgcc/config/pru/pru-asm.h                        |   36 +
 libgcc/config/pru/pru-divmod.h                     |  117 +
 libgcc/config/pru/t-pru                            |   40 +
 42 files changed, 10091 insertions(+), 7 deletions(-)
 create mode 100644 gcc/common/config/pru/pru-common.c
 create mode 100644 gcc/config/pru/constraints.md
 create mode 100644 gcc/config/pru/predicates.md
 create mode 100644 gcc/config/pru/pru-ldst-multiple.md
 create mode 100644 gcc/config/pru/pru-ldst-multiple.ml
 create mode 100644 gcc/config/pru/pru-modes.def
 create mode 100644 gcc/config/pru/pru-pragma.c
 create mode 100644 gcc/config/pru/pru-protos.h
 create mode 100644 gcc/config/pru/pru.c
 create mode 100644 gcc/config/pru/pru.h
 create mode 100644 gcc/config/pru/pru.md
 create mode 100644 gcc/config/pru/pru.opt
 create mode 100644 gcc/config/pru/t-pru
 create mode 100644 gcc/testsuite/gcc.target/pru/pru-pragma-ctable_entry.c
 create mode 100644 gcc/testsuite/gcc.target/pru/pru.exp
 create mode 100644 libgcc/config/pru/lib2bitcountHI.c
 create mode 100644 libgcc/config/pru/lib2divHI.c
 create mode 100644 libgcc/config/pru/lib2divQI.c
 create mode 100644 libgcc/config/pru/lib2divSI.c
 create mode 100644 libgcc/config/pru/lib2shift.c
 create mode 100644 libgcc/config/pru/muldi3.S
 create mode 100644 libgcc/config/pru/pru-asm.h
 create mode 100644 libgcc/config/pru/pru-divmod.h
 create mode 100644 libgcc/config/pru/t-pru

diff --git a/.gitignore b/.gitignore
index ab97ac6..5807e90 100644
--- a/.gitignore
+++ b/.gitignore
@@ -47,3 +47,6 @@ lost+found
 # ignore ./contrib/gcc_update output
 LAST_UPDATED
 REVISION
+
+cscope.*
+.*.swp
diff --git a/config.sub b/config.sub
index 6d2e94c..d725862 100755
--- a/config.sub
+++ b/config.sub
@@ -301,6 +301,7 @@ case $basic_machine in
 	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
+	| pru \
 	| pyramid \
 	| riscv32 | riscv64 \
 	| rl78 | rx \
@@ -427,6 +428,7 @@ case $basic_machine in
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
+	| pru \
 	| pyramid-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
diff --git a/configure b/configure
index 098ed9f..bc27735 100755
--- a/configure
+++ b/configure
@@ -3336,6 +3336,10 @@ case "${target}" in
   powerpc-*-aix* | rs6000-*-aix*)
     noconfigdirs="$noconfigdirs target-libssp"
     ;;
+  pru-*-*)
+    # No hosted I/O support.
+    noconfigdirs="$noconfigdirs target-libssp"
+    ;;
   rl78-*-*)
     # libssp uses a misaligned load to trigger a fault, but the RL78
     # doesn't fault for those - instead, it gives a build-time error
diff --git a/configure.ac b/configure.ac
index 7104631..1d2c71c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -683,6 +683,10 @@ case "${target}" in
   powerpc-*-aix* | rs6000-*-aix*)
     noconfigdirs="$noconfigdirs target-libssp"
     ;;
+  pru-*-*)
+    # No hosted I/O support.
+    noconfigdirs="$noconfigdirs target-libssp"
+    ;;
   rl78-*-*)
     # libssp uses a misaligned load to trigger a fault, but the RL78
     # doesn't fault for those - instead, it gives a build-time error
diff --git a/gcc/common/config/pru/pru-common.c b/gcc/common/config/pru/pru-common.c
new file mode 100644
index 0000000..46e73bd
--- /dev/null
+++ b/gcc/common/config/pru/pru-common.c
@@ -0,0 +1,44 @@
+/* Common hooks for TI PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "diagnostic-core.h"
+#include "tm.h"
+#include "common/common-target.h"
+#include "common/common-target-def.h"
+#include "opts.h"
+#include "flags.h"
+
+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
+static const struct default_options pru_option_optimization_table[] =
+  {
+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },
+    { OPT_LEVELS_NONE, 0, NULL, 0 }
+  };
+
+#undef TARGET_OPTION_OPTIMIZATION_TABLE
+#define TARGET_OPTION_OPTIMIZATION_TABLE pru_option_optimization_table
+
+/* Disable exceptions for now */
+#undef TARGET_EXCEPT_UNWIND_INFO
+#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info
+
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index cb08a5c..3512a51 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -439,6 +439,9 @@ powerpc*-*-*)
 	esac
 	extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
 	;;
+pru-*-*)
+	cpu_type=pru
+	;;
 rs6000*-*-*)
 	extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
 	;;
@@ -2455,6 +2458,13 @@ powerpcle-*-eabi*)
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	use_gcc_stdint=wrap
 	;;
+pru*-*-*)
+	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
+	tmake_file="${tmake_file} pru/t-pru"
+	c_target_objs="pru-pragma.o"
+	cxx_target_objs="pru-pragma.o"
+	use_gcc_stdint=wrap
+	;;
 rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
 	tm_file="rs6000/biarch64.h ${tm_file} rs6000/aix.h rs6000/aix43.h rs6000/xcoff.h rs6000/aix-stdint.h"
 	tmake_file="rs6000/t-aix43 t-slibgcc"
diff --git a/gcc/config/pru/constraints.md b/gcc/config/pru/constraints.md
new file mode 100644
index 0000000..b90152f
--- /dev/null
+++ b/gcc/config/pru/constraints.md
@@ -0,0 +1,68 @@
+;; Constraint definitions for TI PRU.
+;; Copyright (C) 2014 Free Software Foundation, Inc.
+;; Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; We use the following constraint letters for constants
+;;
+;;  I: 0 to 255
+;;  J: 0 to 65535
+;;  K: -255 to 0
+;;  L: 0 to 31 (for shift counts)
+;;  M: -255 to 0 (for converting ADD to SUB with suitable UBYTE OP2)
+;;  T: Text segment label. Needed to know when to select %pmem relocation.
+;;
+;; We use the following built-in register classes:
+;;
+;;  r: general purpose register (r0..r31)
+;;  m: memory operand
+;;
+;; The following constraints are intended for internal use only:
+;;  j: jump address register suitable for sibling calls
+
+;; Register constraints
+
+(define_register_constraint "j" "SIB_REGS"
+  "A register suitable for an indirect sibcall.")
+
+;; Integer constraints
+
+(define_constraint "I"
+  "An unsigned 8-bit constant."
+  (and (match_code "const_int")
+       (match_test "UBYTE_INT (ival)")))
+
+(define_constraint "J"
+  "An unsigned 16-bit constant."
+  (and (match_code "const_int")
+       (match_test "UHWORD_INT(ival)")))
+
+(define_constraint "L"
+  "An unsigned 5-bit constant (for shift counts)."
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 31")))
+
+(define_constraint "M"
+  "A constant in the range [-255;0]."
+  (and (match_code "const_int")
+       (match_test "UBYTE_INT (-ival)")))
+
+(define_constraint "T"
+  "A text segment (program memory) constant label."
+  (match_test "text_segment_operand (op, VOIDmode)"))
+
diff --git a/gcc/config/pru/predicates.md b/gcc/config/pru/predicates.md
new file mode 100644
index 0000000..2fe7d46
--- /dev/null
+++ b/gcc/config/pru/predicates.md
@@ -0,0 +1,211 @@
+;; Predicate definitions for TI PRU.
+;; Copyright (C) 2014 Free Software Foundation, Inc.
+;; Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_predicate "const_ubyte_operand"
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (INTVAL (op), 0, 0xff)")))
+
+(define_predicate "const_uhword_operand"
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (INTVAL (op), 0, 0xffff)")))
+
+; TRUE for comparisons we support.
+(define_predicate "pru_cmp_operator"
+  (match_code "eq,ne,leu,ltu,geu,gtu"))
+
+; TRUE for signed comparisons that need special handling for PRU.
+(define_predicate "pru_signed_cmp_operator"
+  (match_code "ge,gt,le,lt"))
+
+; TRUE for constants which are bit positions for zero_extract
+(define_predicate "pru_bitpos"
+  (and (match_code "const_int")
+       (match_test ("   INTVAL (op) >= 0
+		     && INTVAL (op) <= 31 "))))
+
+(define_predicate "pru_bytepos"
+  (and (match_code "const_int")
+       (match_test ("   INTVAL (op) >= 0
+		     && INTVAL (op) <= 3 "))))
+(define_predicate "pru_hwordpos"
+  (and (match_code "const_int")
+       (match_test ("   INTVAL (op) >= 0
+		     && INTVAL (op) <= 2 "))))
+
+(define_predicate "reg_or_ubyte_operand"
+  (ior (match_operand 0 "const_ubyte_operand")
+       (match_operand 0 "register_operand")))
+
+(define_predicate "const_shift_operand"
+  (and (match_code "const_int")
+       (match_test "SHIFT_INT (INTVAL (op))")))
+
+(define_predicate "shift_operand"
+  (ior (match_operand 0 "const_shift_operand")
+       (match_operand 0 "register_operand")))
+
+(define_predicate "ctable_addr_operand"
+  (and (match_code "const_int")
+       (match_test ("(pru_get_ctable_base_index (INTVAL (op)) >= 0)"))))
+
+(define_predicate "ctable_base_operand"
+  (and (match_code "const_int")
+       (match_test ("(pru_get_ctable_exact_base_index (INTVAL (op)) >= 0)"))))
+
+;; Ideally we should enforce a restriction to all text labels to fit in
+;; 16bits, as required by the PRU ISA. But for the time being we'll rely on
+;; binutils to catch text segment overflows.
+(define_predicate "call_operand"
+  (ior (match_operand 0 "immediate_operand")
+       (match_operand 0 "register_operand")))
+
+;; Return true if OP is a text segment reference.
+;; This is needed for program memory address expressions. Stolen from AVR.
+(define_predicate "text_segment_operand"
+  (match_code "code_label,label_ref,symbol_ref,plus,minus,const")
+{
+  switch (GET_CODE (op))
+    {
+    case CODE_LABEL:
+      return true;
+    case LABEL_REF :
+      return true;
+    case SYMBOL_REF :
+      return SYMBOL_REF_FUNCTION_P (op);
+    case PLUS :
+    case MINUS :
+      /* Assume canonical format of symbol + constant.
+	 Fall through.  */
+    case CONST :
+      return text_segment_operand (XEXP (op, 0), VOIDmode);
+    default :
+      return false;
+    }
+})
+
+;; Return 1 if OP is a load multiple operation.  It is known to be a
+;; PARALLEL and the first section will be tested.
+
+(define_predicate "pru_load_multiple_operation"
+  (match_code "parallel")
+{
+  int count = XVECLEN (op, 0);
+  int base_offset = 0;
+  int dest_regno;
+  rtx src_addr;
+  int i;
+
+  /* Perform a quick check so we don't blow up below.  */
+  if (count < 1
+      || GET_CODE (XVECEXP (op, 0, 0)) != SET
+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG
+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)
+    return 0;
+
+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));
+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);
+
+  /* Zero memory offset will be optimized, so handle both PLUS and REG here.
+     Note that subsequent registers in the sequence will always have
+     non-zero offsets because we can't have negative offsets, and
+     we always increment while going forward. */
+  if (GET_CODE (src_addr) == PLUS
+      && GET_CODE (XEXP (src_addr, 1)) == CONST_INT)
+    {
+      base_offset = INTVAL (XEXP (src_addr, 1));
+      src_addr = XEXP (src_addr, 0);
+    }
+
+  if (GET_CODE (src_addr) != REG)
+    return 0;
+
+  for (i = 1; i < count; i++)
+    {
+      rtx elt = XVECEXP (op, 0, i);
+      int offset = i * UNITS_PER_WORD + base_offset;
+
+      if (GET_CODE (elt) != SET
+	  || GET_CODE (SET_DEST (elt)) != REG
+	  || GET_MODE (SET_DEST (elt)) != SImode
+	  || REGNO (SET_DEST (elt))    != (unsigned) (dest_regno + i)
+	  || GET_CODE (SET_SRC (elt))  != MEM
+	  || GET_MODE (SET_SRC (elt))  != SImode
+	  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS
+	  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)
+	  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT
+	  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != offset)
+	return 0;
+    }
+
+  return 1;
+})
+
+;; Similar, but tests for store multiple.
+
+(define_predicate "pru_store_multiple_operation"
+  (match_code "parallel")
+{
+  int count = XVECLEN (op, 0);
+  int base_offset = 0;
+  int src_regno;
+  rtx dest_addr;
+  int i;
+
+  /* Perform a quick check so we don't blow up below.  */
+  if (count < 1
+      || GET_CODE (XVECEXP (op, 0, 0)) != SET
+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM
+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)
+    return 0;
+
+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));
+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);
+
+  if (GET_CODE (dest_addr) == PLUS
+      && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)
+    {
+      base_offset = INTVAL (XEXP (dest_addr, 1));
+      dest_addr = XEXP (dest_addr, 0);
+    }
+
+  if (GET_CODE (dest_addr) != REG)
+    return 0;
+
+  for (i = 1; i < count; i++)
+    {
+      rtx elt = XVECEXP (op, 0, i);
+      int offset = i * UNITS_PER_WORD + base_offset;
+
+      if (GET_CODE (elt) != SET
+	  || GET_CODE (SET_SRC (elt)) != REG
+	  || GET_MODE (SET_SRC (elt)) != SImode
+	  || REGNO (SET_SRC (elt)) != (unsigned) (src_regno + i)
+	  || GET_CODE (SET_DEST (elt)) != MEM
+	  || GET_MODE (SET_DEST (elt)) != SImode
+	  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS
+	  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)
+	  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT
+	  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != offset)
+	return 0;
+    }
+
+  return 1;
+})
+
diff --git a/gcc/config/pru/pru-ldst-multiple.md b/gcc/config/pru/pru-ldst-multiple.md
new file mode 100644
index 0000000..4b34add
--- /dev/null
+++ b/gcc/config/pru/pru-ldst-multiple.md
@@ -0,0 +1,5998 @@
+/* PRU load/store instruction patterns.  This file was automatically
+   generated using pru-ldst-multiple.ml.  Please do not edit manually.
+
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>.
+   Based on arm-ldmstm.ml
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+(define_insn "*lbbo_multiple_1_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 2 "register_operand" "r")
+                           (match_operand:SI 3 "const_ubyte_operand" "I"))))])]
+  "XVECLEN (operands[0], 0) == 1"
+  "lbbo\t%1, %2, %3, 4"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_1"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 2 "register_operand" "r")))])]
+  "XVECLEN (operands[0], 0) == 1"
+  "lbbo\t%1, %2, 0, 4"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_1_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 2 "register_operand" "r")
+                           (match_operand:SI 3 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 1"
+  "sbbo\t%1, %2, %3, 4"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_1"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 2 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 1"
+  "sbbo\t%1, %2, 0, 4"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_2_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 3 "register_operand" "r")
+                           (match_operand:SI 4 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 3)
+                           (match_operand:SI 5 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 2"
+  "lbbo\t%1, %3, %4, 8"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_2"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 3 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 3)
+                           (match_operand:SI 4 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 2"
+  "lbbo\t%1, %3, 0, 8"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_2_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 3 "register_operand" "r")
+                           (match_operand:SI 4 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 3)
+                           (match_operand:SI 5 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 2"
+  "sbbo\t%1, %3, %4, 8"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_2"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 3 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 3)
+                           (match_operand:SI 4 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 2"
+  "sbbo\t%1, %3, 0, 8"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_3_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 4 "register_operand" "r")
+                           (match_operand:SI 5 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 6 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 7 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 3"
+  "lbbo\t%1, %4, %5, 12"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_3"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 4 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 5 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 6 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 3"
+  "lbbo\t%1, %4, 0, 12"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_3_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 4 "register_operand" "r")
+                           (match_operand:SI 5 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 6 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 7 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 3"
+  "sbbo\t%1, %4, %5, 12"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_3"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 4 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 5 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 4)
+                           (match_operand:SI 6 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 3"
+  "sbbo\t%1, %4, 0, 12"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_4_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 5 "register_operand" "r")
+                           (match_operand:SI 6 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 7 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 8 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 9 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 4"
+  "lbbo\t%1, %5, %6, 16"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_4"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 5 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 6 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 7 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 8 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 4"
+  "lbbo\t%1, %5, 0, 16"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_4_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 5 "register_operand" "r")
+                           (match_operand:SI 6 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 7 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 8 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 9 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 4"
+  "sbbo\t%1, %5, %6, 16"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_4"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 5 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 6 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 7 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 5)
+                           (match_operand:SI 8 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 4"
+  "sbbo\t%1, %5, 0, 16"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_5_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 6 "register_operand" "r")
+                           (match_operand:SI 7 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 8 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 9 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 10 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 11 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 5"
+  "lbbo\t%1, %6, %7, 20"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_5"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 6 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 7 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 8 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 9 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 10 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 5"
+  "lbbo\t%1, %6, 0, 20"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_5_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 6 "register_operand" "r")
+                           (match_operand:SI 7 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 8 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 9 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 5"
+  "sbbo\t%1, %6, %7, 20"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_5"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 6 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 7 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 8 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 9 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 6)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 5"
+  "sbbo\t%1, %6, 0, 20"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_6_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 7 "register_operand" "r")
+                           (match_operand:SI 8 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 9 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 10 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 13 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 6"
+  "lbbo\t%1, %7, %8, 24"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_6"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 7 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 8 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 9 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 10 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 12 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 6"
+  "lbbo\t%1, %7, 0, 24"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_6_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 7 "register_operand" "r")
+                           (match_operand:SI 8 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 9 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 6"
+  "sbbo\t%1, %7, %8, 24"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_6"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 7 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 8 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 9 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 7)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 6"
+  "sbbo\t%1, %7, 0, 24"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_7_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 8 "register_operand" "r")
+                           (match_operand:SI 9 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 10 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 15 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 7"
+  "lbbo\t%1, %8, %9, 28"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_7"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 8 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 9 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 10 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 14 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 7"
+  "lbbo\t%1, %8, 0, 28"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_7_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 8 "register_operand" "r")
+                           (match_operand:SI 9 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 7"
+  "sbbo\t%1, %8, %9, 28"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_7"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 8 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 9 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 8)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 7"
+  "sbbo\t%1, %8, 0, 28"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_8_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 9 "register_operand" "r")
+                           (match_operand:SI 10 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 17 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 8"
+  "lbbo\t%1, %9, %10, 32"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_8"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 9 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 10 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 16 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 8"
+  "lbbo\t%1, %9, 0, 32"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_8_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 9 "register_operand" "r")
+                           (match_operand:SI 10 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 8"
+  "sbbo\t%1, %9, %10, 32"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_8"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 9 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 10 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 9)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 8"
+  "sbbo\t%1, %9, 0, 32"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_9_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 10 "register_operand" "r")
+                           (match_operand:SI 11 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 19 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 9"
+  "lbbo\t%1, %10, %11, 36"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_9"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 10 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 11 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 18 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 9"
+  "lbbo\t%1, %10, 0, 36"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_9_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 10 "register_operand" "r")
+                           (match_operand:SI 11 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 9"
+  "sbbo\t%1, %10, %11, 36"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_9"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 10 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 11 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 10)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 9"
+  "sbbo\t%1, %10, 0, 36"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_10_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 11 "register_operand" "r")
+                           (match_operand:SI 12 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 21 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 10"
+  "lbbo\t%1, %11, %12, 40"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_10"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 11 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 12 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 20 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 10"
+  "lbbo\t%1, %11, 0, 40"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_10_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 11 "register_operand" "r")
+                           (match_operand:SI 12 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 10"
+  "sbbo\t%1, %11, %12, 40"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_10"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 11 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 12 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 11)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 10"
+  "sbbo\t%1, %11, 0, 40"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_11_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 12 "register_operand" "r")
+                           (match_operand:SI 13 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 23 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 11"
+  "lbbo\t%1, %12, %13, 44"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_11"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 12 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 13 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 22 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 11"
+  "lbbo\t%1, %12, 0, 44"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_11_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 12 "register_operand" "r")
+                           (match_operand:SI 13 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 11"
+  "sbbo\t%1, %12, %13, 44"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_11"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 12 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 13 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 12)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 11"
+  "sbbo\t%1, %12, 0, 44"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_12_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 13 "register_operand" "r")
+                           (match_operand:SI 14 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 25 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 12"
+  "lbbo\t%1, %13, %14, 48"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_12"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 13 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 14 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 24 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 12"
+  "lbbo\t%1, %13, 0, 48"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_12_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 13 "register_operand" "r")
+                           (match_operand:SI 14 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 12"
+  "sbbo\t%1, %13, %14, 48"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_12"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 13 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 14 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 13)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 12"
+  "sbbo\t%1, %13, 0, 48"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_13_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 14 "register_operand" "r")
+                           (match_operand:SI 15 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 27 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 13"
+  "lbbo\t%1, %14, %15, 52"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_13"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 14 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 15 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 26 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 13"
+  "lbbo\t%1, %14, 0, 52"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_13_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 14 "register_operand" "r")
+                           (match_operand:SI 15 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 13"
+  "sbbo\t%1, %14, %15, 52"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_13"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 14 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 15 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 14)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 13"
+  "sbbo\t%1, %14, 0, 52"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_14_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 15 "register_operand" "r")
+                           (match_operand:SI 16 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 29 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 14"
+  "lbbo\t%1, %15, %16, 56"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_14"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 15 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 16 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 28 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 14"
+  "lbbo\t%1, %15, 0, 56"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_14_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 15 "register_operand" "r")
+                           (match_operand:SI 16 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 14"
+  "sbbo\t%1, %15, %16, 56"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_14"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 15 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 16 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 15)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 14"
+  "sbbo\t%1, %15, 0, 56"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_15_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 16 "register_operand" "r")
+                           (match_operand:SI 17 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 31 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 15"
+  "lbbo\t%1, %16, %17, 60"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_15"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 16 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 17 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 30 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 15"
+  "lbbo\t%1, %16, 0, 60"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_15_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 16 "register_operand" "r")
+                           (match_operand:SI 17 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 15"
+  "sbbo\t%1, %16, %17, 60"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_15"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 16 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 17 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 16)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 15"
+  "sbbo\t%1, %16, 0, 60"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_16_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 17 "register_operand" "r")
+                           (match_operand:SI 18 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 33 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 16"
+  "lbbo\t%1, %17, %18, 64"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_16"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 17 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 18 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 32 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 16"
+  "lbbo\t%1, %17, 0, 64"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_16_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 17 "register_operand" "r")
+                           (match_operand:SI 18 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 16"
+  "sbbo\t%1, %17, %18, 64"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_16"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 17 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 18 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 17)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 16"
+  "sbbo\t%1, %17, 0, 64"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_17_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 18 "register_operand" "r")
+                           (match_operand:SI 19 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 35 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 17"
+  "lbbo\t%1, %18, %19, 68"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_17"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 18 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 19 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 34 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 17"
+  "lbbo\t%1, %18, 0, 68"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_17_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 18 "register_operand" "r")
+                           (match_operand:SI 19 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 17"
+  "sbbo\t%1, %18, %19, 68"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_17"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 18 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 19 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 18)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 17"
+  "sbbo\t%1, %18, 0, 68"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_18_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 19 "register_operand" "r")
+                           (match_operand:SI 20 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 37 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 18"
+  "lbbo\t%1, %19, %20, 72"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_18"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 19 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 20 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 36 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 18"
+  "lbbo\t%1, %19, 0, 72"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_18_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 19 "register_operand" "r")
+                           (match_operand:SI 20 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 18"
+  "sbbo\t%1, %19, %20, 72"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_18"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 19 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 20 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 19)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 18"
+  "sbbo\t%1, %19, 0, 72"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_19_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 20 "register_operand" "r")
+                           (match_operand:SI 21 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 39 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 19"
+  "lbbo\t%1, %20, %21, 76"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_19"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 20 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 21 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 38 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 19"
+  "lbbo\t%1, %20, 0, 76"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_19_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 20 "register_operand" "r")
+                           (match_operand:SI 21 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 19"
+  "sbbo\t%1, %20, %21, 76"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_19"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 20 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 21 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 20)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 19"
+  "sbbo\t%1, %20, 0, 76"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_20_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 21 "register_operand" "r")
+                           (match_operand:SI 22 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 41 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 20"
+  "lbbo\t%1, %21, %22, 80"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_20"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 21 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 22 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 40 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 20"
+  "lbbo\t%1, %21, 0, 80"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_20_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 21 "register_operand" "r")
+                           (match_operand:SI 22 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 20"
+  "sbbo\t%1, %21, %22, 80"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_20"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 21 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 22 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 21)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 20"
+  "sbbo\t%1, %21, 0, 80"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_21_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 22 "register_operand" "r")
+                           (match_operand:SI 23 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 43 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 21"
+  "lbbo\t%1, %22, %23, 84"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_21"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 22 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 23 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 42 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 21"
+  "lbbo\t%1, %22, 0, 84"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_21_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 22 "register_operand" "r")
+                           (match_operand:SI 23 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 21"
+  "sbbo\t%1, %22, %23, 84"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_21"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 22 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 23 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 22)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 21"
+  "sbbo\t%1, %22, 0, 84"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_22_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 23 "register_operand" "r")
+                           (match_operand:SI 24 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 45 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 22"
+  "lbbo\t%1, %23, %24, 88"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_22"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 23 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 24 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 44 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 22"
+  "lbbo\t%1, %23, 0, 88"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_22_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 23 "register_operand" "r")
+                           (match_operand:SI 24 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 22"
+  "sbbo\t%1, %23, %24, 88"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_22"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 23 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 24 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 23)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 22"
+  "sbbo\t%1, %23, 0, 88"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_23_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 24 "register_operand" "r")
+                           (match_operand:SI 25 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 47 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 23"
+  "lbbo\t%1, %24, %25, 92"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_23"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 24 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 25 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 46 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 23"
+  "lbbo\t%1, %24, 0, 92"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_23_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 24 "register_operand" "r")
+                           (match_operand:SI 25 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 23"
+  "sbbo\t%1, %24, %25, 92"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_23"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 24 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 25 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 24)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 23"
+  "sbbo\t%1, %24, 0, 92"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_24_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 25 "register_operand" "r")
+                           (match_operand:SI 26 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 49 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 24"
+  "lbbo\t%1, %25, %26, 96"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_24"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 25 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 26 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 48 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 24"
+  "lbbo\t%1, %25, 0, 96"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_24_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 25 "register_operand" "r")
+                           (match_operand:SI 26 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 24"
+  "sbbo\t%1, %25, %26, 96"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_24"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 25 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 26 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 25)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 24"
+  "sbbo\t%1, %25, 0, 96"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_25_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 26 "register_operand" "r")
+                           (match_operand:SI 27 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 51 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 25"
+  "lbbo\t%1, %26, %27, 100"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_25"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 26 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 27 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 50 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 25"
+  "lbbo\t%1, %26, 0, 100"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_25_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 26 "register_operand" "r")
+                           (match_operand:SI 27 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 25"
+  "sbbo\t%1, %26, %27, 100"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_25"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 26 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 27 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 26)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 25"
+  "sbbo\t%1, %26, 0, 100"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_26_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 27 "register_operand" "r")
+                           (match_operand:SI 28 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 53 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 26"
+  "lbbo\t%1, %27, %28, 104"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_26"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 27 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 28 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 52 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 26"
+  "lbbo\t%1, %27, 0, 104"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_26_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 27 "register_operand" "r")
+                           (match_operand:SI 28 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 26"
+  "sbbo\t%1, %27, %28, 104"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_26"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 27 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 28 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 27)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 26"
+  "sbbo\t%1, %27, 0, 104"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_27_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 28 "register_operand" "r")
+                           (match_operand:SI 29 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 53 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 54 "const_int_operand" "i"))))
+     (set (match_operand:SI 27 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 55 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 27"
+  "lbbo\t%1, %28, %29, 108"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_27"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 28 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 29 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 53 "const_int_operand" "i"))))
+     (set (match_operand:SI 27 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 54 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 27"
+  "lbbo\t%1, %28, 0, 108"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_27_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 28 "register_operand" "r")
+                           (match_operand:SI 29 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 54 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 55 "const_int_operand" "i")))
+          (match_operand:SI 27 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 27"
+  "sbbo\t%1, %28, %29, 108"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_27"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 28 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 29 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 28)
+                           (match_operand:SI 54 "const_int_operand" "i")))
+          (match_operand:SI 27 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 27"
+  "sbbo\t%1, %28, 0, 108"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_28_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 29 "register_operand" "r")
+                           (match_operand:SI 30 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 53 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 54 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 55 "const_int_operand" "i"))))
+     (set (match_operand:SI 27 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 56 "const_int_operand" "i"))))
+     (set (match_operand:SI 28 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 57 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 28"
+  "lbbo\t%1, %29, %30, 112"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_28"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 29 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 30 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 53 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 54 "const_int_operand" "i"))))
+     (set (match_operand:SI 27 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 55 "const_int_operand" "i"))))
+     (set (match_operand:SI 28 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 56 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 28"
+  "lbbo\t%1, %29, 0, 112"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_28_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 29 "register_operand" "r")
+                           (match_operand:SI 30 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 54 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 55 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 56 "const_int_operand" "i")))
+          (match_operand:SI 27 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 57 "const_int_operand" "i")))
+          (match_operand:SI 28 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 28"
+  "sbbo\t%1, %29, %30, 112"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_28"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 29 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 30 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 54 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 55 "const_int_operand" "i")))
+          (match_operand:SI 27 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 29)
+                           (match_operand:SI 56 "const_int_operand" "i")))
+          (match_operand:SI 28 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 28"
+  "sbbo\t%1, %29, 0, 112"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_29_offs"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (plus:SI (match_operand:SI 30 "register_operand" "r")
+                           (match_operand:SI 31 "const_ubyte_operand" "I"))))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 53 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 54 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 55 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 56 "const_int_operand" "i"))))
+     (set (match_operand:SI 27 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 57 "const_int_operand" "i"))))
+     (set (match_operand:SI 28 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 58 "const_int_operand" "i"))))
+     (set (match_operand:SI 29 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 59 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 29"
+  "lbbo\t%1, %30, %31, 116"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*lbbo_multiple_29"
+  [(match_parallel 0 "pru_load_multiple_operation"
+    [(set (match_operand:SI 1 "register_operand" "")
+          (mem:SI (match_operand:SI 30 "register_operand" "r")))
+     (set (match_operand:SI 2 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 31 "const_int_operand" "i"))))
+     (set (match_operand:SI 3 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 32 "const_int_operand" "i"))))
+     (set (match_operand:SI 4 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 33 "const_int_operand" "i"))))
+     (set (match_operand:SI 5 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 34 "const_int_operand" "i"))))
+     (set (match_operand:SI 6 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 35 "const_int_operand" "i"))))
+     (set (match_operand:SI 7 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 36 "const_int_operand" "i"))))
+     (set (match_operand:SI 8 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 37 "const_int_operand" "i"))))
+     (set (match_operand:SI 9 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 38 "const_int_operand" "i"))))
+     (set (match_operand:SI 10 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 39 "const_int_operand" "i"))))
+     (set (match_operand:SI 11 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 40 "const_int_operand" "i"))))
+     (set (match_operand:SI 12 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 41 "const_int_operand" "i"))))
+     (set (match_operand:SI 13 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 42 "const_int_operand" "i"))))
+     (set (match_operand:SI 14 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 43 "const_int_operand" "i"))))
+     (set (match_operand:SI 15 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 44 "const_int_operand" "i"))))
+     (set (match_operand:SI 16 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 45 "const_int_operand" "i"))))
+     (set (match_operand:SI 17 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 46 "const_int_operand" "i"))))
+     (set (match_operand:SI 18 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 47 "const_int_operand" "i"))))
+     (set (match_operand:SI 19 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 48 "const_int_operand" "i"))))
+     (set (match_operand:SI 20 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 49 "const_int_operand" "i"))))
+     (set (match_operand:SI 21 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 50 "const_int_operand" "i"))))
+     (set (match_operand:SI 22 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 51 "const_int_operand" "i"))))
+     (set (match_operand:SI 23 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 52 "const_int_operand" "i"))))
+     (set (match_operand:SI 24 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 53 "const_int_operand" "i"))))
+     (set (match_operand:SI 25 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 54 "const_int_operand" "i"))))
+     (set (match_operand:SI 26 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 55 "const_int_operand" "i"))))
+     (set (match_operand:SI 27 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 56 "const_int_operand" "i"))))
+     (set (match_operand:SI 28 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 57 "const_int_operand" "i"))))
+     (set (match_operand:SI 29 "register_operand" "")
+          (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 58 "const_int_operand" "i"))))])]
+  "XVECLEN (operands[0], 0) == 29"
+  "lbbo\t%1, %30, 0, 116"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_29_offs"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (plus:SI (match_operand:SI 30 "register_operand" "r")
+                           (match_operand:SI 31 "const_ubyte_operand" "I")))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 54 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 55 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 56 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 57 "const_int_operand" "i")))
+          (match_operand:SI 27 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 58 "const_int_operand" "i")))
+          (match_operand:SI 28 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 59 "const_int_operand" "i")))
+          (match_operand:SI 29 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 29"
+  "sbbo\t%1, %30, %31, 116"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
+(define_insn "*sbbo_multiple_29"
+  [(match_parallel 0 "pru_store_multiple_operation"
+    [(set (mem:SI (match_operand:SI 30 "register_operand" "r"))
+          (match_operand:SI 1 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 31 "const_int_operand" "i")))
+          (match_operand:SI 2 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 32 "const_int_operand" "i")))
+          (match_operand:SI 3 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 33 "const_int_operand" "i")))
+          (match_operand:SI 4 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 34 "const_int_operand" "i")))
+          (match_operand:SI 5 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 35 "const_int_operand" "i")))
+          (match_operand:SI 6 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 36 "const_int_operand" "i")))
+          (match_operand:SI 7 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 37 "const_int_operand" "i")))
+          (match_operand:SI 8 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 38 "const_int_operand" "i")))
+          (match_operand:SI 9 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 39 "const_int_operand" "i")))
+          (match_operand:SI 10 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 40 "const_int_operand" "i")))
+          (match_operand:SI 11 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 41 "const_int_operand" "i")))
+          (match_operand:SI 12 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 42 "const_int_operand" "i")))
+          (match_operand:SI 13 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 43 "const_int_operand" "i")))
+          (match_operand:SI 14 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 44 "const_int_operand" "i")))
+          (match_operand:SI 15 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 45 "const_int_operand" "i")))
+          (match_operand:SI 16 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 46 "const_int_operand" "i")))
+          (match_operand:SI 17 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 47 "const_int_operand" "i")))
+          (match_operand:SI 18 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 48 "const_int_operand" "i")))
+          (match_operand:SI 19 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 49 "const_int_operand" "i")))
+          (match_operand:SI 20 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 50 "const_int_operand" "i")))
+          (match_operand:SI 21 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 51 "const_int_operand" "i")))
+          (match_operand:SI 22 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 52 "const_int_operand" "i")))
+          (match_operand:SI 23 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 53 "const_int_operand" "i")))
+          (match_operand:SI 24 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 54 "const_int_operand" "i")))
+          (match_operand:SI 25 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 55 "const_int_operand" "i")))
+          (match_operand:SI 26 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 56 "const_int_operand" "i")))
+          (match_operand:SI 27 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 57 "const_int_operand" "i")))
+          (match_operand:SI 28 "register_operand" ""))
+     (set (mem:SI (plus:SI (match_dup 30)
+                           (match_operand:SI 58 "const_int_operand" "i")))
+          (match_operand:SI 29 "register_operand" ""))])]
+  "XVECLEN (operands[0], 0) == 29"
+  "sbbo\t%1, %30, 0, 116"
+  [(set_attr "type" "ld")
+   (set_attr "length" "4")])
+
diff --git a/gcc/config/pru/pru-ldst-multiple.ml b/gcc/config/pru/pru-ldst-multiple.ml
new file mode 100644
index 0000000..bcf22f8
--- /dev/null
+++ b/gcc/config/pru/pru-ldst-multiple.ml
@@ -0,0 +1,145 @@
+(* Auto-generate PRU load/store-multiple patterns
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Based on arm-ldmstm.ml
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3, or (at your option) any later
+   version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.
+
+   This is an O'Caml program.  The O'Caml compiler is available from:
+
+     http://caml.inria.fr/
+
+   Or from your favourite OS's friendly packaging system. Tested with version
+   4.01.0, though other versions will probably work too.
+
+   Run with:
+     ocaml pru-ldst-multiple.ml >/path/to/gcc/config/pru/ldst-multiple.md
+*)
+
+let destreg nregs first =
+  if not first then
+    Printf.sprintf "(match_dup %d)" (nregs + 1)
+  else
+    Printf.sprintf ("(match_operand:SI %d \"register_operand\" \"r\")")
+      (nregs + 1)
+
+let write_ldm_set nregs opnr first do_first_offs =
+  let indent = "     " in
+  Printf.printf "%s" (if first then "    [" else indent);
+  Printf.printf "(set (match_operand:SI %d \"register_operand\" \"\")\n" opnr;
+  Printf.printf "%s     (mem:SI " indent;
+  if (first && not do_first_offs) then begin
+    Printf.printf "%s" (destreg nregs first);
+  end else begin
+    Printf.printf "(plus:SI %s" (destreg nregs first);
+    Printf.printf "\n%s                      (match_operand:SI %d "
+      indent
+      (if do_first_offs then (nregs + 1 + opnr) else (nregs + opnr));
+    if first then
+      Printf.printf "\"const_ubyte_operand\" \"I\"))"
+    else
+      Printf.printf "\"const_int_operand\" \"i\"))"
+  end;
+  Printf.printf "))"
+
+let write_stm_set nregs opnr first do_first_offs =
+  let indent = "     " in
+  Printf.printf "%s" (if first then "    [" else indent);
+  Printf.printf "(set (mem:SI ";
+  if (first && not do_first_offs) then begin
+    Printf.printf "%s" (destreg nregs first);
+  end else begin
+    Printf.printf "(plus:SI ";
+    Printf.printf "%s" (destreg nregs first);
+    Printf.printf "\n%s                      (match_operand:SI %d "
+      indent
+      (if do_first_offs then (nregs + 1 + opnr) else (nregs + opnr));
+    begin if first then
+      Printf.printf "\"const_ubyte_operand\" \"I\"))"
+    else
+      Printf.printf "\"const_int_operand\" \"i\"))"
+    end;
+  end;
+  Printf.printf ")\n%s     (match_operand:SI %d \"register_operand\" \"\"))" indent opnr
+
+let rec write_pat_sets func opnr first n_left do_first_offs =
+  func opnr first do_first_offs;
+  begin
+    if n_left > 1 then begin
+      Printf.printf "\n";
+      write_pat_sets func (opnr + 1) false (n_left - 1) do_first_offs;
+    end else
+      Printf.printf "]"
+  end
+
+exception InvalidAddrMode of string;;
+
+let write_pattern_1 name ls nregs do_first_offs write_set_fn =
+  Printf.printf "(define_insn \"*%s_multiple_%d%s\"\n" name nregs
+    (if do_first_offs then "_offs" else "");
+  Printf.printf "  [(match_parallel 0 \"pru_%s_multiple_operation\"\n" ls;
+  write_pat_sets (write_set_fn nregs) 1 true nregs do_first_offs;
+  Printf.printf ")]\n  \"XVECLEN (operands[0], 0) == %d\"\n" nregs;
+  if do_first_offs then begin
+    Printf.printf "  \"%s\\t%%1, %%%d, %%%d, %d\"\n" name (nregs + 1) (nregs + 2) (nregs * 4);
+  end else begin
+    Printf.printf "  \"%s\\t%%1, %%%d, 0, %d\"\n" name (nregs + 1) (nregs * 4);
+  end;
+  Printf.printf "  [(set_attr \"type\" \"ld\")\n";
+  Printf.printf "   (set_attr \"length\" \"4\")";
+  Printf.printf "])\n\n"
+
+let patterns () =
+  (* The rule for load-multiple of a single register greatly simplifies
+     the prologue/epilogue code. *)
+  for nregs = 1 to 29; do
+    write_pattern_1 "lbbo" "load" nregs true write_ldm_set;
+    write_pattern_1 "lbbo" "load" nregs false write_ldm_set;
+    write_pattern_1 "sbbo" "store" nregs true write_stm_set;
+    write_pattern_1 "sbbo" "store" nregs false write_stm_set;
+  done
+
+let print_lines = List.iter (fun s -> Format.printf "%s@\n" s)
+
+(* Do it.  *)
+
+let _ =
+  print_lines [
+"/* PRU load/store instruction patterns.  This file was automatically";
+"   generated using pru-ldst-multiple.ml.  Please do not edit manually.";
+"";
+"   Copyright (C) 2014 Free Software Foundation, Inc.";
+"   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>.";
+"   Based on arm-ldmstm.ml";
+"";
+"   This file is part of GCC.";
+"";
+"   GCC is free software; you can redistribute it and/or modify it";
+"   under the terms of the GNU General Public License as published";
+"   by the Free Software Foundation; either version 3, or (at your";
+"   option) any later version.";
+"";
+"   GCC is distributed in the hope that it will be useful, but WITHOUT";
+"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY";
+"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public";
+"   License for more details.";
+"";
+"   You should have received a copy of the GNU General Public License and";
+"   a copy of the GCC Runtime Library Exception along with this program;";
+"   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see";
+"   <http://www.gnu.org/licenses/>.  */";
+""];
+  patterns ();
diff --git a/gcc/config/pru/pru-modes.def b/gcc/config/pru/pru-modes.def
new file mode 100644
index 0000000..d37259a
--- /dev/null
+++ b/gcc/config/pru/pru-modes.def
@@ -0,0 +1,29 @@
+/* Definitions of target machine for GCC for PRU
+   Copyright (C) 2002-2015 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+INT_MODE (OI, 32);
+INT_MODE (XI, 64);
+
+/* Keep the OI and XI modes from confusing the compiler into thinking
+   that these modes could actually be used for computation.  They are
+   only holders for vectors during data movement.  */
+#define MAX_BITSIZE_MODE_ANY_INT (128)
+
+/* The symbol Pmode stands for one of the above machine modes (usually SImode).
+   The tm.h file specifies which one.  It is not a distinct mode.  */
diff --git a/gcc/config/pru/pru-pragma.c b/gcc/config/pru/pru-pragma.c
new file mode 100644
index 0000000..f3d6c49
--- /dev/null
+++ b/gcc/config/pru/pru-pragma.c
@@ -0,0 +1,96 @@
+/* PRU target specific pragmas
+   Copyright (C) 2015 Free Software Foundation, Inc.
+   Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "hash-set.h"
+#include "machmode.h"
+#include "vec.h"
+#include "double-int.h"
+#include "input.h"
+#include "alias.h"
+#include "symtab.h"
+#include "wide-int.h"
+#include "inchash.h"
+#include "tree.h"
+#include "c-family/c-pragma.h"
+#include "c-family/c-common.h"
+#include "diagnostic-core.h"
+#include "cpplib.h"
+#include "pru-protos.h"
+
+
+/* Implements the "pragma CTABLE_ENTRY" pragma.  This pragma takes a
+   CTABLE index and an address, and instructs the compiler that
+   LBCO/SBCO can be used on that base address.
+
+   WARNING: Only immediate constant addresses are currently supported. */
+static void
+pru_pragma_ctable_entry (cpp_reader * reader ATTRIBUTE_UNUSED)
+{
+  /* on off */
+  tree ctable_index, base_addr;
+  enum cpp_ttype type;
+
+  type = pragma_lex (&ctable_index);
+  if (type == CPP_NUMBER)
+    {
+      type = pragma_lex (&base_addr);
+      if (type == CPP_NUMBER)
+	{
+	  unsigned int i = tree_to_uhwi (ctable_index);
+	  unsigned HOST_WIDE_INT base = tree_to_uhwi (base_addr);
+
+	  type = pragma_lex (&base_addr);
+	  if (type != CPP_EOF)
+	    {
+	      error ("junk at end of #pragma CTABLE_ENTRY");
+	    }
+	  else if (i >= ARRAY_SIZE (pru_ctable))
+	    {
+	      error ("CTABLE_ENTRY index %d is not valid", i);
+	    }
+	  else if (pru_ctable[i].valid && pru_ctable[i].base != base)
+	    {
+	      error ("redefinition of CTABLE_ENTRY %d", i);
+	    }
+	  else
+	    {
+	      if (base & 0xff)
+		warning (0, "CTABLE_ENTRY base address is not a multiple of 256");
+	      pru_ctable[i].base = base;
+	      pru_ctable[i].valid = true;
+	    }
+	  return;
+	}
+    }
+  error ("malformed #pragma CTABLE_ENTRY variable address");
+}
+
+/* Implements REGISTER_TARGET_PRAGMAS.  */
+void
+pru_register_pragmas (void)
+{
+  c_register_pragma (NULL, "ctable_entry", pru_pragma_ctable_entry);
+  c_register_pragma (NULL, "CTABLE_ENTRY", pru_pragma_ctable_entry);
+}
+
diff --git a/gcc/config/pru/pru-protos.h b/gcc/config/pru/pru-protos.h
new file mode 100644
index 0000000..4c03b4a
--- /dev/null
+++ b/gcc/config/pru/pru-protos.h
@@ -0,0 +1,60 @@
+/* Subroutine declarations for TI PRU target support.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+   Contributed by Jonah Graham (jgraham@altera.com).
+   Contributed by Mentor Graphics, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_PRU_PROTOS_H
+#define GCC_PRU_PROTOS_H
+
+struct pru_ctable_entry {
+    bool valid;
+    unsigned HOST_WIDE_INT base;
+};
+
+extern struct pru_ctable_entry pru_ctable[32];
+
+extern int pru_initial_elimination_offset (int, int);
+extern int pru_can_use_return_insn (void);
+extern void pru_expand_prologue (void);
+extern void pru_expand_epilogue (bool);
+extern void pru_function_profiler (FILE *, int);
+
+void pru_register_pragmas (void);
+
+#ifdef RTX_CODE
+extern rtx pru_get_return_address (int);
+
+extern const char * pru_output_sign_extend (rtx *);
+extern const char * pru_output_signed_cbranch (rtx *, bool);
+extern const char * pru_output_signed_cbranch_ubyteop2 (rtx *, bool);
+
+extern bool pru_regno_ok_for_base_p (int, bool);
+static inline bool pru_regno_ok_for_index_p (int regno, bool strict_p)
+{
+  /* selection logic is the same - PRU instructions are quite orthogonal */
+  return pru_regno_ok_for_base_p (regno, strict_p);
+}
+
+extern int pru_get_ctable_exact_base_index (unsigned HOST_WIDE_INT caddr);
+extern int pru_get_ctable_base_index (unsigned HOST_WIDE_INT caddr);
+extern int pru_get_ctable_base_offset (unsigned HOST_WIDE_INT caddr);
+
+#endif /* RTX_CODE */
+
+#endif /* GCC_PRU_PROTOS_H */
diff --git a/gcc/config/pru/pru.c b/gcc/config/pru/pru.c
new file mode 100644
index 0000000..b476760
--- /dev/null
+++ b/gcc/config/pru/pru.c
@@ -0,0 +1,1766 @@
+/* Target machine subroutines for TI PRU.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "hash-set.h"
+#include "machmode.h"
+#include "vec.h"
+#include "double-int.h"
+#include "input.h"
+#include "alias.h"
+#include "symtab.h"
+#include "wide-int.h"
+#include "inchash.h"
+#include "tree.h"
+#include "fold-const.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "hashtab.h"
+#include "function.h"
+#include "statistics.h"
+#include "real.h"
+#include "fixed-value.h"
+#include "expmed.h"
+#include "dojump.h"
+#include "explow.h"
+#include "calls.h"
+#include "emit-rtl.h"
+#include "varasm.h"
+#include "stmt.h"
+#include "expr.h"
+#include "insn-codes.h"
+#include "optabs.h"
+#include "ggc.h"
+#include "predict.h"
+#include "dominance.h"
+#include "cfg.h"
+#include "cfgrtl.h"
+#include "cfganal.h"
+#include "lcm.h"
+#include "cfgbuild.h"
+#include "cfgcleanup.h"
+#include "basic-block.h"
+#include "diagnostic-core.h"
+#include "toplev.h"
+#include "target.h"
+#include "target-def.h"
+#include "tm_p.h"
+#include "langhooks.h"
+#include "df.h"
+#include "debug.h"
+#include "reload.h"
+#include "stor-layout.h"
+#include "builtins.h"
+#include "pru-protos.h"
+
+/* Global PRU CTABLE entries, filled in by pragmaes, and used for fast
+   addressing via LBCO/SBCO instructions. */
+struct pru_ctable_entry pru_ctable[32];
+
+/* Forward function declarations.  */
+static bool prologue_saved_reg_p (unsigned);
+
+struct GTY (()) machine_function
+{
+  /* Current frame information, to be filled in by pru_compute_frame_layout
+     with register save masks, and offsets for the current function.  */
+
+  /* Mask of registers to save.  */
+  unsigned int save_mask;
+  /* Number of bytes that the entire frame takes up.  */
+  int total_size;
+  /* Number of bytes that variables take up.  */
+  int var_size;
+  /* Number of bytes that outgoing arguments take up.  */
+  int args_size;
+  /* Number of bytes needed to store registers in frame.  */
+  int save_reg_size;
+  /* Offset from new stack pointer to store registers.  */
+  int save_regs_offset;
+  /* Offset from save_regs_offset to store frame pointer register.  */
+  int fp_save_offset;
+  /* != 0 if frame layout already calculated.  */
+  int initialized;
+};
+
+
+
+/* Stack layout and calling conventions.  */
+
+#define PRU_STACK_ALIGN(LOC)						\
+  (((LOC) + ((PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT) - 1))		\
+   & ~((PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT) - 1))
+
+/* Return the bytes needed to compute the frame pointer from the current
+   stack pointer.  */
+static int
+pru_compute_frame_layout (void)
+{
+  unsigned int regno;
+  unsigned int save_mask = 0;
+  int total_size;
+  int var_size;
+  int out_args_size;
+  int save_reg_size;
+
+  if (cfun->machine->initialized)
+    return cfun->machine->total_size;
+
+  var_size = PRU_STACK_ALIGN (get_frame_size ());
+  out_args_size = PRU_STACK_ALIGN (crtl->outgoing_args_size);
+  total_size = var_size + out_args_size;
+
+  /* Calculate space needed for gp registers.  */
+  save_reg_size = 0;
+  for (regno = 0; regno <= LAST_GP_REG; regno++)
+    if (prologue_saved_reg_p (regno))
+      {
+	save_mask |= 1 << regno;
+	save_reg_size += 4;
+      }
+
+  cfun->machine->fp_save_offset = 0;
+  if (save_mask & (1 << HARD_FRAME_POINTER_REGNUM))
+    {
+      int fp_save_offset = 0;
+      for (regno = 0; regno < HARD_FRAME_POINTER_REGNUM; regno++)
+	if (save_mask & (1 << regno))
+	  fp_save_offset += 4;
+
+      cfun->machine->fp_save_offset = fp_save_offset;
+    }
+
+  save_reg_size = PRU_STACK_ALIGN (save_reg_size);
+  total_size += save_reg_size;
+  total_size += PRU_STACK_ALIGN (crtl->args.pretend_args_size);
+
+  /* Save other computed information.  */
+  cfun->machine->save_mask = save_mask;
+  cfun->machine->total_size = total_size;
+  cfun->machine->var_size = var_size;
+  cfun->machine->args_size = out_args_size;
+  cfun->machine->save_reg_size = save_reg_size;
+  cfun->machine->initialized = reload_completed;
+  cfun->machine->save_regs_offset = out_args_size + var_size;
+
+  return total_size;
+}
+
+/* Add a const_int to the stack pointer register. */
+static rtx
+pru_add_to_sp (int addendum, const enum reg_note kind)
+{
+  rtx insn;
+
+  rtx sp_adjust
+    = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+		   plus_constant (Pmode, stack_pointer_rtx, addendum));
+  if (UBYTE_INT (addendum) || UBYTE_INT (-addendum))
+    insn = emit_insn (sp_adjust);
+  else
+    {
+      /* Help the compiler to cope with an arbitrary integer constant.
+	 Reload has finished so we can't expect the compiler to
+	 auto-allocate a temporary register. But we know that call-saved
+	 registers are not live yet, so we utilize them. */
+      rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TEMP_REGNO);
+      if (addendum < 0)
+	{
+	  emit_move_insn (tmp, gen_int_mode (-addendum, Pmode));
+	  insn = emit_insn (gen_sub2_insn (stack_pointer_rtx, tmp));
+	}
+      else
+	{
+	  emit_move_insn (tmp, gen_int_mode (addendum, Pmode));
+	  insn = emit_insn (gen_add2_insn (stack_pointer_rtx, tmp));
+	}
+    }
+
+  /* Attach the sp_adjust as a note indicating what happened.  */
+  if (kind != REG_NOTE_MAX)
+    add_reg_note (insn, kind, sp_adjust);
+
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  return insn;
+}
+
+/* Helper function used during prologue/epilogue. Emits a single LBBO/SBBO
+   instruction for load/store of the next group of consecutive registers. */
+static int
+xbbo_next_reg_cluster (int regno_start, int *sp_offset, bool do_store)
+{
+  int regno, nregs, i;
+  rtx addr, insn, pat;
+
+  nregs = 0;
+
+  /* Skip the empty slots */
+  for (; regno_start <= LAST_GP_REG; )
+    if (cfun->machine->save_mask & (1 << regno_start))
+      break;
+    else
+      regno_start++;
+
+  /* Find the largest consecutive group of registers to save */
+  for (regno = regno_start; regno <= LAST_GP_REG; )
+    if (cfun->machine->save_mask & (1 << regno))
+      {
+	regno++;
+	nregs++;
+      }
+    else
+      break;
+
+  if (!nregs)
+    return -1;
+
+  gcc_assert (UBYTE_INT (*sp_offset));
+
+  /* ok, save this bunch */
+  addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,
+		       gen_int_mode (*sp_offset, Pmode));
+
+  if (do_store)
+    insn = gen_store_multiple (gen_frame_mem (Pmode, addr),
+			       gen_rtx_REG (SImode, regno_start),
+			       GEN_INT (nregs));
+  else
+    insn = gen_load_multiple (gen_rtx_REG (SImode, regno_start),
+			      gen_frame_mem (Pmode, addr),
+			      GEN_INT (nregs));
+
+  gcc_assert (insn);
+  emit_insn (insn);
+
+  /* Tag as frame-related. */
+  pat = PATTERN (insn);
+  for (i = 0; i < XVECLEN (pat, 0); i++)
+    if (GET_CODE (XVECEXP (pat, 0, i)) == SET)
+      {
+	RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;
+	if (do_store)
+	  {
+	    /* Tag epilogue unwind note.  */
+	    rtx reg = SET_SRC (XVECEXP (pat, 0, i));
+	    add_reg_note (insn, REG_CFA_RESTORE, reg);
+	  }
+      }
+
+  /* increment and save offset in anticipation of the next register group */
+  *sp_offset += nregs * UNITS_PER_WORD;
+
+  return regno_start + nregs;
+}
+
+void
+pru_expand_prologue (void)
+{
+  int regno_start;
+  int total_frame_size;
+  int sp_offset;      /* offset from base_reg to final stack value.  */
+  int save_regs_base; /* offset from base_reg to register save area.  */
+  int save_offset;    /* temporary offset to currently saved register group */
+  rtx insn;
+
+  total_frame_size = pru_compute_frame_layout ();
+
+  if (flag_stack_usage_info)
+    current_function_static_stack_size = total_frame_size;
+
+  /* Decrement the stack pointer.  */
+  if (!UBYTE_INT (total_frame_size))
+    {
+      /* We need an intermediary point, this will point at the spill block. */
+      insn = pru_add_to_sp (cfun->machine->save_regs_offset
+			     - total_frame_size,
+			     REG_NOTE_MAX);
+      save_regs_base = 0;
+      sp_offset = -cfun->machine->save_regs_offset;
+    }
+  else if (total_frame_size)
+    {
+      insn = emit_insn (gen_sub2_insn (stack_pointer_rtx,
+				       gen_int_mode (total_frame_size,
+						     Pmode)));
+      RTX_FRAME_RELATED_P (insn) = 1;
+      save_regs_base = cfun->machine->save_regs_offset;
+      sp_offset = 0;
+    }
+  else
+    save_regs_base = sp_offset = 0;
+
+  regno_start = 0;
+  save_offset = save_regs_base;
+  do {
+      regno_start = xbbo_next_reg_cluster (regno_start, &save_offset, true);
+  } while (regno_start >= 0);
+
+  if (frame_pointer_needed)
+    {
+      int fp_save_offset = save_regs_base + cfun->machine->fp_save_offset;
+      insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,
+				       stack_pointer_rtx,
+				       gen_int_mode (fp_save_offset, Pmode)));
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+
+  if (sp_offset)
+      insn = pru_add_to_sp (sp_offset, REG_FRAME_RELATED_EXPR);
+
+  /* If we are profiling, make sure no instructions are scheduled before
+     the call to mcount.  */
+  if (crtl->profile)
+    emit_insn (gen_blockage ());
+}
+
+void
+pru_expand_epilogue (bool sibcall_p)
+{
+  rtx insn, cfa_adj;
+  int total_frame_size;
+  int sp_adjust, save_offset;
+  int regno_start;
+
+  if (!sibcall_p && pru_can_use_return_insn ())
+    {
+      emit_jump_insn (gen_return ());
+      return;
+    }
+
+  emit_insn (gen_blockage ());
+
+  total_frame_size = pru_compute_frame_layout ();
+  if (frame_pointer_needed)
+    {
+      /* Recover the stack pointer.  */
+      insn = emit_insn (gen_sub3_insn
+			(stack_pointer_rtx, hard_frame_pointer_rtx,
+			 gen_int_mode (cfun->machine->fp_save_offset, Pmode)));
+      cfa_adj = plus_constant (Pmode, stack_pointer_rtx,
+			       (total_frame_size
+				- cfun->machine->save_regs_offset));
+      add_reg_note (insn, REG_CFA_DEF_CFA, cfa_adj);
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+      save_offset = 0;
+      sp_adjust = total_frame_size - cfun->machine->save_regs_offset;
+    }
+  else if (!UBYTE_INT (total_frame_size))
+    {
+      insn = pru_add_to_sp (cfun->machine->save_regs_offset,
+			    REG_CFA_ADJUST_CFA);
+      save_offset = 0;
+      sp_adjust = total_frame_size - cfun->machine->save_regs_offset;
+    }
+  else
+    {
+      save_offset = cfun->machine->save_regs_offset;
+      sp_adjust = total_frame_size;
+    }
+
+  regno_start = 0;
+  do {
+      regno_start = xbbo_next_reg_cluster (regno_start, &save_offset, false);
+  } while (regno_start >= 0);
+
+  if (sp_adjust)
+      insn = pru_add_to_sp (sp_adjust, REG_CFA_ADJUST_CFA);
+
+  if (!sibcall_p)
+    emit_jump_insn (gen_simple_return ());
+}
+
+/* Implement RETURN_ADDR_RTX.  Note, we do not support moving
+   back to a previous frame.  */
+rtx
+pru_get_return_address (int count)
+{
+  if (count != 0)
+    return const0_rtx;
+
+  return get_hard_reg_initial_val (Pmode, RA_REGNO);
+}
+
+/* Implement FUNCTION_PROFILER macro.  */
+void
+pru_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)
+{
+  fprintf (file, "\tmov\tr1, ra\n");
+  fprintf (file, "\tcall\t_mcount\n");
+  fprintf (file, "\tmov\tra, r1\n");
+}
+
+/* Dump stack layout.  */
+static void
+pru_dump_frame_layout (FILE *file)
+{
+  fprintf (file, "\t%s Current Frame Info\n", ASM_COMMENT_START);
+  fprintf (file, "\t%s total_size = %d\n", ASM_COMMENT_START,
+           cfun->machine->total_size);
+  fprintf (file, "\t%s var_size = %d\n", ASM_COMMENT_START,
+           cfun->machine->var_size);
+  fprintf (file, "\t%s args_size = %d\n", ASM_COMMENT_START,
+           cfun->machine->args_size);
+  fprintf (file, "\t%s save_reg_size = %d\n", ASM_COMMENT_START,
+           cfun->machine->save_reg_size);
+  fprintf (file, "\t%s initialized = %d\n", ASM_COMMENT_START,
+           cfun->machine->initialized);
+  fprintf (file, "\t%s save_regs_offset = %d\n", ASM_COMMENT_START,
+           cfun->machine->save_regs_offset);
+  fprintf (file, "\t%s is_leaf = %d\n", ASM_COMMENT_START,
+           crtl->is_leaf);
+  fprintf (file, "\t%s frame_pointer_needed = %d\n", ASM_COMMENT_START,
+           frame_pointer_needed);
+  fprintf (file, "\t%s pretend_args_size = %d\n", ASM_COMMENT_START,
+           crtl->args.pretend_args_size);
+}
+
+/* Return true if REGNO should be saved in the prologue.  */
+static bool
+prologue_saved_reg_p (unsigned regno)
+{
+  gcc_assert (GP_REG_P (regno));
+
+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])
+    return true;
+
+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)
+    return true;
+
+  if (regno == RA_REGNO && df_regs_ever_live_p (RA_REGNO))
+    return true;
+
+  return false;
+}
+
+/* Implement TARGET_CAN_ELIMINATE.  */
+static bool
+pru_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)
+{
+  if (to == STACK_POINTER_REGNUM)
+    return !frame_pointer_needed;
+  return true;
+}
+
+/* Implement INITIAL_ELIMINATION_OFFSET macro.  */
+int
+pru_initial_elimination_offset (int from, int to)
+{
+  int offset;
+
+  pru_compute_frame_layout ();
+
+  /* Set OFFSET to the offset from the stack pointer.  */
+  switch (from)
+    {
+    case FRAME_POINTER_REGNUM:
+      offset = cfun->machine->args_size;
+      break;
+
+    case ARG_POINTER_REGNUM:
+      offset = cfun->machine->total_size;
+      offset -= crtl->args.pretend_args_size;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+    /* If we are asked for the frame pointer offset, then adjust OFFSET
+       by the offset from the frame pointer to the stack pointer.  */
+  if (to == HARD_FRAME_POINTER_REGNUM)
+    offset -= (cfun->machine->save_regs_offset
+	       + cfun->machine->fp_save_offset);
+
+  return offset;
+}
+
+/* Return nonzero if this function is known to have a null epilogue.
+   This allows the optimizer to omit jumps to jumps if no stack
+   was created.  */
+int
+pru_can_use_return_insn (void)
+{
+  if (!reload_completed || crtl->profile)
+    return 0;
+
+  return pru_compute_frame_layout () == 0;
+}
+
+
+
+/* Allocate a chunk of memory for per-function machine-dependent data.  */
+static struct machine_function *
+pru_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+/* Implement TARGET_OPTION_OVERRIDE.  */
+static void
+pru_option_override (void)
+{
+#ifdef SUBTARGET_OVERRIDE_OPTIONS
+  SUBTARGET_OVERRIDE_OPTIONS;
+#endif
+
+  /* Check for unsupported options.  */
+  if (flag_pic)
+    sorry ("position-independent code is not supported");
+
+  /* Function to allocate machine-dependent function status.  */
+  init_machine_status = &pru_init_machine_status;
+
+  /* Save the initial options in case the user does function specific
+     options.  */
+  target_option_default_node = target_option_current_node
+    = build_target_option_node (&global_options);
+}
+
+
+/* Compute a (partial) cost for rtx X.  Return true if the complete
+   cost has been computed, and false if subexpressions should be
+   scanned.  In either case, *TOTAL contains the cost result.  */
+static bool
+pru_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,
+		 int opno ATTRIBUTE_UNUSED,
+		 int *total, bool speed ATTRIBUTE_UNUSED)
+{
+  /* jumps and calls are very cheap on the PRU */
+  if (text_segment_operand (x, VOIDmode))
+    return COSTS_N_INSNS (0);
+
+  switch (code)
+    {
+      case CONST_INT:
+        if (UBYTE_INT (INTVAL (x)))
+          {
+            *total = COSTS_N_INSNS (0);
+            return true;
+          }
+        else if (outer_code == MEM && ctable_addr_operand (x, VOIDmode))
+          {
+            *total = COSTS_N_INSNS (0);
+            return true;
+          }
+        else
+          {
+            *total = COSTS_N_INSNS (1);
+            return true;
+          }
+
+      case LABEL_REF:
+      case SYMBOL_REF:
+      case CONST:
+      case CONST_DOUBLE:
+        {
+          *total = COSTS_N_INSNS (1);
+          return true;
+        }
+
+      case MULT:
+        {
+          *total = COSTS_N_INSNS (8);
+          return false;
+        }
+      case PLUS:
+	{
+	  rtx op0 = XEXP (x, 0);
+	  rtx op1 = XEXP (x, 1);
+	  if (outer_code == MEM
+	      && ((REG_P (op0) && reg_or_ubyte_operand (op1, VOIDmode))
+		  || (REG_P (op1) && reg_or_ubyte_operand (op0, VOIDmode))
+		  || (ctable_addr_operand (op0, VOIDmode) && op1 == NULL_RTX)
+		  || (ctable_addr_operand (op1, VOIDmode) && op0 == NULL_RTX)
+		  || (ctable_base_operand (op0, VOIDmode) && REG_P (op1))
+		  || (ctable_base_operand (op1, VOIDmode) && REG_P (op0))))
+	    {
+	      /* CTABLE or REG base addressing - PLUS comes for free */
+	      *total = COSTS_N_INSNS (0);
+	      return true;
+	    }
+	  else
+	    {
+	      *total = COSTS_N_INSNS (1);
+	      return false;
+	    }
+	}
+      case SIGN_EXTEND:
+        {
+          *total = COSTS_N_INSNS (3);
+          return false;
+        }
+      case ZERO_EXTEND:
+        {
+          *total = COSTS_N_INSNS (0);
+          return false;
+        }
+
+      default:
+        return false;
+    }
+}
+
+/* Implement TARGET_PREFERRED_RELOAD_CLASS.  */
+static reg_class_t
+pru_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, reg_class_t regclass)
+{
+  return regclass == NO_REGS ? GENERAL_REGS : regclass;
+}
+
+
+
+/* Sign extension.  */
+
+static int sign_bit_position (const rtx op)
+{
+  const int sz = GET_MODE_SIZE (GET_MODE (op));
+
+  return  sz * 8 - 1;
+}
+
+const char *
+pru_output_sign_extend (rtx *operands)
+{
+  static char buf[512];
+  int bufi;
+  const int dst_sz = GET_MODE_SIZE (GET_MODE (operands[0]));
+  const int src_sz = GET_MODE_SIZE (GET_MODE (operands[1]));
+  const int ext_start = src_sz;
+
+  gcc_assert (dst_sz > src_sz);
+
+  bufi = snprintf (buf, sizeof(buf),
+	  "mov\t%%0, %%x1\n\t"		      /* copy AND make positive */
+	  "qbbc\t.+8, %%x0, %d\n\t"	      /* check sign bit */
+	  "fill\t%%0.b%d, %d",		      /* make negative  */
+	  sign_bit_position(operands[1]),
+	  ext_start,
+	  dst_sz - src_sz);
+
+  gcc_assert (bufi > 0);
+  gcc_assert ((unsigned int)bufi < sizeof (buf));
+
+  return buf;
+}
+
+
+/* Branches and compares.  */
+
+/*
+ PRU's ALU does not support signed comparison operations. That's why we
+ emulate them. By first checking the sign bit and handling every possible
+ operand sign combination, we can simulate signed comparisons in just
+ 5 instructions. See table below.
+
+.-------------------.---------------------------------------------------.
+| Operand sign bit  | Mapping the signed comparison to an unsigned one  |
+|---------+---------+------------+------------+------------+------------|
+| OP1.b31 | OP2.b31 | OP1 < OP2  | OP1 <= OP2 | OP1 > OP2  | OP1 >= OP2 |
+|---------+---------+------------+------------+------------+------------|
+| 0       | 0       | OP1 < OP2  | OP1 <= OP2 | OP1 > OP2  | OP1 >= OP2 |
+|---------+---------+------------+------------+------------+------------|
+| 0       | 1       | false      | false      | true       | true       |
+|---------+---------+------------+------------+------------+------------|
+| 1       | 0       | true       | true       | false      | false      |
+|---------+---------+------------+------------+------------+------------|
+| 1       | 1       | OP1 < OP2  | OP1 <= OP2 | OP1 > OP2  | OP1 >= OP2 |
+`---------'---------'------------'------------'------------+------------'
+
+
+Given the table above, here is an example for a concrete op:
+  LT:
+                    qbbc OP1_POS, OP1, 31
+  OP1_NEG:          qbbc BRANCH_TAKEN_LABEL, OP2, 31
+  OP1_NEG_OP2_NEG:  qblt BRANCH_TAKEN_LABEL, OP2, OP1
+                    ; jmp OUT -> can be eliminated because we'll take the
+                    ; following branch. OP2.b31 is guaranteed to be 1
+                    ; by the time we get here.
+  OP1_POS:          qbbs OUT, OP2, 31
+  OP1_POS_OP2_POS:  qblt BRANCH_TAKEN_LABEL, OP2, OP1
+#if FAR_JUMP
+                    jmp OUT
+BRANCH_TAKEN_LABEL: jmp REAL_BRANCH_TAKEN_LABEL
+#endif
+  OUT:
+
+*/
+
+static const char *
+pru_output_ltle_signed_cbranch (rtx *operands, bool is_near)
+{
+  static char buf[1024];
+  enum rtx_code code = GET_CODE (operands[0]);
+  rtx op1;
+  rtx op2;
+  const char *cmp_opstr;
+  int bufi = 0;
+
+  op1 = operands[1];
+  op2 = operands[2];
+
+  gcc_assert (GET_CODE (op1) == REG && GET_CODE (op2) == REG);
+
+  /* determine the comparison operators for positive and negative operands */
+  if (code == LT)
+      cmp_opstr = "qblt";
+  else if (code == LE)
+      cmp_opstr = "qble";
+  else
+      gcc_unreachable();
+
+  if (is_near)
+    {
+      bufi = snprintf (buf, sizeof(buf),
+		       "qbbc\t.+12, %%x1, %d\n\t"
+		       "qbbc\t%%l3, %%x2, %d\n\t"   /* OP1_NEG         */
+		       "%s\t%%l3, %%x2, %%x1\n\t"   /* OP1_NEG_OP2_NEG */
+		       "qbbs\t.+8, %%x2, %d\n\t"    /* OP1_POS         */
+		       "%s\t%%l3, %%x2, %%x1",	    /* OP1_POS_OP2_POS */
+		       sign_bit_position(op1),
+		       sign_bit_position(op2),
+		       cmp_opstr,
+		       sign_bit_position(op2),
+		       cmp_opstr);
+    }
+  else
+    {
+      bufi = snprintf (buf, sizeof(buf),
+		       "qbbc\t.+12, %%x1, %d\n\t"
+		       "qbbc\t.+20, %%x2, %d\n\t"   /* OP1_NEG         */
+		       "%s\t.+16, %%x2, %%x1\n\t"   /* OP1_NEG_OP2_NEG */
+		       "qbbs\t.+16, %%x2, %d\n\t"   /* OP1_POS         */
+		       "%s\t.+8, %%x2, %%x1\n\t"    /* OP1_POS_OP2_POS */
+		       "jmp\t.+8\n\t"               /* jmp OUT */
+		       "jmp\t%%l3",		    /* BRANCH_TAKEN_LABEL */
+		       sign_bit_position(op1),
+		       sign_bit_position(op2),
+		       cmp_opstr,
+		       sign_bit_position(op2),
+		       cmp_opstr);
+    }
+
+  gcc_assert (bufi > 0);
+  gcc_assert ((unsigned int)bufi < sizeof (buf));
+
+  return buf;
+}
+
+static const char *
+pru_output_gtge_signed_cbranch (rtx *operands, bool is_near)
+{
+  static char buf[1024];
+  enum rtx_code code = GET_CODE (operands[0]);
+  rtx op1;
+  rtx op2;
+  const char *cmp_opstr;
+  int bufi = 0;
+
+  op1 = operands[1];
+  op2 = operands[2];
+
+  gcc_assert (GET_CODE (op1) == REG && GET_CODE (op2) == REG);
+
+  /* determine the comparison operators for positive and negative operands */
+  if (code == GT)
+      cmp_opstr = "qbgt";
+  else if (code == GE)
+      cmp_opstr = "qbge";
+  else
+    gcc_unreachable();
+
+  if (is_near)
+    {
+      bufi = snprintf (buf, sizeof(buf),
+		       "qbbs\t.+12, %%x1, %d\n\t"
+		       "qbbs\t%%l3, %%x2, %d\n\t"   /* OP1_POS         */
+		       "%s\t%%l3, %%x2, %%x1\n\t"   /* OP1_POS_OP2_POS */
+		       "qbbc\t.+8, %%x2, %d\n\t"    /* OP1_NEG         */
+		       "%s\t%%l3, %%x2, %%x1",      /* OP1_NEG_OP2_NEG */
+		       sign_bit_position(op1),
+		       sign_bit_position(op2),
+		       cmp_opstr,
+		       sign_bit_position(op2),
+		       cmp_opstr);
+    }
+  else
+    {
+      bufi = snprintf (buf, sizeof(buf),
+		       "qbbs\t.+12, %%x1, %d\n\t"
+		       "qbbs\t.+20, %%x2, %d\n\t"   /* OP1_POS         */
+		       "%s\t.+16, %%x2, %%x1\n\t"   /* OP1_POS_OP2_POS */
+		       "qbbc\t.+16, %%x2, %d\n\t"   /* OP1_NEG         */
+		       "%s\t.+8, %%x2, %%x1\n\t"    /* OP1_NEG_OP2_NEG */
+		       "jmp\t.+8\n\t"               /* jmp OUT */
+		       "jmp\t%%l3",                 /* BRANCH_TAKEN_LABEL */
+		       sign_bit_position(op1),
+		       sign_bit_position(op2),
+		       cmp_opstr,
+		       sign_bit_position(op2),
+		       cmp_opstr);
+    }
+
+  gcc_assert (bufi > 0);
+  gcc_assert ((unsigned int)bufi < sizeof (buf));
+
+  return buf;
+}
+
+const char *
+pru_output_signed_cbranch (rtx *operands, bool is_near)
+{
+  enum rtx_code code = GET_CODE (operands[0]);
+
+  if (code == LT || code == LE)
+    return pru_output_ltle_signed_cbranch (operands, is_near);
+  else if (code == GT || code == GE)
+    return pru_output_gtge_signed_cbranch (operands, is_near);
+  else
+      gcc_unreachable();
+}
+
+/*
+   Optimized version of pru_output_signed_cbranch for constant second
+   operand. */
+
+const char *
+pru_output_signed_cbranch_ubyteop2 (rtx *operands, bool is_near)
+{
+  static char buf[1024];
+  enum rtx_code code = GET_CODE (operands[0]);
+  int regop_sign_bit_pos = sign_bit_position (operands[1]);
+  const char *cmp_opstr;
+  const char *rcmp_opstr;
+
+  /* We must swap operands due to PRU's demand OP1 to be the immediate. */
+  code = swap_condition (code);
+
+  /* Determine normal and reversed comparison operators for both positive
+     operands. This enables us to go completely unsigned.
+
+     NOTE: We cannot use the R print modifier because we convert signed
+     comparison operators to unsigned ones. */
+  switch (code)
+    {
+    case LT: cmp_opstr = "qblt"; rcmp_opstr = "qbge"; break;
+    case LE: cmp_opstr = "qble"; rcmp_opstr = "qbgt"; break;
+    case GT: cmp_opstr = "qbgt"; rcmp_opstr = "qble"; break;
+    case GE: cmp_opstr = "qbge"; rcmp_opstr = "qblt"; break;
+    default: gcc_unreachable();
+    }
+
+  /* OP2 is a constant unsigned byte - utilize this info to generate
+     optimized code. We can "remove half" of the op table above because
+     we know that OP2.b31 = 0 (remember that 0 <= OP2 <= 255). */
+  if (code == LT || code == LE)
+    {
+      if (is_near)
+	snprintf (buf, sizeof(buf),
+		  "qbbs\t.+8, %%x1, %d\n\t"
+		  "%s\t%%l3, %%x1, %%x2",
+		  regop_sign_bit_pos,
+		  cmp_opstr);
+      else
+	snprintf (buf, sizeof(buf),
+		  "qbbs\t.+12, %%x1, %d\n\t"
+		  "%s\t.+8, %%x1, %%x2\n\t"
+		  "jmp\t%%l3",
+		  regop_sign_bit_pos,
+		  rcmp_opstr);
+    }
+  else if (code == GT || code == GE)
+    {
+      if (is_near)
+	snprintf (buf, sizeof(buf),
+		  "qbbs\t%%l3, %%x1, %d\n\t"
+		  "%s\t%%l3, %%x1, %%x2",
+		  regop_sign_bit_pos,
+		  cmp_opstr);
+      else
+	snprintf (buf, sizeof(buf),
+		  "qbbs\t.+8, %%x1, %d\n\t"
+		  "%s\t.+8, %%x1, %%x2\n\t"
+		  "jmp\t%%l3",
+		  regop_sign_bit_pos,
+		  rcmp_opstr);
+    }
+  else
+    gcc_unreachable();
+
+  return buf;
+}
+
+/* Addressing Modes.  */
+
+/* Return true if register REGNO is a valid base register.
+   STRICT_P is true if REG_OK_STRICT is in effect.  */
+
+bool
+pru_regno_ok_for_base_p (int regno, bool strict_p)
+{
+  if (!HARD_REGISTER_NUM_P (regno))
+    {
+      if (!strict_p)
+        return true;
+
+      if (!reg_renumber)
+        return false;
+
+      regno = reg_renumber[regno];
+    }
+
+  /* The fake registers will be eliminated to either the stack or
+     hard frame pointer, both of which are usually valid base registers.
+     Reload deals with the cases where the eliminated form isn't valid.  */
+  return (GP_REG_P (regno)
+          || regno == FRAME_POINTER_REGNUM
+          || regno == ARG_POINTER_REGNUM);
+}
+
+static bool
+pru_valid_const_ubyte_offset (machine_mode mode, HOST_WIDE_INT offset)
+{
+  bool valid = UBYTE_INT (offset);
+
+  /* Reload can split multi word accesses, so make sure we can address
+     the second word in a DI. */
+  if (valid && GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+    valid = UBYTE_INT (offset + GET_MODE_SIZE (mode) - 1);
+
+  return valid;
+}
+
+/* Recognize a CTABLE base address. Return CTABLE entry index, or -1 if
+ * base was not found in the pragma-filled pru_ctable. */
+int pru_get_ctable_exact_base_index (unsigned HOST_WIDE_INT caddr)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (pru_ctable); i++)
+    {
+      if (pru_ctable[i].valid && pru_ctable[i].base == caddr)
+	return i;
+    }
+  return -1;
+}
+
+
+/* Check if the given address can be addressed via CTABLE_BASE + UBYTE_OFFS,
+   and return the base CTABLE index if possible. */
+int pru_get_ctable_base_index (unsigned HOST_WIDE_INT caddr)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (pru_ctable); i++)
+    {
+      if (pru_ctable[i].valid && IN_RANGE (caddr,
+					   pru_ctable[i].base,
+					   pru_ctable[i].base + 0xff))
+	return i;
+    }
+  return -1;
+}
+
+
+/* Return the offset from some CTABLE base for this address. */
+int pru_get_ctable_base_offset (unsigned HOST_WIDE_INT caddr)
+{
+  int i;
+
+  i = pru_get_ctable_base_index (caddr);
+  gcc_assert (i >= 0);
+
+  return caddr - pru_ctable[i].base;
+}
+
+/* Return true if the address expression formed by BASE + OFFSET is
+   valid.  */
+static bool
+pru_valid_addr_expr_p (machine_mode mode, rtx base, rtx offset, bool strict_p)
+{
+  if (!strict_p && base != NULL_RTX && GET_CODE (base) == SUBREG)
+    base = SUBREG_REG (base);
+  if (!strict_p && offset != NULL_RTX && GET_CODE (offset) == SUBREG)
+    offset = SUBREG_REG (offset);
+
+  if (REG_P (base)
+      && pru_regno_ok_for_base_p (REGNO (base), strict_p)
+      && (offset == NULL_RTX
+	  || (CONST_INT_P (offset)
+	      && pru_valid_const_ubyte_offset (mode, INTVAL (offset)))
+	  || (REG_P (offset)
+	      && pru_regno_ok_for_index_p (REGNO (offset), strict_p))))
+    {
+      /*     base register + register offset
+       * OR  base register + UBYTE constant offset */
+      return true;
+    }
+  else if (REG_P (base)
+	   && pru_regno_ok_for_index_p (REGNO (base), strict_p)
+	   && (offset != NULL_RTX && ctable_base_operand (offset, VOIDmode)))
+    {
+      /*     base CTABLE constant base + register offset
+       * Note: GCC always puts the register as a first operand of PLUS. */
+      return true;
+    }
+  else if (CONST_INT_P (base)
+	   && offset == NULL_RTX
+	   && (ctable_addr_operand (base, VOIDmode)))
+    {
+      /*     base CTABLE constant base + UBYTE constant offset */
+      return true;
+    }
+  else
+    {
+      return false;
+    }
+}
+
+/* Implement TARGET_LEGITIMATE_ADDRESS_P.  */
+static bool
+pru_legitimate_address_p (machine_mode mode,
+			    rtx operand, bool strict_p)
+{
+  switch (GET_CODE (operand))
+    {
+      /* Direct.  */
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST:
+    case CONST_DOUBLE:
+      return false;
+
+    case CONST_INT:
+      return ctable_addr_operand (operand, VOIDmode);
+
+      /* Register indirect.  */
+    case REG:
+      return pru_regno_ok_for_base_p (REGNO (operand), strict_p);
+
+      /* Register indirect with displacement.  */
+    case PLUS:
+	{
+	  rtx op0 = XEXP (operand, 0);
+	  rtx op1 = XEXP (operand, 1);
+
+	  return (pru_valid_addr_expr_p (mode, op0, op1, strict_p)
+		  || pru_valid_addr_expr_p (mode, op1, op0, strict_p));
+	}
+
+    default:
+      break;
+    }
+  return false;
+}
+
+
+/* Output assembly language related definitions.  */
+
+static const char *
+pru_comparison_str(enum rtx_code cond)
+{
+  switch(cond) {
+    case NE:  return "ne";
+    case EQ:  return "eq";
+    case GEU: return "ge";
+    case GTU: return "gt";
+    case LEU: return "le";
+    case LTU: return "lt";
+    default: gcc_unreachable ();
+  }
+}
+
+/* Print the operand OP to file stream FILE modified by LETTER.
+   LETTER can be one of:
+
+     x: for registers with size (e.g. R0.b0, R3.w0)
+     B: prints 'c' or 'b' for CTABLE or REG base in a memory address
+     H: for %hi
+     L: for %lo
+     N: prints next register (upper 32bits of a 64bit REG couple)
+     P: prints swapped condition.
+     Q: prints swapped and reversed condition.
+     R: prints reversed condition.
+     S: print operand mode size (but do not print the operand itself)
+     U: for upper half of 32 bit value
+*/
+static void
+pru_print_operand (FILE *file, rtx op, int letter)
+{
+
+  switch (letter)
+    {
+    case 'S':
+      fprintf (file, "%d", GET_MODE_SIZE(GET_MODE(op)));
+      return;
+
+    default:
+      break;
+    }
+
+  if (comparison_operator (op, VOIDmode))
+    {
+      enum rtx_code cond = GET_CODE (op);
+      gcc_assert (!pru_signed_cmp_operator (op, VOIDmode));
+
+      switch (letter)
+	{
+	case 0:
+	  fprintf (file, "%s", pru_comparison_str (cond));
+	  return;
+	case 'P':
+	  fprintf (file, "%s", pru_comparison_str (swap_condition (cond)));
+	  return;
+	case 'Q':
+	  cond = swap_condition (cond);
+	  /* fall through to reverse */
+	case 'R':
+	  fprintf (file, "%s", pru_comparison_str (reverse_condition (cond)));
+	  return;
+	}
+    }
+
+  switch (GET_CODE (op))
+    {
+    case REG:
+      if (letter == 0)
+        {
+          fprintf (file, "%s", reg_names[REGNO (op)]);
+          return;
+        }
+      else if (letter == 'N')
+        {
+	  gcc_assert (REGNO (op) < 29);
+          fprintf (file, "%s", reg_names[REGNO (op) + 1]);
+          return;
+        }
+      else if (letter == 'x')
+        {
+	  const int sz = GET_MODE_SIZE(GET_MODE(op));
+          const char *subreg = (sz == 1) ? ".b0" : ((sz == 2) ? ".w0" : "");
+          fprintf (file, "%s%s", reg_names[REGNO (op)], subreg);
+          return;
+        }
+      break;
+
+    case CONST_INT:
+      /* Ignore 'x' for constants so that MD rules can stay simple. */
+      if (letter == 'x')
+        {
+          output_addr_const (file, op);
+          return;
+        }
+
+      if (letter == 'U')
+        {
+          HOST_WIDE_INT val = INTVAL (op);
+	  val = (val >> 16) & 0xFFFF;
+	  output_addr_const (file, gen_int_mode (val, SImode));
+          return;
+        }
+      /* Else, fall through.  */
+
+    case CONST:
+    case LABEL_REF:
+    case SYMBOL_REF:
+    case CONST_DOUBLE:
+      if (letter == 0)
+        {
+          output_addr_const (file, op);
+          return;
+        }
+      else if (letter == 'H')
+        {
+          fprintf (file, "%%hi(");
+          output_addr_const (file, op);
+          fprintf (file, ")");
+          return;
+        }
+      else if (letter == 'L')
+        {
+          fprintf (file, "%%lo(");
+          output_addr_const (file, op);
+          fprintf (file, ")");
+          return;
+        }
+      break;
+
+    case SUBREG:
+    case MEM:
+      if (letter == 0)
+        {
+          output_address (op);
+          return;
+        }
+      else if (letter == 'B')
+	{
+	  rtx base = XEXP (op, 0);
+	  if (GET_CODE (base) == PLUS)
+	    {
+	      rtx op0 = XEXP (base, 0);
+	      rtx op1 = XEXP (base, 1);
+
+	      /* PLUS cannot have two constant operands, so one
+		 of them must be a REG, hence we must check for an
+		 exact base address. */
+	      if (ctable_base_operand (op0, VOIDmode)
+		  || ctable_base_operand (op1, VOIDmode))
+		{
+		  fprintf (file, "c");
+		  return;
+		}
+	      else if (REG_P (op0) || REG_P (op1))
+		{
+		  fprintf (file, "b");
+		  return;
+		}
+	    }
+	  else if (REG_P (base))
+	    {
+	      fprintf (file, "b");
+	      return;
+	    }
+	  else if (ctable_addr_operand (base, VOIDmode))
+	    {
+	      fprintf (file, "c");
+	      return;
+	    }
+	}
+      break;
+
+    case CODE_LABEL:
+      if (letter == 0)
+        {
+          output_addr_const (file, op);
+          return;
+        }
+      break;
+
+    default:
+      break;
+    }
+
+  output_operand_lossage ("Unsupported operand %s for code '%c'",
+			  GET_RTX_NAME (GET_CODE (op)), letter);
+  gcc_unreachable ();
+}
+
+/* Implement TARGET_PRINT_OPERAND_ADDRESS.  */
+static void
+pru_print_operand_address (FILE *file, rtx op)
+{
+  if (GET_CODE (op) != REG && CONSTANT_ADDRESS_P (op)
+          && text_segment_operand (op, VOIDmode))
+    {
+      fprintf (stderr, "Unexpectred text address?\n");
+      debug_rtx (op);
+      gcc_unreachable ();
+    }
+
+  switch (GET_CODE (op))
+    {
+    case CONST:
+    case LABEL_REF:
+    case CONST_DOUBLE:
+    case SYMBOL_REF:
+      break;
+
+    case CONST_INT:
+      {
+	unsigned HOST_WIDE_INT caddr = INTVAL (op);
+	int base = pru_get_ctable_base_index (caddr);
+	int offs = pru_get_ctable_base_offset (caddr);
+	gcc_assert (base >= 0);
+        fprintf (file, "%d, %d", base, offs);
+	return;
+      }
+      break;
+
+    case PLUS:
+      {
+	int base;
+        rtx op0 = XEXP (op, 0);
+        rtx op1 = XEXP (op, 1);
+
+        if (REG_P (op0) && CONST_INT_P (op1)
+	    && (base = pru_get_ctable_exact_base_index (INTVAL (op1))) >= 0)
+	  {
+            fprintf (file, "%d, %s", base, reg_names[REGNO (op0)]);
+	    return;
+	  }
+	else if (REG_P (op1) && CONST_INT_P (op0)
+	    && (base = pru_get_ctable_exact_base_index (INTVAL (op0))) >= 0)
+	  {
+            fprintf (file, "%d, %s", base, reg_names[REGNO (op1)]);
+	    return;
+	  }
+	else if (REG_P (op0) && CONSTANT_P (op1))
+          {
+            fprintf (file, "%s, ", reg_names[REGNO (op0)]);
+            output_addr_const (file, op1);
+            return;
+          }
+        else if (REG_P (op1) && CONSTANT_P (op0))
+          {
+            fprintf (file, "%s, ", reg_names[REGNO (op1)]);
+            output_addr_const (file, op0);
+            return;
+          }
+        else if (REG_P (op1) && REG_P (op0))
+          {
+	    /* TODO - can op1 be a partial (word/byte) subfield? */
+            fprintf (file, "%s, %s", reg_names[REGNO (op0)],
+                                     reg_names[REGNO (op1)]);
+            return;
+          }
+      }
+      break;
+
+    case REG:
+      fprintf (file, "%s, 0", reg_names[REGNO (op)]);
+      return;
+
+    case MEM:
+      {
+        rtx base = XEXP (op, 0);
+        pru_print_operand_address (file, base);
+        return;
+      }
+    default:
+      break;
+    }
+
+  fprintf (stderr, "Missing way to print address\n");
+  debug_rtx (op);
+  gcc_unreachable ();
+}
+
+/* Implement TARGET_ASM_FUNCTION_PROLOGUE.  */
+static void
+pru_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
+{
+  if (flag_verbose_asm || flag_debug_asm)
+    {
+      pru_compute_frame_layout ();
+      pru_dump_frame_layout (file);
+    }
+}
+
+/* Implement `TARGET_ASM_INTEGER'.  */
+/* Target hook for assembling integer objects.  PRU version needs
+   special handling for references to pmem. Code copied from AVR.  */
+
+static bool
+pru_assemble_integer (rtx x, unsigned int size, int aligned_p)
+{
+  if (size == POINTER_SIZE / BITS_PER_UNIT && aligned_p
+      && text_segment_operand (x, VOIDmode))
+    {
+      fputs ("\t.word\t%pmem(", asm_out_file);
+      output_addr_const (asm_out_file, x);
+      fputs (")\n", asm_out_file);
+
+      return true;
+    }
+  else
+    {
+      return default_assemble_integer (x, size, aligned_p);
+    }
+}
+
+
+
+/* Function argument related.  */
+
+/* Define where to put the arguments to a function.  Value is zero to
+   push the argument on the stack, or a hard register in which to
+   store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+   This is null for libcalls where that information may
+   not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+   the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+   (otherwise it is an extra parameter matching an ellipsis).  */
+
+static rtx
+pru_function_arg (cumulative_args_t cum_v, machine_mode mode,
+		    const_tree type ATTRIBUTE_UNUSED,
+		    bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  rtx return_rtx = NULL_RTX;
+
+  if (cum->regs_used < NUM_ARG_REGS)
+    return_rtx = gen_rtx_REG (mode, FIRST_ARG_REGNO + cum->regs_used);
+
+  return return_rtx;
+}
+
+/* Return number of bytes, at the beginning of the argument, that must be
+   put in registers.  0 is the argument is entirely in registers or entirely
+   in memory.  */
+
+static int
+pru_arg_partial_bytes (cumulative_args_t cum_v,
+                         machine_mode mode, tree type ATTRIBUTE_UNUSED,
+                         bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  HOST_WIDE_INT param_size;
+
+  if (mode == BLKmode)
+    {
+      param_size = int_size_in_bytes (type);
+      gcc_assert (param_size >= 0);
+    }
+  else
+    param_size = GET_MODE_SIZE (mode);
+
+  /* Convert to words (round up).  */
+  param_size = (UNITS_PER_WORD - 1 + param_size) / UNITS_PER_WORD;
+
+  if (cum->regs_used < NUM_ARG_REGS
+      && cum->regs_used + param_size > NUM_ARG_REGS)
+    return (NUM_ARG_REGS - cum->regs_used) * UNITS_PER_WORD;
+
+  return 0;
+}
+
+/* Update the data in CUM to advance over an argument of mode MODE
+   and data type TYPE; TYPE is null for libcalls where that information
+   may not be available.  */
+
+static void
+pru_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,
+			    const_tree type ATTRIBUTE_UNUSED,
+			    bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  HOST_WIDE_INT param_size;
+
+  if (mode == BLKmode)
+    {
+      param_size = int_size_in_bytes (type);
+      gcc_assert (param_size >= 0);
+    }
+  else
+    param_size = GET_MODE_SIZE (mode);
+
+  /* Convert to words (round up).  */
+  param_size = (UNITS_PER_WORD - 1 + param_size) / UNITS_PER_WORD;
+
+  if (cum->regs_used + param_size > NUM_ARG_REGS)
+    cum->regs_used = NUM_ARG_REGS;
+  else
+    cum->regs_used += param_size;
+}
+
+/* Implement TARGET_FUNCTION_VALUE.  */
+static rtx
+pru_function_value (const_tree ret_type, const_tree fn ATTRIBUTE_UNUSED,
+		      bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (TYPE_MODE (ret_type), FIRST_RETVAL_REGNO);
+}
+
+/* Implement TARGET_LIBCALL_VALUE.  */
+static rtx
+pru_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (mode, FIRST_RETVAL_REGNO);
+}
+
+/* Implement TARGET_FUNCTION_VALUE_REGNO_P.  */
+static bool
+pru_function_value_regno_p (const unsigned int regno)
+{
+  return regno == FIRST_RETVAL_REGNO;
+}
+
+/* Implement TARGET_RETURN_IN_MEMORY.  */
+static bool
+pru_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  return (int_size_in_bytes (type) > (2 * UNITS_PER_WORD)
+	  || int_size_in_bytes (type) == -1);
+}
+
+/* TODO: It may be possible to eliminate the copyback and implement
+   own va_arg type.  */
+static void
+pru_setup_incoming_varargs (cumulative_args_t cum_v,
+                              machine_mode mode, tree type,
+                              int *pretend_size, int second_time)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  CUMULATIVE_ARGS local_cum;
+  cumulative_args_t local_cum_v = pack_cumulative_args (&local_cum);
+  int regs_to_push;
+  int pret_size;
+
+  local_cum = *cum;
+  pru_function_arg_advance (local_cum_v, mode, type, 1);
+
+  regs_to_push = NUM_ARG_REGS - local_cum.regs_used;
+
+  if (!second_time && regs_to_push > 0)
+    {
+      rtx ptr = virtual_incoming_args_rtx;
+      rtx mem = gen_rtx_MEM (BLKmode, ptr);
+      emit_insn (gen_blockage ());
+      move_block_from_reg (local_cum.regs_used + FIRST_ARG_REGNO, mem,
+			   regs_to_push);
+      emit_insn (gen_blockage ());
+    }
+
+  pret_size = regs_to_push * UNITS_PER_WORD;
+  if (pret_size)
+    *pretend_size = pret_size;
+}
+
+
+
+/* Implement TARGET_INIT_BUILTINS.  */
+static void
+pru_init_builtins (void)
+{
+}
+
+/* Implement TARGET_BUILTIN_DECL.  */
+static tree
+pru_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)
+{
+  (void)code;
+  return error_mark_node;
+}
+
+
+
+/* Implement TARGET_EXPAND_BUILTIN.  Expand an expression EXP that calls
+   a built-in function, with result going to TARGET if that's convenient
+   (and in mode MODE if that's convenient).
+   SUBTARGET may be used as the target for computing one of EXP's operands.
+   IGNORE is nonzero if the value is to be ignored.  */
+
+static rtx
+pru_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,
+                      rtx subtarget ATTRIBUTE_UNUSED,
+                      machine_mode mode ATTRIBUTE_UNUSED,
+		      int ignore ATTRIBUTE_UNUSED)
+{
+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);
+  rtx arg1 = expand_normal (CALL_EXPR_ARG (exp, 0));
+
+  if (! REG_P (arg1) && ! CONSTANT_P (arg1))
+    arg1 = force_reg (mode, arg1);
+
+  switch (fcode)
+    {
+    default:
+      internal_error ("bad builtin code");
+      break;
+    }
+  return NULL_RTX;
+}
+
+
+
+/* Return a TARGET_OPTION_NODE tree of the target options listed or NULL.  */
+
+static tree
+pru_valid_target_attribute_tree (tree args ATTRIBUTE_UNUSED)
+{
+  return build_target_option_node (&global_options);
+}
+
+/* Hook to validate attribute((target("string"))).  */
+
+static bool
+pru_valid_target_attribute_p (tree fndecl, tree ARG_UNUSED (name),
+				tree args, int ARG_UNUSED (flags))
+{
+  struct cl_target_option cur_target;
+  bool ret = true;
+  tree old_optimize = build_optimization_node (&global_options);
+  tree new_target, new_optimize;
+  tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);
+
+  /* If the function changed the optimization levels as well as setting target
+     options, start with the optimizations specified.  */
+  if (func_optimize && func_optimize != old_optimize)
+    cl_optimization_restore (&global_options,
+			     TREE_OPTIMIZATION (func_optimize));
+
+  /* The target attributes may also change some optimization flags, so update
+     the optimization options if necessary.  */
+  cl_target_option_save (&cur_target, &global_options);
+  new_target = pru_valid_target_attribute_tree (args);
+  new_optimize = build_optimization_node (&global_options);
+
+  if (!new_target)
+    ret = false;
+
+  else if (fndecl)
+    {
+      DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_target;
+
+      if (old_optimize != new_optimize)
+	DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;
+    }
+
+  cl_target_option_restore (&global_options, &cur_target);
+
+  if (old_optimize != new_optimize)
+    cl_optimization_restore (&global_options,
+			     TREE_OPTIMIZATION (old_optimize));
+  return ret;
+}
+
+/* Remember the last target of pru_set_current_function.  */
+static GTY(()) tree pru_previous_fndecl;
+
+/* Establish appropriate back-end context for processing the function
+   FNDECL.  The argument might be NULL to indicate processing at top
+   level, outside of any function scope.  */
+static void
+pru_set_current_function (tree fndecl)
+{
+  tree old_tree = (pru_previous_fndecl
+		   ? DECL_FUNCTION_SPECIFIC_TARGET (pru_previous_fndecl)
+		   : NULL_TREE);
+
+  tree new_tree = (fndecl
+		   ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)
+		   : NULL_TREE);
+
+  if (fndecl && fndecl != pru_previous_fndecl)
+    {
+      pru_previous_fndecl = fndecl;
+      if (old_tree == new_tree)
+	;
+
+      else if (new_tree)
+	{
+	  cl_target_option_restore (&global_options,
+				    TREE_TARGET_OPTION (new_tree));
+	  target_reinit ();
+	}
+
+      else if (old_tree)
+	{
+	  struct cl_target_option *def
+	    = TREE_TARGET_OPTION (target_option_current_node);
+
+	  cl_target_option_restore (&global_options, def);
+	  target_reinit ();
+	}
+    }
+}
+
+
+
+/* Initialize the GCC target structure.  */
+#undef TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE pru_asm_function_prologue
+#undef TARGET_ASM_INTEGER
+#define TARGET_ASM_INTEGER pru_assemble_integer
+
+#undef TARGET_INIT_BUILTINS
+#define TARGET_INIT_BUILTINS pru_init_builtins
+#undef TARGET_EXPAND_BUILTIN
+#define TARGET_EXPAND_BUILTIN pru_expand_builtin
+#undef TARGET_BUILTIN_DECL
+#define TARGET_BUILTIN_DECL pru_builtin_decl
+
+#undef TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL hook_bool_tree_tree_true
+
+#undef TARGET_CAN_ELIMINATE
+#define TARGET_CAN_ELIMINATE pru_can_eliminate
+
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG pru_function_arg
+
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE pru_function_arg_advance
+
+#undef TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES pru_arg_partial_bytes
+
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE pru_function_value
+
+#undef TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE pru_libcall_value
+
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P pru_function_value_regno_p
+
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY pru_return_in_memory
+
+#undef TARGET_SETUP_INCOMING_VARARGS
+#define TARGET_SETUP_INCOMING_VARARGS pru_setup_incoming_varargs
+
+#undef TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+
+#undef TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P pru_legitimate_address_p
+
+#undef TARGET_PREFERRED_RELOAD_CLASS
+#define TARGET_PREFERRED_RELOAD_CLASS pru_preferred_reload_class
+
+#undef TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS pru_rtx_costs
+
+#undef TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND pru_print_operand
+
+#undef TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS pru_print_operand_address
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE pru_option_override
+
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION pru_set_current_function
+
+#undef TARGET_OPTION_VALID_ATTRIBUTE_P
+#define TARGET_OPTION_VALID_ATTRIBUTE_P pru_valid_target_attribute_p
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-pru.h"
diff --git a/gcc/config/pru/pru.h b/gcc/config/pru/pru.h
new file mode 100644
index 0000000..04046ec
--- /dev/null
+++ b/gcc/config/pru/pru.h
@@ -0,0 +1,418 @@
+/* Definitions of target machine for TI PRU.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_PRU_H
+#define GCC_PRU_H
+
+/* Define built-in preprocessor macros.  */
+#define TARGET_CPU_CPP_BUILTINS()		    \
+  do						    \
+    {						    \
+      builtin_define_std ("__PRU__");		    \
+      builtin_define_std ("__pru__");		    \
+      builtin_define_std ("__PRU_V3__");	    \
+      builtin_define_std ("__LITTLE_ENDIAN__");	    \
+      /* Trampolines are disabled for now. */	    \
+      builtin_define_std ("NO_TRAMPOLINES");	    \
+    }						    \
+  while (0)
+
+#define DRIVER_SELF_SPECS " %{mmcu=*:-specs=device-specs/%*%s %<mmcu=*} "
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC "%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} -lgcc"
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "-lgloss"
+
+/* We require underscore label prefix in order to prevent ambiguity
+   when a C function name matches a CPU register name. We know that no
+   register name starts with an underscore. */
+#undef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX "_"
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX ".L"
+
+/* Storage layout.  */
+
+#define DEFAULT_SIGNED_CHAR 0
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+#define BITS_PER_WORD 32
+#define UNITS_PER_WORD 4
+#define POINTER_SIZE 32
+#define BIGGEST_ALIGNMENT 32
+#define STRICT_ALIGNMENT 0
+#define FUNCTION_BOUNDARY 32
+#define PARM_BOUNDARY 32
+#define STACK_BOUNDARY 32
+#define PREFERRED_STACK_BOUNDARY 32
+#define MAX_FIXED_MODE_SIZE 64
+
+/* Layout of source language data types.  */
+
+#define INT_TYPE_SIZE 32
+#define SHORT_TYPE_SIZE 16
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 64
+#define LONG_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+
+/* Basic characteristics of PRU registers:
+
+   Regno  Name
+   0      r0               Caller Saved. Also used as a static chain register.
+   1      r1               Caller Saved. Also used as a temporary by function
+                           profiler and function prologue/epilogue.
+   2      r2       sp      Stack Pointer
+   3      r3       ra      Return Address
+   4      r4       fp      Frame Pointer
+   5-13   r5-r13           Callee Saved Registers
+   14-29  r14-r29          Register Arguments. Caller Saved Registers.
+   14-15  r14-r15          Return Location
+   30     r30              Special I/O register. Not used by compiler.
+   31     r31              Special I/O register. Not used by compiler.
+
+   32     pc               Not an actual register
+
+   33     fake_fp          Fake Frame Pointer (always eliminated)
+   34     fake_ap          Fake Argument Pointer (always eliminated)
+   35                      First Pseudo Register
+
+   The definitions for all the hard register numbers are located in pru.md.
+*/
+
+#define FIXED_REGISTERS			      \
+  {					      \
+/*        +0  1  2  3  4  5  6  7  8  9 */    \
+/*   0 */  0, 0, 1, 1, 0, 0, 0, 0, 0, 0,      \
+/*  10 */  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      \
+/*  20 */  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      \
+/*  30 */  1, 1, 1, 1, 1,		      \
+  }
+
+/* Call used == caller saved + fixed regs + args + ret vals. */
+#define CALL_USED_REGISTERS		      \
+  {					      \
+/*        +0  1  2  3  4  5  6  7  8  9 */    \
+/*   0 */  1, 1, 1, 1, 0, 0, 0, 0, 0, 0,      \
+/*  10 */  0, 0, 0, 0, 1, 1, 1, 1, 1, 1,      \
+/*  20 */  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,      \
+/*  30 */  1, 1, 1, 1, 1,		      \
+  }
+
+/* Try to allocate r14-r29 first. Use r0 and r1 only if necessary. */
+   
+#define REG_ALLOC_ORDER			      \
+  {					      \
+    14, 15, 16, 17, 18, 19, 20, 21, 22, 23,   \
+    24, 25, 26, 27, 28, 29, 0,  1,	      \
+    5,  6,  7,  8,  9,  10, 11, 12, 13,	      \
+    4,					      \
+    2,  3,				      \
+    30, 31, 32, 33, 34			      \
+  }
+
+#define MODES_TIEABLE_P(MODE1, MODE2) 1
+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
+#define HARD_REGNO_NREGS(REGNO, MODE)          \
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Register Classes.  */
+
+enum reg_class
+{
+  NO_REGS,
+  SIB_REGS,
+  GP_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES   \
+  {  "NO_REGS",           \
+     "SIB_REGS",          \
+     "GP_REGS",           \
+     "ALL_REGS" }
+
+#define GENERAL_REGS ALL_REGS
+
+#define REG_CLASS_CONTENTS			\
+  {						\
+    /* NO_REGS  */ { 0, 0},			\
+    /* SIB_REGS */ { 0x3fffc001, 0},		\
+    /* GP_REGS  */ { ~0, 0},			\
+    /* ALL_REGS */ { ~0,~0}			\
+  }
+
+
+#define GP_REG_P(REGNO) ((unsigned)(REGNO) <= LAST_GP_REG)
+#define REGNO_REG_CLASS(REGNO) (GP_REG_P (REGNO) ? GP_REGS : ALL_REGS)
+#define CLASS_MAX_NREGS(CLASS, MODE) \
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Arbitrarily set to a non-argument register. */
+#define STATIC_CHAIN_REGNUM      0	/* r0 */
+
+/* Tests for various kinds of constants used in the PRU port.  */
+#define SHIFT_INT(X) ((X) >= 0 && (X) <= 31)
+
+#define UHWORD_INT(X) (IN_RANGE ((X), 0, 0xffff))
+#define UBYTE_INT(X) (IN_RANGE ((X), 0, 0xff))
+
+/* Say that the epilogue uses the return address register.  Note that
+   in the case of sibcalls, the values "used by the epilogue" are
+   considered live at the start of the called function.  */
+#define EPILOGUE_USES(REGNO) (epilogue_completed && (REGNO) == RA_REGNO)
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in
+   functions that have frame pointers.
+   No definition is equivalent to always zero.  */
+
+#define EXIT_IGNORE_STACK 1
+
+#define TRAMPOLINE_SIZE 4
+
+/* Stack layout.  */
+#define STACK_GROWS_DOWNWARD
+#undef FRAME_GROWS_DOWNWARD
+#define STARTING_FRAME_OFFSET 0
+#define FIRST_PARM_OFFSET(FUNDECL) 0
+
+/* Before the prologue, RA lives in r3.  */
+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, RA_REGNO)
+#define RETURN_ADDR_RTX(C,F) pru_get_return_address (C)
+
+#define DWARF_FRAME_RETURN_COLUMN RA_REGNO
+
+/* The CFA includes the pretend args.  */
+#define ARG_POINTER_CFA_OFFSET(FNDECL) \
+  (gcc_assert ((FNDECL) == current_function_decl), \
+   FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)
+
+/* Frame/arg pointer elimination settings.  */
+#define ELIMINABLE_REGS                                                 \
+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},                         \
+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},                    \
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},                         \
+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  (OFFSET) = pru_initial_elimination_offset ((FROM), (TO))
+
+/* Calling convention definitions.  */
+typedef struct pru_args
+{
+  int regs_used;
+} CUMULATIVE_ARGS;
+
+#define NUM_ARG_REGS (LAST_ARG_REGNO - FIRST_ARG_REGNO + 1)
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
+  do { (CUM).regs_used = 0; } while (0)
+
+#define FUNCTION_ARG_REGNO_P(REGNO) \
+  ((REGNO) >= FIRST_ARG_REGNO && (REGNO) <= LAST_ARG_REGNO)
+
+/* Passing function arguments on stack.  */
+#define PUSH_ARGS 0
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* We define TARGET_RETURN_IN_MEMORY, so set to zero.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Profiling.  */
+#define PROFILE_BEFORE_PROLOGUE
+#define NO_PROFILE_COUNTERS 1
+#define FUNCTION_PROFILER(FILE, LABELNO) \
+  pru_function_profiler ((FILE), (LABELNO))
+
+/* Addressing modes.  */
+
+#define CONSTANT_ADDRESS_P(X) \
+  (CONSTANT_P (X) && memory_address_p (SImode, X))
+
+#define MAX_REGS_PER_ADDRESS 2
+#define BASE_REG_CLASS ALL_REGS
+#define INDEX_REG_CLASS ALL_REGS
+
+#define REGNO_OK_FOR_BASE_P(REGNO) pru_regno_ok_for_base_p ((REGNO), true)
+#define REGNO_OK_FOR_INDEX_P(REGNO) pru_regno_ok_for_index_p ((REGNO), true)
+
+/* Describing Relative Costs of Operations.  */
+#define MOVE_MAX 4
+#define SLOW_BYTE_ACCESS 1
+
+/* It is as good to call a constant function address as to call an address
+   kept in a register.  */
+#define NO_FUNCTION_CSE 1
+
+/* Define output assembler language.  */
+
+#define ASM_APP_ON "#APP\n"
+#define ASM_APP_OFF "#NO_APP\n"
+
+#define ASM_COMMENT_START "# "
+
+#define GLOBAL_ASM_OP "\t.global\t"
+
+#define REGISTER_NAMES \
+  {       \
+    "r0", \
+    "r1", \
+    "sp", \
+    "ra", \
+    "fp", \
+    "r5", \
+    "r6", \
+    "r7", \
+    "r8", \
+    "r9", \
+    "r10", \
+    "r11", \
+    "r12", \
+    "r13", \
+    "r14", \
+    "r15", \
+    "r16", \
+    "r17", \
+    "r18", \
+    "r19", \
+    "r20", \
+    "r21", \
+    "r22", \
+    "r23", \
+    "r24", \
+    "r25", \
+    "r26", \
+    "r27", \
+    "r28", \
+    "r29", \
+    "r30", \
+    "r31", \
+    "pc", \
+    "fake_fp", \
+    "fake_ap", \
+}
+
+#define ADDITIONAL_REGISTER_NAMES       \
+{                                       \
+  {"r2", 2},                          	\
+  {"r3", 2},                          	\
+  {"r4", 4},                          	\
+}
+
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
+  do									\
+    {									\
+      fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \
+      fprintf (FILE, "%%pmem(.L%u)\n", (unsigned) (VALUE));		\
+    }									\
+  while (0)
+
+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\
+  do									\
+    {									\
+      fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), STREAM); \
+      fprintf (STREAM, "%%pmem(.L%u-.L%u)\n", (unsigned) (VALUE), (unsigned) (REL)); \
+    }									\
+  while (0)
+
+/* Section directives.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP "\t.section\t.text"
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP "\t.section\t.data"
+
+/* Output before uninitialized data.  */
+#define BSS_SECTION_ASM_OP "\t.section\t.bss"
+
+#define ASM_OUTPUT_ALIGN(FILE, LOG)                  \
+  do {                                               \
+    fprintf ((FILE), "%s%d\n", ALIGN_ASM_OP, (LOG)); \
+  } while (0)
+
+#undef  ASM_OUTPUT_ALIGNED_COMMON
+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)              \
+do                                                                      \
+  {									\
+    fprintf ((FILE), "%s", COMMON_ASM_OP);				\
+    assemble_name ((FILE), (NAME));					\
+    fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%u\n", (SIZE),	\
+	     (ALIGN) / BITS_PER_UNIT);					\
+  }									\
+while (0)
+
+
+/* This says how to output assembler code to declare an
+   uninitialized internal linkage data object.  Under SVR4,
+   the linker seems to want the alignment of data objects
+   to depend on their types.  We do exactly that here.  */
+
+#undef  ASM_OUTPUT_ALIGNED_LOCAL
+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)               \
+do {                                                                    \
+  switch_to_section (bss_section);					\
+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");                     \
+  if (!flag_inhibit_size_directive)                                     \
+    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);                       \
+  ASM_OUTPUT_ALIGN ((FILE), exact_log2((ALIGN) / BITS_PER_UNIT));       \
+  ASM_OUTPUT_LABEL(FILE, NAME);                                         \
+  ASM_OUTPUT_SKIP((FILE), (SIZE) ? (SIZE) : 1);                         \
+} while (0)
+
+/* Misc. parameters.  */
+
+#define STORE_FLAG_VALUE 1
+#define Pmode SImode
+#define FUNCTION_MODE Pmode
+
+#define CASE_VECTOR_MODE Pmode
+
+/* TODO - revisit */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)	1
+
+#define LOGICAL_OP_NON_SHORT_CIRCUIT		0	/* jumps are cheap */
+
+#undef LOAD_EXTEND_OP
+
+#define WORD_REGISTER_OPERATIONS		1
+
+#define HAS_LONG_UNCOND_BRANCH			1
+#define HAS_LONG_COND_BRANCH			1
+
+#define REGISTER_TARGET_PRAGMAS() pru_register_pragmas()
+
+#endif /* GCC_PRU_H */
diff --git a/gcc/config/pru/pru.md b/gcc/config/pru/pru.md
new file mode 100644
index 0000000..1b7d28b
--- /dev/null
+++ b/gcc/config/pru/pru.md
@@ -0,0 +1,579 @@
+;; Machine Description for TI PRU.
+;; Copyright (C) 2014 Free Software Foundation, Inc.
+;; Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+;; Based on the NIOS2 GCC port.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Register numbers
+(define_constants
+  [
+   (FIRST_ARG_REGNO        14)	; Argument registers
+   (LAST_ARG_REGNO         29)	;
+   (FIRST_RETVAL_REGNO     14)	; Return value registers
+   (LAST_RETVAL_REGNO      15)	;
+   (PROLOGUE_TEMP_REGNO    1)	; Temporary register to use in prologue
+
+   (RA_REGNO		   3)	; Return address register. NB! This is
+				; a major difference from TI's PRU C
+				; compiler where r3.w2 is used.
+   (FP_REGNO	           4)	; Frame pointer register
+   (LAST_NONIO_GP_REG      29)	; Last non-I/O general purpose register
+   (LAST_GP_REG            31)	; Last general purpose register
+
+   ;; Target register definitions
+   (STACK_POINTER_REGNUM       2)
+   (HARD_FRAME_POINTER_REGNUM  FP_REGNO)
+   (PC_REGNUM                  32)
+   (FRAME_POINTER_REGNUM       33)
+   (ARG_POINTER_REGNUM         34)
+   (FIRST_PSEUDO_REGISTER      35)
+  ]
+)
+
+;; Enumeration of UNSPECs
+
+(define_c_enum "unspecv" [
+  UNSPECV_BLOCKAGE
+])
+
+
+; length of an instruction (in bytes)
+(define_attr "length" "" (const_int 4))
+(define_attr "type" 
+  "unknown,complex,control,alu,cond_alu,st,ld,shift" 
+  (const_string "complex"))
+
+(define_asm_attributes
+ [(set_attr "length" "4")
+  (set_attr "type" "complex")])
+
+; There is no pipeline, so our scheduling description is simple.
+(define_automaton "pru")
+(define_cpu_unit "cpu" "pru")
+
+(define_insn_reservation "everything" 1 (match_test "true") "cpu")
+
+(include "predicates.md")
+(include "constraints.md")
+
+(define_mode_iterator ALL [QI HI SI])
+(define_mode_iterator BIGI [DI TI OI XI])
+
+
+;; Move instructions
+
+;; Assume that Program Mem (T constraint) can fit in 16 bits!
+(define_insn "mov<mode>"
+  [(set (match_operand:ALL 0 "nonimmediate_operand" "=m,r,r,r,r,r")
+        (match_operand:ALL 1 "general_operand"       "r,m,r,T,J,i"))]
+;  "(which_alternative == 5) ? (<MODE>mode == SImode) : true"
+  ""
+  "@
+    sb%B0o\\t%1, %0, %S0
+    lb%B1o\\t%0, %1, %S1
+    mov\\t%x0, %x1
+    ldi\\t%x0, %%pmem(%1)
+    ldi\\t%x0, %1
+    ldi\\t%0.w2, %H1\;ldi\\t%0.w0, %L1"
+  [(set_attr "type" "st,ld,alu,alu,alu,alu")
+   (set_attr "length" "4,4,4,4,4,8")])
+
+;; Load multiple
+;;   op0: first of the consecutive registers
+;;   op1: first memory location
+;;   op2: number of consecutive registers
+(define_expand "load_multiple"
+  [(match_par_dup 3 [(set (match_operand:SI 0 "" "")
+			  (match_operand:SI 1 "" ""))
+		     (use (match_operand:SI 2 "" ""))])]
+  ""
+  "
+{
+  int first_regno, count, i;
+
+  /* Support only loading a constant number of registers from memory and
+     only if at least one register. */
+  if (GET_CODE (operands[2]) != CONST_INT
+      || INTVAL (operands[2]) < 1
+      || GET_CODE (operands[1]) != MEM
+      || GET_CODE (operands[0]) != REG
+      || (REGNO (operands[0]) + INTVAL (operands[2]) - 1) > LAST_NONIO_GP_REG)
+    FAIL;
+
+  count = INTVAL (operands[2]);
+  first_regno = REGNO (operands[0]);
+
+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));
+
+  for (i = 0; i < count; i++)
+    XVECEXP (operands[3], 0, i)
+      = gen_rtx_SET (VOIDmode,
+		 gen_rtx_REG (SImode, first_regno + i),
+		 gen_rtx_MEM (SImode, plus_constant (Pmode,
+						     XEXP (operands[1], 0),
+						     i * UNITS_PER_WORD)));
+}")
+
+;; Store multiple
+;;   op0: first memory location
+;;   op1: first of the consecutive registers
+;;   op2: number of consecutive registers
+(define_expand "store_multiple"
+  [(match_par_dup 3 [(set (match_operand:SI 0 "" "")
+			  (match_operand:SI 1 "" ""))
+		     (use (match_operand:SI 2 "" ""))])]
+  ""
+  "
+{
+  int first_regno, count, i;
+
+  /* Support only storing a constant number of registers to memory and
+     only if at least one register. */
+  if (GET_CODE (operands[2]) != CONST_INT
+      || INTVAL (operands[2]) < 1
+      || GET_CODE (operands[0]) != MEM
+      || GET_CODE (operands[1]) != REG
+      || (REGNO (operands[1]) + INTVAL (operands[2]) - 1) > LAST_NONIO_GP_REG)
+    FAIL;
+
+  count = INTVAL (operands[2]);
+  first_regno = REGNO (operands[1]);
+
+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));
+
+  for (i = 0; i < count; i++)
+    XVECEXP (operands[3], 0, i)
+      = gen_rtx_SET (VOIDmode,
+		 gen_rtx_MEM (SImode, plus_constant (Pmode,
+						     XEXP (operands[0], 0),
+						     i * UNITS_PER_WORD)),
+		 gen_rtx_REG (SImode, first_regno + i));
+}")
+
+;; Include the machine-generated patterns for all LBBO/SBBO multuple-reg
+;; lengths. This is needed due to limitations of GCC. See
+;; http://article.gmane.org/gmane.comp.gcc.devel/54458
+(include "pru-ldst-multiple.md")
+
+
+;; EQS for extension source and EQD for extension destination patterns.
+(define_mode_iterator EQS [QI HI])
+(define_mode_iterator EQD [HI SI])
+
+;; Zero extension patterns
+;;
+;; Unfortunately we cannot use lbbo to load AND zero-extent a value.
+;; The burst length parameter designates not only the number of memory
+;; data bytes fetched, but also the number of register byte fields written.
+(define_insn "zero_extend<EQS:mode><EQD:mode>2"
+  [(set (match_operand:EQD 0 "register_operand" "=r")
+        (zero_extend:EQD (match_operand:EQS 1 "register_operand" "r")))]
+  ""
+  "mov\\t%x0, %x1"
+  [(set_attr "type"     "alu")])
+
+;; Sign extension patterns. We have to emulate them due to lack of
+;; signed operations in PRU's ALU.
+
+(define_insn "extend<EQS:mode><EQD:mode>2"
+  [(set (match_operand:EQD 0 "register_operand"                   "=r")
+        (sign_extend:EQD (match_operand:EQS 1 "register_operand"  "r")))]
+  ""
+  {
+    return pru_output_sign_extend(operands);
+  }
+  [(set_attr "type" "complex")
+   (set_attr "length" "12")])
+
+
+;; Arithmetic Operations
+
+(define_expand "addsi3"
+  [(set (match_operand:SI 0 "register_operand"            "")
+        (plus:SI (match_operand:SI 1 "register_operand"   "")
+                 (match_operand:SI 2 "nonmemory_operand" "")))]
+  "!reload_in_progress && !reload_completed"
+  {
+    if (GET_CODE (operands[2]) == REG || GET_CODE (operands[2]) == SUBREG)
+      {
+      emit_insn (gen_pru_addsi3 (operands[0], operands[1], operands[2]));
+      }
+    else if (GET_CODE (operands[2]) != CONST_INT)
+      {
+      emit_insn (gen_pru_addsi3_bigint (operands[0], operands[1], operands[2]));
+      }
+    else if (UBYTE_INT (INTVAL (operands[2])))
+      {
+      emit_insn (gen_pru_addsi3 (operands[0], operands[1], operands[2]));
+      }
+    else if (UBYTE_INT (-INTVAL (operands[2])))
+      {
+      HOST_WIDE_INT imm = -INTVAL (operands[2]);
+      emit_insn (gen_subsi3 (operands[0], operands[1], gen_int_mode(imm, SImode)));
+      }
+    else
+      {
+      emit_insn (gen_pru_addsi3_bigint (operands[0], operands[1], operands[2]));
+      }
+    DONE;
+  })
+
+(define_expand "pru_addsi3_bigint"
+  [(set (match_operand:SI 0 "register_operand"           "")
+        (plus:SI (match_operand:SI 1 "register_operand"  "")
+                 (match_operand:SI 2 "const_int_operand" "")))]
+  "!reload_in_progress && !reload_completed"
+  {
+    rtx tmp = force_reg (SImode, operands[2]);
+    emit_insn (gen_pru_addsi3 (operands[0], operands[1], tmp));
+    DONE;
+  }
+)
+
+
+(define_insn "pru_addsi3"
+  [(set (match_operand:SI 0 "register_operand"            "=r,r,r")
+        (plus:SI (match_operand:SI 1 "register_operand"   "%r,r,r")
+                 (match_operand:SI 2 "nonmemory_operand" "r,I,M")))]
+  ""
+  "@
+   add\\t%0, %1, %2
+   add\\t%0, %1, %2
+   sub\\t%0, %1, -(%2)"
+  [(set_attr "type" "alu")])
+
+(define_insn "adddi3"
+  [(set (match_operand:DI 0 "register_operand"            "=&r,&r,&r")
+        (plus:DI (match_operand:DI 1 "register_operand"   "%r,r,r")
+                 (match_operand:DI 2 "reg_or_ubyte_operand" "r,I,M")))]
+  ""
+  "@
+   add\\t%0, %1, %2\;adc\\t%N0, %N1, %N2
+   add\\t%0, %1, %2\;adc\\t%N0, %N1, 0
+   sub\\t%0, %1, -(%2)\;suc\\t%N0, %N1, 0"
+  [(set_attr "type" "alu,alu,alu")
+   (set_attr "length" "8,8,8")])
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand"           "=r,r,r")
+        (minus:SI (match_operand:SI 1 "reg_or_ubyte_operand" "r,r,I")
+                  (match_operand:SI 2 "reg_or_ubyte_operand" "r,I,r")))]
+  ""
+  "@
+   sub\\t%0, %1, %2
+   sub\\t%0, %1, %2
+   rsb\\t%0, %2, %1"
+  [(set_attr "type" "alu")])
+
+(define_insn "subdi3"
+  [(set (match_operand:DI 0 "register_operand"            "=&r,&r,&r")
+        (minus:DI (match_operand:DI 1 "register_operand"   "r,r,I")
+                 (match_operand:DI 2 "reg_or_ubyte_operand" "r,I,r")))]
+  ""
+  "@
+   sub\\t%0, %1, %2\;suc\\t%N0, %N1, %N2
+   sub\\t%0, %1, %2\;suc\\t%N0, %N1, 0
+   rsb\\t%0, %2, %1\;rsc\\t%N0, %N2, 0"
+  [(set_attr "type" "alu,alu,alu")
+   (set_attr "length" "8,8,8")])
+
+
+;;  Negate and ones complement
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand"        "=r")
+        (neg:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "rsb\\t%0, %1, 0"
+  [(set_attr "type" "alu")])
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand"        "=r")
+        (not:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "not\\t%0, %1"
+  [(set_attr "type" "alu")])
+
+
+;;  Integer logical Operations
+;;
+;; TODO - add optimized cases that exploit the fact that we can get away
+;; with a single machine op for special constants, e.g. UBYTE << (0..31)
+
+(define_code_iterator LOGICAL [and ior xor umin umax])
+(define_code_attr logical_asm [(and "and") (ior "or") (xor "xor") (umin "min") (umax "max")])
+
+(define_insn "<code>si3"
+  [(set (match_operand:SI 0 "register_operand"                 "=r")
+        (LOGICAL:SI (match_operand:SI 1 "register_operand"     "%r")
+                    (match_operand:SI 2 "reg_or_ubyte_operand"  "rI")))]
+  ""
+  "<logical_asm>\\t%0, %1, %2"
+  [(set_attr "type" "alu")])
+
+
+;;  Shift instructions
+
+(define_code_iterator SHIFT  [ashift lshiftrt])
+(define_code_attr shift_op   [(ashift "ashl") (lshiftrt "lshr")])
+(define_code_attr shift_asm  [(ashift "lsl") (lshiftrt "lsr")])
+
+(define_insn "<shift_op>si3"
+  [(set (match_operand:SI 0 "register_operand"          "=r")
+        (SHIFT:SI (match_operand:SI 1 "register_operand" "r")
+                  (match_operand:SI 2 "shift_operand"    "rL")))]
+  ""
+  "<shift_asm>\\t%0, %1, %2"
+  [(set_attr "type" "shift")])
+;; TODO - add clrbit, setbit,
+
+
+;; Multiply instruction. Idea for fixing registers comes from the AVR backend.
+
+(define_expand "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+        (mult:SI (match_operand:SI 1 "register_operand" "")
+                 (match_operand:SI 2 "register_operand" "")))]
+  ""
+  {
+     emit_insn (gen_mulsi3_fixinp (operands[0], operands[1], operands[2]));
+     DONE;
+  })
+
+
+(define_expand "mulsi3_fixinp"
+  [(set (reg:SI 28) (match_operand:SI 1 "register_operand" ""))
+   (set (reg:SI 29) (match_operand:SI 2 "register_operand" ""))
+   (parallel [(set (reg:SI 26) (mult:SI (reg:SI 28) (reg:SI 29)))
+              (clobber (reg:SI 25))
+              (clobber (reg:SI 27))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:SI 26))]
+  ""
+  {
+  })
+
+(define_insn "*mulsi3_prumac"
+  [(set (reg:SI 26) (mult:SI (reg:SI 28) (reg:SI 29)))
+   (clobber (reg:SI 25))
+   (clobber (reg:SI 27))]
+  ""
+  "ldi\\tr25, 0\;xout\\t0, r25, 1\;xin\\t0, r26, 8"
+  [(set_attr "type" "alu")
+   (set_attr "length" "12")])
+
+
+
+;; Prologue, Epilogue and Return
+
+(define_expand "prologue"
+  [(const_int 1)]
+  ""
+{
+  pru_expand_prologue ();
+  DONE;
+})
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+{
+  pru_expand_epilogue (false);
+  DONE;
+})
+
+(define_expand "sibcall_epilogue"
+  [(return)]
+  ""
+{
+  pru_expand_epilogue (true);
+  DONE;
+})
+
+(define_insn "return"
+  [(simple_return)]
+  "pru_can_use_return_insn ()"
+  "ret")
+
+(define_insn "simple_return"
+  [(simple_return)]
+  ""
+  "ret")
+
+;; Block any insns from being moved before this point, since the
+;; profiling call to mcount can use various registers that aren't
+;; saved or used to pass arguments.
+
+(define_insn "blockage"
+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]
+  ""
+  ""
+  [(set_attr "type" "unknown")
+   (set_attr "length" "0")])
+
+
+;;  Jumps and calls
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "jmp\\t%0"
+  [(set_attr "type" "control")])
+
+(define_insn "jump"
+  [(set (pc)
+        (label_ref (match_operand 0 "" "")))]
+  ""
+  "jmp\\t%0"
+  [(set_attr "type" "control")
+   (set_attr "length" "4")])
+
+
+(define_expand "call"
+  [(parallel [(call (match_operand 0 "" "")
+                    (match_operand 1 "" ""))
+              (clobber (reg:SI RA_REGNO))])]
+  ""
+  "")
+
+(define_expand "call_value"
+  [(parallel [(set (match_operand 0 "" "")
+                   (call (match_operand 1 "" "")
+                         (match_operand 2 "" "")))
+              (clobber (reg:SI RA_REGNO))])]
+  ""
+  "")
+
+(define_insn "*call"
+  [(call (mem:SI (match_operand:SI 0 "call_operand" "ir"))
+         (match_operand 1 "" ""))
+   (clobber (reg:SI RA_REGNO))]
+  ""
+  "call\\t%0"
+  [(set_attr "type" "control")])
+
+(define_insn "*call_value"
+  [(set (match_operand 0 "" "")
+        (call (mem:SI (match_operand:SI 1 "call_operand" "ir"))
+              (match_operand 2 "" "")))
+   (clobber (reg:SI RA_REGNO))]
+  ""
+  "call\\t%1"
+  [(set_attr "type" "control")])
+
+(define_expand "sibcall"
+  [(parallel [(call (match_operand 0 "" "")
+                    (match_operand 1 "" ""))
+              (return)])]
+  ""
+  "")
+
+(define_expand "sibcall_value"
+  [(parallel [(set (match_operand 0 "" "")
+                   (call (match_operand 1 "" "")
+                         (match_operand 2 "" "")))
+              (return)])]
+  ""
+  "")
+
+(define_insn "*sibcall"
+ [(call (mem:SI (match_operand:SI 0 "call_operand" "ij"))
+        (match_operand 1 "" ""))
+  (return)]
+  "SIBLING_CALL_P(insn)"
+  "jmp\\t%0"
+  [(set_attr "type" "control")])
+
+(define_insn "*sibcall_value"
+ [(set (match_operand 0 "register_operand" "")
+       (call (mem:SI (match_operand:SI 1 "call_operand" "ij"))
+             (match_operand 2 "" "")))
+  (return)]
+  "SIBLING_CALL_P(insn)"
+  "jmp\\t%1"
+  [(set_attr "type" "control")])
+
+(define_insn "*tablejump"
+  [(set (pc)
+        (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "jmp\\t%0"
+  [(set_attr "type" "control")])
+
+
+;; cbranch pattern.
+;;
+;; NOTE: The short branch check has no typo! We must be conservative and take
+;; into account the worst case of having a signed comparison with a
+;; "far taken branch" label, which amounts to 7 instructions.
+;;
+;; TODO - define qbbs/qbbc, and possibly then re-define sign_extend and
+;; sign compares as define_split's.
+
+(define_insn "cbranch<mode>4"
+  [(set (pc)
+     (if_then_else
+       (match_operator 0 "ordered_comparison_operator"
+         [(match_operand:ALL 1 "register_operand" "r,r")
+          (match_operand:ALL 2 "reg_or_ubyte_operand" "r,I")])
+       (label_ref (match_operand 3 "" ""))
+       (pc)))]
+  ""
+{
+  const int length = (get_attr_length (insn));
+  const bool is_near = (length == 20 || length == 4);
+
+  if (pru_signed_cmp_operator (operands[0], VOIDmode))
+    {
+      if (which_alternative == 0)
+        return pru_output_signed_cbranch (operands, is_near);
+      else
+        return pru_output_signed_cbranch_ubyteop2 (operands, is_near);
+    }
+  else
+    {
+      /* PRU demands OP1 to be immediate, so swap operands */
+      if (is_near)
+        return "qb%P0\t%l3, %x1, %x2";
+      else
+        return "qb%Q0\t.+8, %x1, %x2\;jmp\t%l3";
+    }
+}
+  [(set_attr "type" "control")
+   (set (attr "length") 
+        (if_then_else
+            (and (ge (minus (match_dup 3) (pc)) (const_int -2020))
+                 (le (minus (match_dup 3) (pc)) (const_int 2016)))
+            (if_then_else
+		(match_test "pru_signed_cmp_operator (operands[0], VOIDmode)")
+		    (const_int 20)
+		    (const_int 4))
+            (if_then_else
+		(match_test "pru_signed_cmp_operator (operands[0], VOIDmode)")
+		    (const_int 28)
+		    (const_int 8))))])
+
+
+;;  Misc. patterns
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "type" "alu")])
+
diff --git a/gcc/config/pru/pru.opt b/gcc/config/pru/pru.opt
new file mode 100644
index 0000000..d81289a
--- /dev/null
+++ b/gcc/config/pru/pru.opt
@@ -0,0 +1,27 @@
+; Options for the TI PRU port of the compiler.
+; Copyright (C) 2012-2014 Free Software Foundation, Inc.
+; Contributed by Altera and Mentor Graphics, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 3, or (at your option)
+; any later version.
+;
+; GCC is distributed in the hope that it will be useful,
+; but WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+; GNU General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+minrt
+Target Report Mask(MINRT) RejectNegative
+Use a minimum runtime (no static initializers or ctors) for memory-constrained devices.
+
+mmcu=
+Target RejectNegative Joined
+-mmcu=MCU	Select the target System-On-Chip variant that embeds this PRU
diff --git a/gcc/config/pru/t-pru b/gcc/config/pru/t-pru
new file mode 100644
index 0000000..2bbdeb9
--- /dev/null
+++ b/gcc/config/pru/t-pru
@@ -0,0 +1,25 @@
+# Makefile fragment for building GCC for the TI PRU target.
+# Copyright (C) 2012-2013 Free Software Foundation, Inc.
+# Contributed by DDD
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 3, or (at your
+# option) any later version.
+#
+# GCC is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the  GNU General Public
+# License along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+#MULTILIB_OPTIONS    = mmcu=pru
+
+pru-pragma.o: $(srcdir)/config/pru/pru-pragma.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
+
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 50815d1..eea763d 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -17424,6 +17424,7 @@ for further explanation.
 * ARM Pragmas::
 * M32C Pragmas::
 * MeP Pragmas::
+* PRU Pragmas::
 * RS/6000 and PowerPC Pragmas::
 * Darwin Pragmas::
 * Solaris Pragmas::
@@ -17561,6 +17562,25 @@ extern int foo ();
 
 @end table
 
+@node PRU Pragmas
+@subsection PRU Pragmas
+
+@table @code
+
+@item ctable_entry @var{index} @var{constant_address}
+@cindex pragma, ctable_entry
+Specifies that the given PRU CTABLE entry at @var{index} has a value
+@var{constant_address}. This enables GCC to emit LBCO/SBCO instructions
+when the load/store address is known and can be addressed with some CTABLE
+entry. Example:
+
+@smallexample
+#pragma ctable_entry 2 0x4802a000
+*(unsigned int *)0x4802a010 = val; /* will compile to "lbco Rx, 2, 0x10, 4" */
+@end smallexample
+
+@end table
+
 @node RS/6000 and PowerPC Pragmas
 @subsection RS/6000 and PowerPC Pragmas
 
diff --git a/gcc/doc/md.texi b/gcc/doc/md.texi
index bc1ec9d..bba8567 100644
--- a/gcc/doc/md.texi
+++ b/gcc/doc/md.texi
@@ -3209,6 +3209,25 @@ Vector constant that is all zeros.
 
 @end table
 
+@item PRU---@file{config/pru/constraints.md}
+@table @code
+@item I
+An unsigned 8-bit integer constant.
+
+@item J
+An unsigned 16-bit integer constant.
+
+@item L
+An unsigned 5-bit integer constant (for shift counts).
+
+@item M
+An integer constant in the range [-255;0].
+
+@item T
+A text segment (program memory) constant label.
+
+@end table
+
 @item RL78---@file{config/rl78/constraints.md}
 @table @code
 
diff --git a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
index 34d0313..ff90620 100644
--- a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
+++ b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
@@ -74,6 +74,9 @@ __aeabi_idiv0 (int return_value)
 #elif defined (__nvptx__)
 /* There isn't even a signal function.  */
 # define DO_TEST 0
+#elif defined (__pru__)
+/* There isn't even a signal function.  */
+# define DO_TEST 0
 #else
 # define DO_TEST 1
 #endif
diff --git a/gcc/testsuite/gcc.dg/20020312-2.c b/gcc/testsuite/gcc.dg/20020312-2.c
index 71201fe..80430ac 100644
--- a/gcc/testsuite/gcc.dg/20020312-2.c
+++ b/gcc/testsuite/gcc.dg/20020312-2.c
@@ -108,6 +108,8 @@ extern void abort (void);
 /* No pic register.  */
 #elif defined (__nvptx__)
 /* No pic register.  */
+#elif defined(__PRU__)
+/* No pic register.  */
 #else
 # error "Modify the test for your target."
 #endif
diff --git a/gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-1.c b/gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-1.c
index 07285a9..30236a8 100644
--- a/gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-1.c
+++ b/gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-1.c
@@ -29,7 +29,7 @@ int
 main (void)
 {
   int a[50];
-  foo (a, 50);
+  foo (a, 49);
   int res = array_sum (a);
   if (res != 49)
     abort ();
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
index 5985f60..a6e76e6 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* pru*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target mips*-*-* avr-*-* s390*-*-* i?86-*-* x86_64-*-* } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
index 81fd568..8ac76b5 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* pru*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target mips*-*-* avr-*-* s390*-*-* i?86-*-* x86_64-*-* } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
index 6d28b10..30cbc86 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* pru*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target mips*-*-* avr-*-* s390*-*-* i?86-*-* x86_64-*-* } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
index 650bef9..806fc68 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* pru*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target mips*-*-* avr-*-* s390*-*-* i?86-*-* x86_64-*-* } } */
diff --git a/gcc/testsuite/gcc.target/pru/pru-pragma-ctable_entry.c b/gcc/testsuite/gcc.target/pru/pru-pragma-ctable_entry.c
new file mode 100644
index 0000000..5a7cef6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/pru-pragma-ctable_entry.c
@@ -0,0 +1,22 @@
+/* Test specification of custom instructions via command-line options.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+/* -O1 in the options is significant.  Without it LBCO/SBCO operations may
+   not be optimized to the respective instructions.  */
+
+
+#pragma ctable_entry 12 0x48040000
+
+unsigned int
+test_ctable (unsigned int val1, unsigned int val2)
+{
+  ((volatile unsigned short int *)0x48040000)[0] = val2;
+  ((volatile unsigned int *)0x48040000)[val1] = val2;
+  return ((volatile unsigned int *)0x48040000)[4];
+}
+
+/* { dg-final { scan-assembler "sbco\\tr15, 12, 0, 2" } } */
+/* { dg-final { scan-assembler "sbco\\tr15, 12, r14, 4" } } */
+/* { dg-final { scan-assembler "lbco\\tr14, 12, 16, 4" } } */
diff --git a/gcc/testsuite/gcc.target/pru/pru.exp b/gcc/testsuite/gcc.target/pru/pru.exp
new file mode 100644
index 0000000..122a2b3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/pru.exp
@@ -0,0 +1,41 @@
+# Copyright (C) 2015 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't a PRU target.
+if ![istarget pru*-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/lib/gcc-dg.exp b/gcc/testsuite/lib/gcc-dg.exp
index 4fa433d..967f6b9 100644
--- a/gcc/testsuite/lib/gcc-dg.exp
+++ b/gcc/testsuite/lib/gcc-dg.exp
@@ -232,6 +232,11 @@ proc gcc-dg-prune { system text } {
 	return "::unsupported::memory full"
     }
 
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* overflowed by \[^\n\]* bytes" $text] {
+	# The format here is important.  See dg.exp.
+	return "::unsupported::memory full"
+    }
+
     if { [regexp "(^|\n)\[^\n\]*: relocation truncated to fit" $text]
           && [check_effective_target_tiny] } {
         return "::unsupported::memory full"
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index f632d00..4d46013 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -451,7 +451,8 @@ proc check_effective_target_trampolines { } {
 	 || [istarget msp430-*-*]
 	 || [istarget nvptx-*-*]
 	 || [istarget hppa2.0w-hp-hpux11.23]
-	 || [istarget hppa64-hp-hpux11.23] } {
+	 || [istarget hppa64-hp-hpux11.23]
+	 || [istarget pru-*-*] } {
 	return 0;
     }
     return 1
@@ -549,6 +550,7 @@ proc check_profiling_available { test_what } {
 	     || [istarget nvptx-*-*]
 	     || [istarget powerpc-*-eabi*]
 	     || [istarget powerpc-*-elf]
+	     || [istarget pru-*-*]
 	     || [istarget rx-*-*]	
 	     || [istarget tic6x-*-elf]
 	     || [istarget visium-*-*]
@@ -732,7 +734,7 @@ proc check_effective_target_tls_emulated {} {
 proc check_effective_target_tls_runtime {} {
     # The runtime does not have TLS support, but just
     # running the test below is insufficient to show this.
-    if { [istarget msp430-*-*] || [istarget visium-*-*] } {
+    if { [istarget msp430-*-*] || [istarget visium-*-*] || [istarget pru-*-*] } {
 	return 0
     }
     return [check_runtime tls_runtime {
@@ -6172,6 +6174,7 @@ proc check_effective_target_logical_op_short_circuit {} {
 	 || [istarget powerpc*-*-*]
 	 || [istarget nios2*-*-*]
 	 || [istarget visium-*-*]
+	 || [istarget pru*-*-*]
 	 || [check_effective_target_arm_cortex_m] } {
 	return 1
     }
diff --git a/gcc/testsuite/lib/target-utils.exp b/gcc/testsuite/lib/target-utils.exp
index dbfb818..ba2b57b 100644
--- a/gcc/testsuite/lib/target-utils.exp
+++ b/gcc/testsuite/lib/target-utils.exp
@@ -28,6 +28,9 @@
 load_lib target-supports.exp
 
 proc ${tool}_check_unsupported_p { output } {
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* overflowed by \[^\n\]* bytes" $output] {
+	return "memory full"
+    }
     if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $output] {
 	return "memory full"
     }
diff --git a/libgcc/config.host b/libgcc/config.host
index 4b15895..638d531 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -165,6 +165,9 @@ nios2*-*-*)
 powerpc*-*-*)
 	cpu_type=rs6000
 	;;
+pru-*-*)
+	cpu_type=pru
+	;;
 rs6000*-*-*)
 	;;
 sparc64*-*-*)
@@ -1057,6 +1060,9 @@ powerpcle-*-eabi*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-crtstuff t-crtstuff-pic t-fdpbit"
 	extra_parts="$extra_parts crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o ecrti.o ecrtn.o ncrti.o ncrtn.o"
 	;;
+pru-*-*)
+	tmake_file="$tm_file t-fdpbit pru/t-pru"
+	;;
 rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
 	md_unwind_header=rs6000/aix-unwind.h
 	tmake_file="t-fdpbit rs6000/t-ppc64-fp rs6000/t-slibgcc-aix rs6000/t-ibm-ldouble"
diff --git a/libgcc/config/pru/lib2bitcountHI.c b/libgcc/config/pru/lib2bitcountHI.c
new file mode 100644
index 0000000..09e0d4e
--- /dev/null
+++ b/libgcc/config/pru/lib2bitcountHI.c
@@ -0,0 +1,43 @@
+/* libgcc routines for PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Red Hat.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+typedef          int  sint32_type   __attribute__ ((mode (SI)));
+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));
+typedef          int  sint16_type   __attribute__ ((mode (HI)));
+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));
+typedef          int  sint08_type   __attribute__ ((mode (QI)));
+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));
+typedef int           word_type     __attribute__ ((mode (__word__)));
+
+#define C3B(a,b,c) a##b##c
+#define C3(a,b,c) C3B(a,b,c)
+
+#define L_clzsi2
+#define L_ctzsi2
+#define L_ffssi2
+#define L_paritysi2
+#define L_popcountsi2
+
+#include "libgcc2.c"
diff --git a/libgcc/config/pru/lib2divHI.c b/libgcc/config/pru/lib2divHI.c
new file mode 100644
index 0000000..0f89c7e
--- /dev/null
+++ b/libgcc/config/pru/lib2divHI.c
@@ -0,0 +1,42 @@
+/* HI mode divide routines for libgcc for PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Red Hat.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+typedef          int  sint32_type   __attribute__ ((mode (SI)));
+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));
+typedef          int  sint16_type   __attribute__ ((mode (HI)));
+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));
+typedef          int  sint08_type   __attribute__ ((mode (QI)));
+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));
+typedef int           word_type     __attribute__ ((mode (__word__)));
+
+#define C3B(a,b,c) a##b##c
+#define C3(a,b,c) C3B(a,b,c)
+
+#define UINT_TYPE	uint16_type
+#define SINT_TYPE	sint16_type
+#define BITS_MINUS_1	15
+#define NAME_MODE	hi
+
+#include "pru-divmod.h"
diff --git a/libgcc/config/pru/lib2divQI.c b/libgcc/config/pru/lib2divQI.c
new file mode 100644
index 0000000..484e865
--- /dev/null
+++ b/libgcc/config/pru/lib2divQI.c
@@ -0,0 +1,43 @@
+/* QI mode divide routines for libgcc for PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Red Hat.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+typedef          int  sint32_type   __attribute__ ((mode (SI)));
+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));
+typedef          int  sint16_type   __attribute__ ((mode (HI)));
+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));
+typedef          int  sint08_type   __attribute__ ((mode (QI)));
+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));
+typedef int           word_type     __attribute__ ((mode (__word__)));
+
+#define C3B(a,b,c) a##b##c
+#define C3(a,b,c) C3B(a,b,c)
+
+#define UINT_TYPE	uint08_type
+#define SINT_TYPE	sint08_type
+#define BITS_MINUS_1	7
+#define NAME_MODE	qi
+
+#include "pru-divmod.h"
+
diff --git a/libgcc/config/pru/lib2divSI.c b/libgcc/config/pru/lib2divSI.c
new file mode 100644
index 0000000..1daa91a
--- /dev/null
+++ b/libgcc/config/pru/lib2divSI.c
@@ -0,0 +1,42 @@
+/* SI mode divide routines for libgcc for PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Red Hat.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+typedef          int  sint32_type   __attribute__ ((mode (SI)));
+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));
+typedef          int  sint16_type   __attribute__ ((mode (HI)));
+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));
+typedef          int  sint08_type   __attribute__ ((mode (QI)));
+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));
+typedef int           word_type     __attribute__ ((mode (__word__)));
+
+#define C3B(a,b,c) a##b##c
+#define C3(a,b,c) C3B(a,b,c)
+
+#define UINT_TYPE	uint32_type
+#define SINT_TYPE	sint32_type
+#define BITS_MINUS_1	31
+#define NAME_MODE	si
+
+#include "pru-divmod.h"
diff --git a/libgcc/config/pru/lib2shift.c b/libgcc/config/pru/lib2shift.c
new file mode 100644
index 0000000..6b01564
--- /dev/null
+++ b/libgcc/config/pru/lib2shift.c
@@ -0,0 +1,48 @@
+/* Shift functions for the GCC support library for the PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+typedef          int  sint32_type   __attribute__ ((mode (SI)));
+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));
+typedef          int  sint16_type   __attribute__ ((mode (HI)));
+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));
+
+sint32_type __ashrsi3 (sint32_type in, char bit);
+
+sint32_type
+__ashrsi3 (sint32_type in, char bit)
+{
+  sint32_type sign = in & (1 << 31);
+
+  if (bit > 32)
+    return 0;
+  if (bit < 0)
+    return in;
+
+  while (bit--)
+    in = ((uint32_type)in >> 1) | sign;
+
+  return in;
+}
+
diff --git a/libgcc/config/pru/muldi3.S b/libgcc/config/pru/muldi3.S
new file mode 100644
index 0000000..5aaef32
--- /dev/null
+++ b/libgcc/config/pru/muldi3.S
@@ -0,0 +1,60 @@
+/*  Copyright (C) 2014 Free Software Foundation, Inc.
+    Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+  This file is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the
+  Free Software Foundation; either version 3, or (at your option) any
+  later version.
+
+  This file is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Under Section 7 of GPL version 3, you are granted additional
+  permissions described in the GCC Runtime Library Exception, version
+  3.1, as published by the Free Software Foundation.
+
+  You should have received a copy of the GNU General Public License and
+  a copy of the GCC Runtime Library Exception along with this program;
+  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+  <http://www.gnu.org/licenses/>.
+
+      (al + C * ah) * (bl + C * bh) =    al * bl
+				       + C * ah * bl
+				       + C * al * bh
+				       + C * C * ah * bh  -> discard, overflow
+	Where C=(1 << 32)
+  */
+
+#include "pru-asm.h"
+
+	.global	SYM(__muldi3)
+	FUNC(__muldi3)
+SYM(__muldi3):
+	/* switch to MUL mode */
+	ldi	r25, 0
+	xout	0, r25, 1
+
+	/* + C * ah * bl */
+	mov	r28, r15
+	mov	r29, r16
+	xin	0, r26, 8
+	mov	r15, r26		/* "loose" ah, record only reslo */
+
+	/* + C * al * bh */
+	mov	r28, r14
+	mov	r29, r17
+	xin	0, r26, 8
+	add	r15, r15, r26
+
+	/* + al * bl */
+	/* mov	r28, r14		-> no need, already loaded */
+	mov	r29, r16
+	xin	0, r26, 8
+	mov	r14, r26
+	add	r15, r15, r27
+
+	ret
+
+	ENDFUNC(__muldi3)
diff --git a/libgcc/config/pru/pru-asm.h b/libgcc/config/pru/pru-asm.h
new file mode 100644
index 0000000..4315ee6
--- /dev/null
+++ b/libgcc/config/pru/pru-asm.h
@@ -0,0 +1,36 @@
+/*  Copyright (C) 2014 Free Software Foundation, Inc.
+    Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+  This file is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the
+  Free Software Foundation; either version 3, or (at your option) any
+  later version.
+
+  This file is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Under Section 7 of GPL version 3, you are granted additional
+  permissions described in the GCC Runtime Library Exception, version
+  3.1, as published by the Free Software Foundation.
+
+  You should have received a copy of the GNU General Public License and
+  a copy of the GCC Runtime Library Exception along with this program;
+  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+  <http://www.gnu.org/licenses/>. */
+
+/* ANSI concatenation macros.  */
+
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define CONCAT2(a, b) a ## b
+
+/* Use the right prefix for global labels.  */
+
+#define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
+
+#define FUNC(X)		.type SYM(X),@function
+#define HIDDEN_FUNC(X)	FUNC(X)` .hidden SYM(X)
+#define ENDFUNC0(X)	CONCAT1(.Lfe_,X): .size X,CONCAT1(.Lfe_,X)-X
+#define ENDFUNC(X)	ENDFUNC0(SYM(X))
+
diff --git a/libgcc/config/pru/pru-divmod.h b/libgcc/config/pru/pru-divmod.h
new file mode 100644
index 0000000..5458c3a
--- /dev/null
+++ b/libgcc/config/pru/pru-divmod.h
@@ -0,0 +1,117 @@
+/* libgcc routines for PRU
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Red Hat.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+UINT_TYPE C3(udivmod,NAME_MODE,4) (UINT_TYPE, UINT_TYPE, word_type);
+SINT_TYPE C3(__div,NAME_MODE,3)   (SINT_TYPE, SINT_TYPE);
+SINT_TYPE C3(__mod,NAME_MODE,3)   (SINT_TYPE, SINT_TYPE);
+UINT_TYPE C3(__udiv,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);
+UINT_TYPE C3(__umod,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);
+
+UINT_TYPE
+C3(udivmod,NAME_MODE,4) (UINT_TYPE num, UINT_TYPE den, word_type modwanted)
+{
+  UINT_TYPE bit = 1;
+  UINT_TYPE res = 0;
+
+  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
+    {
+      den <<= 1;
+      bit <<= 1;
+    }
+  while (bit)
+    {
+      if (num >= den)
+	{
+	  num -= den;
+	  res |= bit;
+	}
+      bit >>= 1;
+      den >>= 1;
+    }
+  if (modwanted)
+    return num;
+  return res;
+}
+
+SINT_TYPE
+C3(__div,NAME_MODE,3) (SINT_TYPE a, SINT_TYPE b)
+{
+  word_type neg = 0;
+  SINT_TYPE res;
+
+  if (a < 0)
+    {
+      a = -a;
+      neg = !neg;
+    }
+
+  if (b < 0)
+    {
+      b = -b;
+      neg = !neg;
+    }
+
+  res = C3(udivmod,NAME_MODE,4) (a, b, 0);
+
+  if (neg)
+    res = -res;
+
+  return res;
+}
+
+SINT_TYPE
+C3(__mod,NAME_MODE,3) (SINT_TYPE a, SINT_TYPE b)
+{
+  word_type neg = 0;
+  SINT_TYPE res;
+
+  if (a < 0)
+    {
+      a = -a;
+      neg = 1;
+    }
+
+  if (b < 0)
+    b = -b;
+
+  res = C3(udivmod,NAME_MODE,4) (a, b, 1);
+
+  if (neg)
+    res = -res;
+
+  return res;
+}
+
+UINT_TYPE
+C3(__udiv,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)
+{
+  return C3(udivmod,NAME_MODE,4) (a, b, 0);
+}
+
+UINT_TYPE
+C3(__umod,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)
+{
+  return C3(udivmod,NAME_MODE,4) (a, b, 1);
+}
diff --git a/libgcc/config/pru/t-pru b/libgcc/config/pru/t-pru
new file mode 100644
index 0000000..470f0d4
--- /dev/null
+++ b/libgcc/config/pru/t-pru
@@ -0,0 +1,40 @@
+# Makefile fragment for building LIBGCC for the TI PRU processor.
+# Copyright (C) 2011 Free Software Foundation, Inc.
+# Contributed by Red Hat.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 3, or (at your
+# option) any later version.
+#
+# GCC is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See
+# the GNU General Public License for more details.
+#
+# You should have received a copy of the  GNU General Public
+# License along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Note - we have separate versions of the lib2div<mode> files
+# as the functions are quite large and we do not want to pull
+# in unneeded division routines.
+
+LIB2ADD = \
+        $(srcdir)/config/pru/lib2divQI.c \
+        $(srcdir)/config/pru/lib2divHI.c \
+        $(srcdir)/config/pru/lib2divSI.c \
+        $(srcdir)/config/pru/lib2bitcountHI.c \
+        $(srcdir)/config/pru/lib2shift.c \
+        $(srcdir)/config/pru/muldi3.S
+
+
+HOST_LIBGCC2_CFLAGS += -Os -ffunction-sections -fdata-sections
+
+LIB2FUNCS_EXCLUDE = _muldi3
+
+# Local Variables:
+# mode: Makefile
+# End:
-- 
2.1.4


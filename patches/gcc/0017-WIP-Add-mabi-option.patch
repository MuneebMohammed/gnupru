From 6b90cc651eaa777aa5e695aca9477a2d1e242929 Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dimitar@dinux.eu>
Date: Sat, 23 Sep 2017 20:40:44 +0300
Subject: [PATCH 17/17] WIP: Add mabi option

Signed-off-by: Dimitar Dimitrov <dimitar@dinux.eu>
---
 gcc/config.gcc                           |   3 +-
 gcc/config/pru/pru-opts.h                |  31 +++++
 gcc/config/pru/pru-passes.c              | 197 +++++++++++++++++++++++++++++++
 gcc/config/pru/pru-protos.h              |   5 +
 gcc/config/pru/pru.c                     |  60 +++-------
 gcc/config/pru/pru.h                     |   2 +
 gcc/config/pru/pru.opt                   |  19 ++-
 gcc/config/pru/t-pru                     |   6 +-
 gcc/doc/invoke.texi                      |  55 +++++++++
 gcc/testsuite/gcc.target/pru/mabi-ti-1.c |  10 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-2.c |  15 +++
 gcc/testsuite/gcc.target/pru/mabi-ti-3.c |  12 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-4.c |  14 +++
 gcc/testsuite/gcc.target/pru/mabi-ti-5.c |  33 ++++++
 14 files changed, 417 insertions(+), 45 deletions(-)
 create mode 100644 gcc/config/pru/pru-opts.h
 create mode 100644 gcc/config/pru/pru-passes.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-1.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-2.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-3.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-4.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-5.c

diff --git a/gcc/config.gcc b/gcc/config.gcc
index dda6e8ae4b5..3c2a629a4b1 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2602,8 +2602,7 @@ powerpcle-*-eabi*)
 pru*-*-*)
 	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
 	tmake_file="${tmake_file} pru/t-pru"
-	c_target_objs="pru-pragma.o"
-	cxx_target_objs="pru-pragma.o"
+	extra_objs="pru-pragma.o pru-passes.o"
 	use_gcc_stdint=wrap
 	;;
 rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
diff --git a/gcc/config/pru/pru-opts.h b/gcc/config/pru/pru-opts.h
new file mode 100644
index 00000000000..056d15a9372
--- /dev/null
+++ b/gcc/config/pru/pru-opts.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2017 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Definitions for option handling for PRU.  */
+
+#ifndef GCC_AARCH64_OPTS_H
+#define GCC_AARCH64_OPTS_H
+
+/* ABI variant for code generation.  */
+enum pru_abi {
+    PRU_ABI_GNU,
+    PRU_ABI_TI
+};
+
+#endif
diff --git a/gcc/config/pru/pru-passes.c b/gcc/config/pru/pru-passes.c
new file mode 100644
index 00000000000..3044aa199a0
--- /dev/null
+++ b/gcc/config/pru/pru-passes.c
@@ -0,0 +1,197 @@
+/* PRU target specific passes
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   Dimitar Dimitrov <dimitar@dinux.eu>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "context.h"
+#include "tm.h"
+#include "alias.h"
+#include "symtab.h"
+#include "tree.h"
+#include "diagnostic-core.h"
+#include "function.h"
+#include "gimple.h"
+#include "gimple-iterator.h"
+#include "gimple-walk.h"
+#include "gimple-expr.h"
+#include "tree-pass.h"
+
+#include "pru-protos.h"
+
+namespace {
+
+/* Scan the tree to ensure that the compiled code by GCC
+   conforms to the TI ABI specification.  If GCC cannot
+   output a conforming code, raise an error.  */
+const pass_data pass_data_tiabi_check =
+{
+  GIMPLE_PASS, /* type */
+  "tiabi_check", /* name */
+  OPTGROUP_NONE, /* optinfo_flags */
+  TV_NONE, /* tv_id */
+  PROP_gimple_any, /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  0, /* todo_flags_finish */
+};
+
+class pass_tiabi_check : public gimple_opt_pass
+{
+public:
+  pass_tiabi_check(gcc::context *ctxt)
+    : gimple_opt_pass(pass_data_tiabi_check, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  virtual unsigned int execute (function *);
+
+  virtual bool gate (function *fun ATTRIBUTE_UNUSED)
+  {
+    return pru_current_abi == PRU_ABI_TI;
+  }
+
+}; // class pass_tiabi_check
+
+
+
+/* Return 1 if type TYPE is a pointer to function type or a
+   structure having a pointer to function type as one of its fields.
+   Otherwise return 0.  */
+static bool
+chkp_type_has_function_pointer (const_tree type)
+{
+  bool res = false;
+
+  if (BOUNDED_TYPE_P (type) && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (type)))
+    res = true;
+  else if (RECORD_OR_UNION_TYPE_P (type))
+    {
+      tree field;
+
+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))
+	if (TREE_CODE (field) == FIELD_DECL)
+	  res = res || chkp_type_has_function_pointer (TREE_TYPE (field));
+    }
+  else if (TREE_CODE (type) == ARRAY_TYPE)
+    res = chkp_type_has_function_pointer (TREE_TYPE (type));
+
+  return res;
+}
+
+static tree
+check_op_callback (tree *tp, int *walk_subtrees, void *data)
+{
+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;
+
+  const tree type = TREE_TYPE (*tp);
+  switch (TREE_CODE (type))
+    {
+    case FUNCTION_TYPE:
+    case METHOD_TYPE:
+	{
+	  /* Note: Do not enforce a small return value. It is safe to
+	     call any TI ABI function from GCC, since GCC will
+	     never pass NULL.  */
+
+	  /* Check arguments for function pointers.  */
+	  for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))
+	    {
+	      tree arg_type = TREE_VALUE (p);
+	      if (chkp_type_has_function_pointer (arg_type))
+		{
+		  error_at (gimple_location (wi->stmt),
+			    "function pointers not supported with -mabi=ti option");
+		}
+	    }
+	  break;
+	}
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+	{
+	  if (chkp_type_has_function_pointer (type))
+	    {
+	      error_at (gimple_location (wi->stmt),
+			"function pointers not supported with -mabi=ti option");
+	      *walk_subtrees = false;
+	    }
+	  break;
+	}
+    default:
+	  break;
+    }
+  return NULL;
+}
+
+unsigned
+pass_tiabi_check::execute (function *fun)
+{
+  struct walk_stmt_info wi;
+  const_tree fntype = TREE_TYPE (fun->decl);
+
+  gimple_seq body = fun->gimple_body;
+
+  memset (&wi, 0, sizeof (wi));
+  wi.info = NULL;
+  wi.want_locations = true;
+
+  walk_gimple_seq (body, NULL, check_op_callback, &wi);
+
+  /* GCC does not check if the RETURN VALUE pointer is NULL,
+     so do not allow GCC functions with large return values.  */
+  if (!VOID_TYPE_P (TREE_TYPE (fntype))
+      && pru_return_in_memory (TREE_TYPE (fntype), fntype))
+    error_at (fun->function_start_locus,
+	      "large return values not supported with -mabi=ti option");
+
+  /* Check this function's arguments.  */
+  for (tree p = TYPE_ARG_TYPES (fntype); p; p = TREE_CHAIN (p))
+    {
+      tree arg_type = TREE_VALUE (p);
+      if (chkp_type_has_function_pointer (arg_type))
+	{
+	  error_at (fun->function_start_locus,
+		    "function pointers not supported with -mabi=ti option");
+	}
+    }
+  return 0;
+}
+
+} // anon namespace
+
+gimple_opt_pass *
+make_pass_tiabi_check (gcc::context *ctxt)
+{
+  return new pass_tiabi_check (ctxt);
+}
+
+void
+pru_register_abicheck_pass (void)
+{
+  opt_pass *tiabi_check = make_pass_tiabi_check (g);
+  struct register_pass_info tiabi_check_info
+    = { tiabi_check, "omplower",
+	1, PASS_POS_INSERT_BEFORE
+      };
+  register_pass (&tiabi_check_info);
+}
diff --git a/gcc/config/pru/pru-protos.h b/gcc/config/pru/pru-protos.h
index f05029eac54..cd15be7ed15 100644
--- a/gcc/config/pru/pru-protos.h
+++ b/gcc/config/pru/pru-protos.h
@@ -59,6 +59,11 @@ extern int pru_get_ctable_exact_base_index (unsigned HOST_WIDE_INT caddr);
 extern int pru_get_ctable_base_index (unsigned HOST_WIDE_INT caddr);
 extern int pru_get_ctable_base_offset (unsigned HOST_WIDE_INT caddr);
 
+extern void pru_register_abicheck_pass (void);
 #endif /* RTX_CODE */
 
+#ifdef TREE_CODE
+bool pru_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED);
+#endif /* TREE_CODE */
+
 #endif /* GCC_PRU_PROTOS_H */
diff --git a/gcc/config/pru/pru.c b/gcc/config/pru/pru.c
index 10df43d47c3..8c23ca4bd7e 100644
--- a/gcc/config/pru/pru.c
+++ b/gcc/config/pru/pru.c
@@ -540,7 +540,7 @@ pru_hard_regno_mode_ok (unsigned int regno, machine_mode mode)
     case 1: return true;
     case 2: return (regno % 4) <= 2;
     case 4: return (regno % 4) == 0;
-    default: return (regno % 4) == 0; /* TODO - check why we get VOIDmode.  */
+    default: return (regno % 4) == 0; /* Not sure why VOIDmode is passed.  */
     }
 }
 
@@ -594,6 +594,16 @@ pru_hard_regno_rename_ok (unsigned int old_reg,
   return 1;
 }
 
+
+static void
+pru_init (void)
+{
+  /* Due to difficulties in implementing the TI ABI with GCC,
+     at least check and error-out if GCC cannot compile a
+     complient output.  */
+  pru_register_abicheck_pass ();
+}
+
 /* Allocate a chunk of memory for per-function machine-dependent data.  */
 static struct machine_function *
 pru_init_machine_status (void)
@@ -637,6 +647,9 @@ pru_option_override (void)
      options.  */
   target_option_default_node = target_option_current_node
     = build_target_option_node (&global_options);
+
+  /* This needs to be done at start up.  It's convenient to do it here.  */
+  pru_init ();
 }
 
 /* Compute a (partial) cost for rtx X.  Return true if the complete
@@ -1919,47 +1932,15 @@ pru_function_value_regno_p (const unsigned int regno)
 }
 
 /* Implement TARGET_RETURN_IN_MEMORY.  */
-static bool
+bool
 pru_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
-  return (int_size_in_bytes (type) > (2 * 4 * UNITS_PER_WORD)
-	  || int_size_in_bytes (type) == -1);
-}
-
-#if 0
-/* TODO: It may be possible to eliminate the copyback and implement
-   own va_arg type.  */
-static void
-pru_setup_incoming_varargs (cumulative_args_t cum_v,
-			    machine_mode mode, tree type,
-			    int *pretend_size, int second_time)
-{
-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
-  CUMULATIVE_ARGS local_cum;
-  cumulative_args_t local_cum_v = pack_cumulative_args (&local_cum);
-  int regs_to_push;
-  int pret_size;
+  bool in_memory = (int_size_in_bytes (type) > (2 * 4 * UNITS_PER_WORD)
+		    || int_size_in_bytes (type) == -1);
 
-  local_cum = *cum;
-  pru_function_arg_advance (local_cum_v, mode, type, 1);
-
-  regs_to_push = NUM_ARG_REGS - local_cum.regs_used;
-
-  if (!second_time && regs_to_push > 0)
-    {
-      rtx ptr = virtual_incoming_args_rtx;
-      rtx mem = gen_rtx_MEM (BLKmode, ptr);
-      emit_insn (gen_blockage ());
-      move_block_from_reg (local_cum.regs_used + FIRST_ARG_REGNO, mem,
-			   regs_to_push);
-      emit_insn (gen_blockage ());
-    }
-
-  pret_size = regs_to_push * UNITS_PER_WORD;
-  if (pret_size)
-    *pretend_size = pret_size;
+  return in_memory;
 }
-#endif
+
 
 /* Implement TARGET_CAN_USE_DOLOOP_P.  */
 
@@ -2735,9 +2716,6 @@ pru_set_current_function (tree fndecl)
 #undef TARGET_RETURN_IN_MEMORY
 #define TARGET_RETURN_IN_MEMORY pru_return_in_memory
 
-//#undef TARGET_SETUP_INCOMING_VARARGS
-//#define TARGET_SETUP_INCOMING_VARARGS pru_setup_incoming_varargs
-
 #undef TARGET_MUST_PASS_IN_STACK
 #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
 
diff --git a/gcc/config/pru/pru.h b/gcc/config/pru/pru.h
index 4fe63ba741c..f4f077e74fc 100644
--- a/gcc/config/pru/pru.h
+++ b/gcc/config/pru/pru.h
@@ -21,6 +21,8 @@
 #ifndef GCC_PRU_H
 #define GCC_PRU_H
 
+#include "config/pru/pru-opts.h"
+
 /* Define built-in preprocessor macros.  */
 #define TARGET_CPU_CPP_BUILTINS()		    \
   do						    \
diff --git a/gcc/config/pru/pru.opt b/gcc/config/pru/pru.opt
index df76ed5c593..97af71a04a1 100644
--- a/gcc/config/pru/pru.opt
+++ b/gcc/config/pru/pru.opt
@@ -18,6 +18,9 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
+HeaderInclude
+config/pru/pru-opts.h
+
 minrt
 Target Report Mask(MINRT) RejectNegative
 Use a minimum runtime (no static initializers or ctors) for memory-constrained devices.
@@ -32,4 +35,18 @@ Prevent relaxation of LDI instructions with hi_rlz modifier.
 
 mloop
 Target Mask(OPT_LOOP)
-Allow gcc to use the LOOP instruction.
+Allow (or do not allow) gcc to use the LOOP instruction.
+
+mabi=
+Target RejectNegative Report Joined Enum(pru_abi_t) Var(pru_current_abi) Init(PRU_ABI_GNU) Save
+Select target ABI variant.
+
+Enum
+Name(pru_abi_t) Type(enum pru_abi)
+ABI variant code generation (for use with -mabi= option):
+
+EnumValue
+Enum(pru_abi_t) String(gnu) Value(PRU_ABI_GNU)
+
+EnumValue
+Enum(pru_abi_t) String(ti) Value(PRU_ABI_TI)
diff --git a/gcc/config/pru/t-pru b/gcc/config/pru/t-pru
index af3eac95c31..b74d3685047 100644
--- a/gcc/config/pru/t-pru
+++ b/gcc/config/pru/t-pru
@@ -20,6 +20,10 @@
 
 #MULTILIB_OPTIONS    = mmcu=pru
 
-pru-pragma.o: $(srcdir)/config/pru/pru-pragma.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H)
+pru-pragma.o: $(srcdir)/config/pru/pru-pragma.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H) \
+		$(srcdir)/config/pru/pru-protos.h
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
 
+pru-passes.o: $(srcdir)/config/pru/pru-passes.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H) \
+		$(srcdir)/config/pru/pru-protos.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 204c9b77b61..aebca65031a 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -975,6 +975,10 @@ Objective-C and Objective-C++ Dialects}.
 @emph{PowerPC Options}
 See RS/6000 and PowerPC Options.
 
+@emph{PRU Options}
+@gccoptlist{-mmcu=@var{mcu}  -minrt -mno-relax -mloop @gol
+-mabi=@var{variant} @gol}
+
 @emph{RISC-V Options}
 @gccoptlist{-mbranch-cost=@var{N-instruction} @gol
 -mmemcpy  -mno-memcpy @gol
@@ -14031,6 +14035,7 @@ platform.
 * PDP-11 Options::
 * picoChip Options::
 * PowerPC Options::
+* PRU Options::
 * RISC-V Options::
 * RL78 Options::
 * RS/6000 and PowerPC Options::
@@ -21535,6 +21540,56 @@ these warnings.
 
 These are listed under @xref{RS/6000 and PowerPC Options}.
 
+@node PRU Options
+@subsection PRU Options
+@cindex PRU Options
+
+These command-line options are defined for PRU target:
+
+@table @gcctabopt
+@item -minrt
+@opindex minrt
+Enable the use of a minimum runtime environment - no static
+initializers or constructors.  Results in significant code size
+reduction of final ELF binaries.
+
+@item -mmcu=@var{mcu}
+@opindex mmcu
+Specify the PRU MCU variant to use. Check the C library for exact
+list of options.
+
+@item -mno-relax
+@opindex mno-relax
+Pass on (or do not pass on) the @option{-mrelax} command-line option
+to the assembler.
+
+@item -mloop
+@opindex mloop
+Allow (or do not allow) gcc to use the LOOP instruction.
+
+@item -mabi=@var{variant}
+@opindex mabi
+Specify the ABI variant to output code for. Permissible values are @samp{gnu}
+for GCC, and @samp{ti} for fully conformant TI ABI. These are the differences:
+
+@table @samp
+@item Function Pointer Size
+TI ABI specifies that function (code) pointers are 16-bit, whereas GCC
+supports only 32-bit data and code pointers.
+
+@item Optional Return Value Pointer
+Function return values larger than 64-bits are passed by using a hidden
+pointer as the first argument of the function. TI ABI, though, mandates that
+the pointer can be NULL in case the caller is not using the returned value.
+GCC always passes a valid return value pointer.
+
+@end table
+
+The current @samp{mabi=ti} implementation will simply raise a compile error
+when any of the above code constructs is detected.
+
+@end table
+
 @node RISC-V Options
 @subsection RISC-V Options
 @cindex RISC-V Options
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-1.c b/gcc/testsuite/gcc.target/pru/mabi-ti-1.c
new file mode 100644
index 00000000000..a4b699e9ff6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-1.c
@@ -0,0 +1,10 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+int test(int a, int b, void (*fp)(void))
+{ /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return a+b;
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-2.c b/gcc/testsuite/gcc.target/pru/mabi-ti-2.c
new file mode 100644
index 00000000000..d6bf7bed29f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-2.c
@@ -0,0 +1,15 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+struct big {
+	char c[9];
+};
+
+struct big test(void)
+{ /* { dg-error "large return values not supported with -mabi=ti option" } */
+  static struct big b;
+  return b;
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-3.c b/gcc/testsuite/gcc.target/pru/mabi-ti-3.c
new file mode 100644
index 00000000000..0789dda82f9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-3.c
@@ -0,0 +1,12 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+extern void extfunc(void (*fp)(void));
+
+void test(void)
+{
+  extfunc(test); /* { dg-error "function pointers not supported with -mabi=ti option" } */
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-4.c b/gcc/testsuite/gcc.target/pru/mabi-ti-4.c
new file mode 100644
index 00000000000..0110e6ce290
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-4.c
@@ -0,0 +1,14 @@
+/* Test TI ABI with supported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+extern void extfunc1(long long);
+extern long long extfunc2(long long);
+
+long long test(void)
+{
+  extfunc1(3);
+  return extfunc2(1);
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-5.c b/gcc/testsuite/gcc.target/pru/mabi-ti-5.c
new file mode 100644
index 00000000000..fa8833fde9c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-5.c
@@ -0,0 +1,33 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+struct s1 {
+    void (*f)(void);
+    int a;
+};
+
+struct s2 {
+    union {
+	void (*f)(void);
+	int a;
+	long b;
+    } u;
+};
+
+int test1(struct s1 *p)
+{
+  return p->a; /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return 1;
+}
+
+int test1_unused_arg(struct s1 p, int a)
+{ /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return a;
+}
+
+int test2(struct s2 v)
+{ /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return 2;
+}
-- 
2.11.0


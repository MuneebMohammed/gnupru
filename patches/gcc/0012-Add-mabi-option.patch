From fd9271fde96244e6c8254ef7e4b20b3b64af49ec Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dimitar@dinux.eu>
Date: Sat, 23 Sep 2017 20:40:44 +0300
Subject: [PATCH 12/16] Add mabi option

Signed-off-by: Dimitar Dimitrov <dimitar@dinux.eu>
---
 gcc/config.gcc                           |   3 +-
 gcc/config/pru/pru-opts.h                |  31 +++++
 gcc/config/pru/pru-passes.c              | 232 +++++++++++++++++++++++++++++++
 gcc/config/pru/pru-protos.h              |   5 +
 gcc/config/pru/pru.c                     |  71 ++++------
 gcc/config/pru/pru.h                     |  32 +++--
 gcc/config/pru/pru.opt                   |  19 ++-
 gcc/config/pru/t-pru                     |   9 +-
 gcc/doc/invoke.texi                      |  56 ++++++++
 gcc/testsuite/gcc.target/pru/mabi-ti-1.c |  10 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-2.c |  15 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-3.c |  12 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-4.c |  14 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-5.c |  33 +++++
 gcc/testsuite/gcc.target/pru/mabi-ti-6.c |  12 ++
 gcc/testsuite/gcc.target/pru/mabi-ti-7.c |  21 +++
 16 files changed, 521 insertions(+), 54 deletions(-)
 create mode 100644 gcc/config/pru/pru-opts.h
 create mode 100644 gcc/config/pru/pru-passes.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-1.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-2.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-3.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-4.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-5.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-6.c
 create mode 100644 gcc/testsuite/gcc.target/pru/mabi-ti-7.c

diff --git a/gcc/config.gcc b/gcc/config.gcc
index bf437aac7d8..cf76a95b669 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2608,8 +2608,7 @@ powerpcle-*-eabi*)
 pru*-*-*)
 	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
 	tmake_file="${tmake_file} pru/t-pru"
-	c_target_objs="pru-pragma.o"
-	cxx_target_objs="pru-pragma.o"
+	extra_objs="pru-pragma.o pru-passes.o"
 	use_gcc_stdint=wrap
 	;;
 rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
diff --git a/gcc/config/pru/pru-opts.h b/gcc/config/pru/pru-opts.h
new file mode 100644
index 00000000000..d63c1c94e13
--- /dev/null
+++ b/gcc/config/pru/pru-opts.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2017 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Definitions for option handling for PRU.  */
+
+#ifndef GCC_PRU_OPTS_H
+#define GCC_PRU_OPTS_H
+
+/* ABI variant for code generation.  */
+enum pru_abi {
+    PRU_ABI_GNU,
+    PRU_ABI_TI
+};
+
+#endif
diff --git a/gcc/config/pru/pru-passes.c b/gcc/config/pru/pru-passes.c
new file mode 100644
index 00000000000..282849479ea
--- /dev/null
+++ b/gcc/config/pru/pru-passes.c
@@ -0,0 +1,232 @@
+/* PRU target specific passes
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   Dimitar Dimitrov <dimitar@dinux.eu>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "context.h"
+#include "tm.h"
+#include "alias.h"
+#include "symtab.h"
+#include "tree.h"
+#include "diagnostic-core.h"
+#include "function.h"
+#include "gimple.h"
+#include "gimple-iterator.h"
+#include "gimple-walk.h"
+#include "gimple-expr.h"
+#include "tree-pass.h"
+#include "gimple-pretty-print.h"
+
+#include "pru-protos.h"
+
+namespace {
+
+/* Scan the tree to ensure that the compiled code by GCC
+   conforms to the TI ABI specification.  If GCC cannot
+   output a conforming code, raise an error.  */
+const pass_data pass_data_tiabi_check =
+{
+  GIMPLE_PASS, /* type */
+  "*tiabi_check", /* name */
+  OPTGROUP_NONE, /* optinfo_flags */
+  TV_NONE, /* tv_id */
+  PROP_gimple_any, /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  0, /* todo_flags_finish */
+};
+
+class pass_tiabi_check : public gimple_opt_pass
+{
+public:
+  pass_tiabi_check(gcc::context *ctxt)
+    : gimple_opt_pass(pass_data_tiabi_check, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  virtual unsigned int execute (function *);
+
+  virtual bool gate (function *fun ATTRIBUTE_UNUSED)
+  {
+    return pru_current_abi == PRU_ABI_TI;
+  }
+
+}; // class pass_tiabi_check
+
+
+
+/* Return 1 if type TYPE is a pointer to function type or a
+   structure having a pointer to function type as one of its fields.
+   Otherwise return 0.  */
+static bool
+chkp_type_has_function_pointer (const_tree type)
+{
+  bool res = false;
+
+  if (BOUNDED_TYPE_P (type) && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (type)))
+    res = true;
+  else if (RECORD_OR_UNION_TYPE_P (type))
+    {
+      tree field;
+
+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))
+	if (TREE_CODE (field) == FIELD_DECL)
+	  res = res || chkp_type_has_function_pointer (TREE_TYPE (field));
+    }
+  else if (TREE_CODE (type) == ARRAY_TYPE)
+    res = chkp_type_has_function_pointer (TREE_TYPE (type));
+
+  return res;
+}
+
+/* Check the function declaration for TI ABI compatibility.  */
+static void
+chk_function_decl (const_tree fntype, location_t call_location)
+{
+  /* GCC does not check if the RETURN VALUE pointer is NULL,
+     so do not allow GCC functions with large return values.  */
+  if (!VOID_TYPE_P (TREE_TYPE (fntype))
+      && pru_return_in_memory (TREE_TYPE (fntype), fntype))
+    error_at (call_location,
+	      "large return values not supported with -mabi=ti option");
+
+  /* Check this function's arguments.  */
+  for (tree p = TYPE_ARG_TYPES (fntype); p; p = TREE_CHAIN (p))
+    {
+      tree arg_type = TREE_VALUE (p);
+      if (chkp_type_has_function_pointer (arg_type))
+	{
+	  error_at (call_location,
+		    "function pointers not supported with -mabi=ti option");
+	}
+    }
+}
+
+static tree
+check_op_callback (tree *tp, int *walk_subtrees, void *data)
+{
+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;
+
+  if (RECORD_OR_UNION_TYPE_P (*tp) || TREE_CODE (*tp) == ENUMERAL_TYPE)
+    {
+      /* Forward declarations have NULL tree type.  Skip them.  */
+      if (TREE_TYPE (*tp) == NULL)
+	return NULL;
+    }
+
+  /* TODO - why C++ leaves INTEGER_TYPE forward declarations around?  */
+  if (TREE_TYPE (*tp) == NULL)
+    return NULL;
+
+  const tree type = TREE_TYPE (*tp);
+
+  /* Direct function calls are allowed, obviously.  */
+  if (TREE_CODE (*tp) == ADDR_EXPR && TREE_CODE (type) == POINTER_TYPE)
+    {
+      const tree ptype = TREE_TYPE (type);
+      if (TREE_CODE (ptype) == FUNCTION_TYPE)
+	return NULL;
+    }
+
+  switch (TREE_CODE (type))
+    {
+    case FUNCTION_TYPE:
+    case METHOD_TYPE:
+	{
+	  /* Note: Do not enforce a small return value. It is safe to
+	     call any TI ABI function from GCC, since GCC will
+	     never pass NULL.  */
+
+	  /* Check arguments for function pointers.  */
+	  for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))
+	    {
+	      tree arg_type = TREE_VALUE (p);
+	      if (chkp_type_has_function_pointer (arg_type))
+		{
+		  error_at (gimple_location (wi->stmt),
+			    "function pointers not supported with -mabi=ti option");
+		}
+	    }
+	  break;
+	}
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+    case POINTER_TYPE:
+	{
+	  if (chkp_type_has_function_pointer (type))
+	    {
+	      error_at (gimple_location (wi->stmt),
+			"function pointers not supported with -mabi=ti option");
+	      *walk_subtrees = false;
+	    }
+	  break;
+	}
+    default:
+	  break;
+    }
+  return NULL;
+}
+
+unsigned
+pass_tiabi_check::execute (function *fun)
+{
+  struct walk_stmt_info wi;
+  const_tree fntype = TREE_TYPE (fun->decl);
+
+  gimple_seq body = gimple_body(current_function_decl);
+
+  memset (&wi, 0, sizeof (wi));
+  wi.info = NULL;
+  wi.want_locations = true;
+
+  /* Check the function body.  */
+  walk_gimple_seq (body, NULL, check_op_callback, &wi);
+
+  /* Check the function declaration.  */
+  chk_function_decl (fntype, fun->function_start_locus);
+
+  return 0;
+}
+
+} // anon namespace
+
+gimple_opt_pass *
+make_pass_tiabi_check (gcc::context *ctxt)
+{
+  return new pass_tiabi_check (ctxt);
+}
+
+/* Register as early as possible.  */
+void
+pru_register_abicheck_pass (void)
+{
+  opt_pass *tiabi_check = make_pass_tiabi_check (g);
+  struct register_pass_info tiabi_check_info
+    = { tiabi_check, "*warn_unused_result",
+	1, PASS_POS_INSERT_AFTER
+      };
+  register_pass (&tiabi_check_info);
+}
diff --git a/gcc/config/pru/pru-protos.h b/gcc/config/pru/pru-protos.h
index f05029eac54..cd15be7ed15 100644
--- a/gcc/config/pru/pru-protos.h
+++ b/gcc/config/pru/pru-protos.h
@@ -59,6 +59,11 @@ extern int pru_get_ctable_exact_base_index (unsigned HOST_WIDE_INT caddr);
 extern int pru_get_ctable_base_index (unsigned HOST_WIDE_INT caddr);
 extern int pru_get_ctable_base_offset (unsigned HOST_WIDE_INT caddr);
 
+extern void pru_register_abicheck_pass (void);
 #endif /* RTX_CODE */
 
+#ifdef TREE_CODE
+bool pru_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED);
+#endif /* TREE_CODE */
+
 #endif /* GCC_PRU_PROTOS_H */
diff --git a/gcc/config/pru/pru.c b/gcc/config/pru/pru.c
index eb5c9f43ed1..003043fdffd 100644
--- a/gcc/config/pru/pru.c
+++ b/gcc/config/pru/pru.c
@@ -542,7 +542,7 @@ pru_hard_regno_mode_ok (unsigned int regno, machine_mode mode)
     case 1: return true;
     case 2: return (regno % 4) <= 2;
     case 4: return (regno % 4) == 0;
-    default: return (regno % 4) == 0; /* TODO - check why we get VOIDmode.  */
+    default: return (regno % 4) == 0; /* Not sure why VOIDmode is passed.  */
     }
 }
 
@@ -596,6 +596,16 @@ pru_hard_regno_rename_ok (unsigned int old_reg,
   return 1;
 }
 
+
+static void
+pru_init (void)
+{
+  /* Due to difficulties in implementing the TI ABI with GCC,
+     at least check and error-out if GCC cannot compile a
+     complient output.  */
+  pru_register_abicheck_pass ();
+}
+
 /* Allocate a chunk of memory for per-function machine-dependent data.  */
 static struct machine_function *
 pru_init_machine_status (void)
@@ -639,6 +649,9 @@ pru_option_override (void)
      options.  */
   target_option_default_node = target_option_current_node
     = build_target_option_node (&global_options);
+
+  /* This needs to be done at start up.  It's convenient to do it here.  */
+  pru_init ();
 }
 
 /* Compute a (partial) cost for rtx X.  Return true if the complete
@@ -1972,47 +1985,15 @@ pru_function_value_regno_p (const unsigned int regno)
 }
 
 /* Implement TARGET_RETURN_IN_MEMORY.  */
-static bool
+bool
 pru_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
-  return (int_size_in_bytes (type) > (2 * 4 * UNITS_PER_WORD)
-	  || int_size_in_bytes (type) == -1);
-}
-
-#if 0
-/* TODO: It may be possible to eliminate the copyback and implement
-   own va_arg type.  */
-static void
-pru_setup_incoming_varargs (cumulative_args_t cum_v,
-			    machine_mode mode, tree type,
-			    int *pretend_size, int second_time)
-{
-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
-  CUMULATIVE_ARGS local_cum;
-  cumulative_args_t local_cum_v = pack_cumulative_args (&local_cum);
-  int regs_to_push;
-  int pret_size;
+  bool in_memory = (int_size_in_bytes (type) > (2 * 4 * UNITS_PER_WORD)
+		    || int_size_in_bytes (type) == -1);
 
-  local_cum = *cum;
-  pru_function_arg_advance (local_cum_v, mode, type, 1);
-
-  regs_to_push = NUM_ARG_REGS - local_cum.regs_used;
-
-  if (!second_time && regs_to_push > 0)
-    {
-      rtx ptr = virtual_incoming_args_rtx;
-      rtx mem = gen_rtx_MEM (BLKmode, ptr);
-      emit_insn (gen_blockage ());
-      move_block_from_reg (local_cum.regs_used + FIRST_ARG_REGNO, mem,
-			   regs_to_push);
-      emit_insn (gen_blockage ());
-    }
-
-  pret_size = regs_to_push * UNITS_PER_WORD;
-  if (pret_size)
-    *pretend_size = pret_size;
+  return in_memory;
 }
-#endif
+
 
 /* Implement TARGET_CAN_USE_DOLOOP_P.  */
 
@@ -2736,6 +2717,14 @@ pru_set_current_function (tree fndecl)
     }
 }
 
+
+static scalar_int_mode
+pru_unwind_word_mode (void)
+{
+  return SImode;
+}
+
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_FUNCTION_PROLOGUE
 #define TARGET_ASM_FUNCTION_PROLOGUE pru_asm_function_prologue
@@ -2788,9 +2777,6 @@ pru_set_current_function (tree fndecl)
 #undef TARGET_RETURN_IN_MEMORY
 #define TARGET_RETURN_IN_MEMORY pru_return_in_memory
 
-//#undef TARGET_SETUP_INCOMING_VARARGS
-//#define TARGET_SETUP_INCOMING_VARARGS pru_setup_incoming_varargs
-
 #undef TARGET_MUST_PASS_IN_STACK
 #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
 
@@ -2831,6 +2817,9 @@ pru_set_current_function (tree fndecl)
 #undef TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT
 #define TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT hook_bool_void_true
 
+#undef  TARGET_UNWIND_WORD_MODE
+#define TARGET_UNWIND_WORD_MODE pru_unwind_word_mode
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-pru.h"
diff --git a/gcc/config/pru/pru.h b/gcc/config/pru/pru.h
index 0e584db96b2..a8e4204c0ab 100644
--- a/gcc/config/pru/pru.h
+++ b/gcc/config/pru/pru.h
@@ -21,6 +21,8 @@
 #ifndef GCC_PRU_H
 #define GCC_PRU_H
 
+#include "config/pru/pru-opts.h"
+
 /* Define built-in preprocessor macros.  */
 #define TARGET_CPU_CPP_BUILTINS()		    \
   do						    \
@@ -35,14 +37,29 @@
     }						    \
   while (0)
 
-#define DRIVER_SELF_SPECS " %{mmcu=*:-specs=device-specs/%*%s %<mmcu=*} "
+/* TI ABI implementation is not feature enough (e.g. function pointers are
+   not supported), so we cannot list it as a multilib variant.  To prevent
+   misuse from users, do not link any of the standard libraries.  */
+#define DRIVER_SELF_SPECS			      \
+  "%{mabi=ti:-nodefaultlibs} "			      \
+  "%{mmcu=*:-specs=device-specs/%*%s %<mmcu=*} "
+
+#if 0
+  "%{mabi=ti:-nostdlib -nodefaultlibs} "
+#endif
+
+#undef CPP_SPEC
+#define CPP_SPEC					\
+  "%{mabi=ti:-D__PRU_EABI_TI__; :-D__PRU_EABI_GNU__}"
 
+#if 0
 #undef  CC1PLUS_SPEC
 #define CC1PLUS_SPEC                                    \
   "%(cc1) "                                             \
   "%{!frtti:-fno-rtti} "                                \
   "%{!fenforce-eh-specs:-fno-enforce-eh-specs} "        \
   "%{!fexceptions:-fno-exceptions} "
+#endif
 
 #if 0
 /* Leave relaxation to the linker, please. */
@@ -52,18 +69,17 @@
 #endif
 
 #undef  LINK_SPEC
-#define LINK_SPEC				\
-  "%{mno-relax:--no-relax} "			\
+#define LINK_SPEC				      \
+  "%{mno-relax:--no-relax} "			      \
   "%{shared:%eshared is not supported} "
 
+/* CRT0 is carefully maintained to be compatible with both GNU and TI ABIs.  */
 #undef  STARTFILE_SPEC
-#define STARTFILE_SPEC "%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} -lgcc"
+#define STARTFILE_SPEC							\
+  "%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} %{!mabi=ti:-lgcc} "
 
 #undef  ENDFILE_SPEC
-#define ENDFILE_SPEC "-lgloss"
-
-/* No libstdc++ for now.  Empty string doesn't work.  */
-#define LIBSTDCXX "gcc"
+#define ENDFILE_SPEC "%{!mabi=ti:-lgloss} "
 
 /* TI ABI mandates that ELF symbols do not start with any prefix.  */
 #undef USER_LABEL_PREFIX
diff --git a/gcc/config/pru/pru.opt b/gcc/config/pru/pru.opt
index df76ed5c593..97af71a04a1 100644
--- a/gcc/config/pru/pru.opt
+++ b/gcc/config/pru/pru.opt
@@ -18,6 +18,9 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
+HeaderInclude
+config/pru/pru-opts.h
+
 minrt
 Target Report Mask(MINRT) RejectNegative
 Use a minimum runtime (no static initializers or ctors) for memory-constrained devices.
@@ -32,4 +35,18 @@ Prevent relaxation of LDI instructions with hi_rlz modifier.
 
 mloop
 Target Mask(OPT_LOOP)
-Allow gcc to use the LOOP instruction.
+Allow (or do not allow) gcc to use the LOOP instruction.
+
+mabi=
+Target RejectNegative Report Joined Enum(pru_abi_t) Var(pru_current_abi) Init(PRU_ABI_GNU) Save
+Select target ABI variant.
+
+Enum
+Name(pru_abi_t) Type(enum pru_abi)
+ABI variant code generation (for use with -mabi= option):
+
+EnumValue
+Enum(pru_abi_t) String(gnu) Value(PRU_ABI_GNU)
+
+EnumValue
+Enum(pru_abi_t) String(ti) Value(PRU_ABI_TI)
diff --git a/gcc/config/pru/t-pru b/gcc/config/pru/t-pru
index af3eac95c31..3f3094fa126 100644
--- a/gcc/config/pru/t-pru
+++ b/gcc/config/pru/t-pru
@@ -18,8 +18,13 @@
 # License along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-#MULTILIB_OPTIONS    = mmcu=pru
+# Unfortunately mabi=ti is not feature-complete enough to build newlib.
+# MULTILIB_OPTIONS    = mabi=gnu/mabi=ti
 
-pru-pragma.o: $(srcdir)/config/pru/pru-pragma.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H)
+pru-pragma.o: $(srcdir)/config/pru/pru-pragma.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H) \
+		$(srcdir)/config/pru/pru-protos.h
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
 
+pru-passes.o: $(srcdir)/config/pru/pru-passes.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H) \
+		$(srcdir)/config/pru/pru-protos.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 277c99a0527..3a52df59270 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -1029,6 +1029,10 @@ See RS/6000 and PowerPC Options.
 -mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{reg} @gol
 -mstack-protector-guard-offset=@var{offset}}
 
+@emph{PRU Options}
+@gccoptlist{-mmcu=@var{mcu}  -minrt -mno-relax -mloop @gol
+-mabi=@var{variant} @gol}
+
 @emph{RISC-V Options}
 @gccoptlist{-mbranch-cost=@var{N-instruction} @gol
 -mplt  -mno-plt @gol
@@ -14487,6 +14491,7 @@ platform.
 * picoChip Options::
 * PowerPC Options::
 * PowerPC SPE Options::
+* PRU Options::
 * RISC-V Options::
 * RL78 Options::
 * RS/6000 and PowerPC Options::
@@ -22957,6 +22962,57 @@ the offset with a symbol reference to a canary in the TLS block.
 @end table
 
 
+@node PRU Options
+@subsection PRU Options
+@cindex PRU Options
+
+These command-line options are defined for PRU target:
+
+@table @gcctabopt
+@item -minrt
+@opindex minrt
+Enable the use of a minimum runtime environment - no static
+initializers or constructors.  Results in significant code size
+reduction of final ELF binaries.
+
+@item -mmcu=@var{mcu}
+@opindex mmcu
+Specify the PRU MCU variant to use. Check the C library for exact
+list of options.
+
+@item -mno-relax
+@opindex mno-relax
+Pass on (or do not pass on) the @option{-mrelax} command-line option
+to the assembler.
+
+@item -mloop
+@opindex mloop
+Allow (or do not allow) gcc to use the LOOP instruction.
+
+@item -mabi=@var{variant}
+@opindex mabi
+Specify the ABI variant to output code for. Permissible values are @samp{gnu}
+for GCC, and @samp{ti} for fully conformant TI ABI. These are the differences:
+
+@table @samp
+@item Function Pointer Size
+TI ABI specifies that function (code) pointers are 16-bit, whereas GCC
+supports only 32-bit data and code pointers.
+
+@item Optional Return Value Pointer
+Function return values larger than 64-bits are passed by using a hidden
+pointer as the first argument of the function. TI ABI, though, mandates that
+the pointer can be NULL in case the caller is not using the returned value.
+GCC always passes a valid return value pointer.
+
+@end table
+
+The current @samp{mabi=ti} implementation will simply raise a compile error
+when any of the above code constructs is detected.
+
+@end table
+
+
 @node RISC-V Options
 @subsection RISC-V Options
 @cindex RISC-V Options
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-1.c b/gcc/testsuite/gcc.target/pru/mabi-ti-1.c
new file mode 100644
index 00000000000..a4b699e9ff6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-1.c
@@ -0,0 +1,10 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+int test(int a, int b, void (*fp)(void))
+{ /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return a+b;
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-2.c b/gcc/testsuite/gcc.target/pru/mabi-ti-2.c
new file mode 100644
index 00000000000..d6bf7bed29f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-2.c
@@ -0,0 +1,15 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+struct big {
+	char c[9];
+};
+
+struct big test(void)
+{ /* { dg-error "large return values not supported with -mabi=ti option" } */
+  static struct big b;
+  return b;
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-3.c b/gcc/testsuite/gcc.target/pru/mabi-ti-3.c
new file mode 100644
index 00000000000..0789dda82f9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-3.c
@@ -0,0 +1,12 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+extern void extfunc(void (*fp)(void));
+
+void test(void)
+{
+  extfunc(test); /* { dg-error "function pointers not supported with -mabi=ti option" } */
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-4.c b/gcc/testsuite/gcc.target/pru/mabi-ti-4.c
new file mode 100644
index 00000000000..0110e6ce290
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-4.c
@@ -0,0 +1,14 @@
+/* Test TI ABI with supported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+extern void extfunc1(long long);
+extern long long extfunc2(long long);
+
+long long test(void)
+{
+  extfunc1(3);
+  return extfunc2(1);
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-5.c b/gcc/testsuite/gcc.target/pru/mabi-ti-5.c
new file mode 100644
index 00000000000..fa8833fde9c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-5.c
@@ -0,0 +1,33 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+struct s1 {
+    void (*f)(void);
+    int a;
+};
+
+struct s2 {
+    union {
+	void (*f)(void);
+	int a;
+	long b;
+    } u;
+};
+
+int test1(struct s1 *p)
+{
+  return p->a; /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return 1;
+}
+
+int test1_unused_arg(struct s1 p, int a)
+{ /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return a;
+}
+
+int test2(struct s2 v)
+{ /* { dg-error "function pointers not supported with -mabi=ti option" } */
+  return 2;
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-6.c b/gcc/testsuite/gcc.target/pru/mabi-ti-6.c
new file mode 100644
index 00000000000..25ccdbbad82
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-6.c
@@ -0,0 +1,12 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+
+extern void (*extfuncp)(int);
+
+void test(void)
+{
+  extfuncp(1); /* { dg-error "function pointers not supported with -mabi=ti option" } */
+}
diff --git a/gcc/testsuite/gcc.target/pru/mabi-ti-7.c b/gcc/testsuite/gcc.target/pru/mabi-ti-7.c
new file mode 100644
index 00000000000..eff016a2524
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/mabi-ti-7.c
@@ -0,0 +1,21 @@
+/* Test TI ABI unsupported constructs */
+
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mabi=ti" } */
+
+struct s1 {
+    int (*f)(void);
+    int a;
+};
+
+extern struct s1 s;
+
+int test1(void)
+{
+  return s.f(); /* { dg-error "function pointers not supported with -mabi=ti option" } */
+}
+
+int test2(void)
+{
+  return s.a; /* { dg-error "function pointers not supported with -mabi=ti option" } */
+}
-- 
2.11.0


From ebb6a219d51b457c8e20957fd6c6e0a3dabe0d3c Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dinuxbg@gmail.com>
Date: Sun, 23 Feb 2014 22:25:35 +0200
Subject: [PATCH 1/2] Initial TI PRU binutils port

Although not very well tested, core functionality should be there.

Signed-off-by: Dimitar Dimitrov <dinuxbg@gmail.com>
---
 .gitignore                      |    2 +
 bfd/Makefile.am                 |    4 +
 bfd/Makefile.in                 |    6 +
 bfd/archures.c                  |    4 +
 bfd/bfd-in2.h                   |   13 +
 bfd/config.bfd                  |    5 +
 bfd/configure                   |    1 +
 bfd/configure.in                |    1 +
 bfd/cpu-pru.c                   |   43 ++
 bfd/elf-bfd.h                   |    1 +
 bfd/elf32-pru.c                 |  903 ++++++++++++++++++++++
 bfd/libbfd.h                    |    9 +
 bfd/po/SRC-POTFILES.in          |    2 +
 bfd/reloc.c                     |   21 +
 bfd/targets.c                   |    3 +
 binutils/readelf.c              |   11 +
 config.sub                      |    2 +
 elfcpp/elfcpp.h                 |    3 +-
 gas/Makefile.am                 |    2 +
 gas/Makefile.in                 |   17 +
 gas/config/obj-elf.c            |    4 +
 gas/config/tc-pru.c             | 1605 +++++++++++++++++++++++++++++++++++++++
 gas/config/tc-pru.h             |   91 +++
 gas/configure.tgt               |    2 +
 gas/po/POTFILES.in              |    2 +
 gas/testsuite/gas/pru/alu.d     |   32 +
 gas/testsuite/gas/pru/alu.s     |   30 +
 gas/testsuite/gas/pru/branch.d  |   35 +
 gas/testsuite/gas/pru/branch.s  |   42 +
 gas/testsuite/gas/pru/illegal.l |    5 +
 gas/testsuite/gas/pru/illegal.s |   11 +
 gas/testsuite/gas/pru/ldst.d    |   33 +
 gas/testsuite/gas/pru/ldst.s    |   37 +
 gas/testsuite/gas/pru/misc.d    |   12 +
 gas/testsuite/gas/pru/misc.s    |    6 +
 gas/testsuite/gas/pru/pru.exp   |   25 +
 gas/testsuite/gas/pru/pseudo.d  |   10 +
 gas/testsuite/gas/pru/pseudo.s  |    5 +
 gas/testsuite/gas/pru/xfr.d     |   44 ++
 gas/testsuite/gas/pru/xfr.s     |   52 ++
 include/dis-asm.h               |    1 +
 include/elf/common.h            |    3 +
 include/elf/pru.h               |   54 ++
 include/opcode/pru.h            |  379 +++++++++
 ld/Makefile.am                  |    5 +
 ld/Makefile.in                  |    5 +
 ld/configure.tgt                |    1 +
 ld/emulparams/pruelf.sh         |   18 +
 ld/scripttempl/pru.sc           |  194 +++++
 opcodes/Makefile.am             |    2 +
 opcodes/Makefile.in             |    4 +
 opcodes/configure               |    1 +
 opcodes/configure.in            |    1 +
 opcodes/disassemble.c           |    6 +
 opcodes/pru-dis.c               |  265 +++++++
 opcodes/pru-opc.c               |  217 ++++++
 readline/support/config.sub     |    2 +
 57 files changed, 4293 insertions(+), 1 deletion(-)
 create mode 100644 bfd/cpu-pru.c
 create mode 100644 bfd/elf32-pru.c
 create mode 100644 gas/config/tc-pru.c
 create mode 100644 gas/config/tc-pru.h
 create mode 100644 gas/testsuite/gas/pru/alu.d
 create mode 100644 gas/testsuite/gas/pru/alu.s
 create mode 100644 gas/testsuite/gas/pru/branch.d
 create mode 100644 gas/testsuite/gas/pru/branch.s
 create mode 100644 gas/testsuite/gas/pru/illegal.l
 create mode 100644 gas/testsuite/gas/pru/illegal.s
 create mode 100644 gas/testsuite/gas/pru/ldst.d
 create mode 100644 gas/testsuite/gas/pru/ldst.s
 create mode 100644 gas/testsuite/gas/pru/misc.d
 create mode 100644 gas/testsuite/gas/pru/misc.s
 create mode 100644 gas/testsuite/gas/pru/pru.exp
 create mode 100644 gas/testsuite/gas/pru/pseudo.d
 create mode 100644 gas/testsuite/gas/pru/pseudo.s
 create mode 100644 gas/testsuite/gas/pru/xfr.d
 create mode 100644 gas/testsuite/gas/pru/xfr.s
 create mode 100644 include/elf/pru.h
 create mode 100644 include/opcode/pru.h
 create mode 100644 ld/emulparams/pruelf.sh
 create mode 100644 ld/scripttempl/pru.sc
 create mode 100644 opcodes/pru-dis.c
 create mode 100644 opcodes/pru-opc.c

diff --git a/.gitignore b/.gitignore
index bda55a3..1104322 100644
--- a/.gitignore
+++ b/.gitignore
@@ -40,3 +40,5 @@ core
 !core/
 
 lost+found
+*.swp
+cscope.*
diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 595c489..c86563b 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -144,6 +144,7 @@ ALL_MACHINES = \
 	cpu-pj.lo \
 	cpu-plugin.lo \
 	cpu-powerpc.lo \
+	cpu-pru.lo \
 	cpu-rs6000.lo \
 	cpu-rl78.lo \
 	cpu-rx.lo \
@@ -228,6 +229,7 @@ ALL_MACHINES_CFILES = \
 	cpu-pj.c \
 	cpu-plugin.c \
 	cpu-powerpc.c \
+	cpu-pru.c \
 	cpu-rs6000.c \
 	cpu-rl78.c \
 	cpu-rx.c \
@@ -353,6 +355,7 @@ BFD32_BACKENDS = \
 	elf32-or1k.lo \
 	elf32-pj.lo \
 	elf32-ppc.lo \
+	elf32-pru.lo \
 	elf32-rl78.lo \
 	elf32-rx.lo \
 	elf32-s390.lo \
@@ -540,6 +543,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-or1k.c \
 	elf32-pj.c \
 	elf32-ppc.c \
+	elf32-pru.c \
 	elf32-rl78.c \
 	elf32-rx.c \
 	elf32-s390.c \
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 2ea8516..e066e71 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -445,6 +445,7 @@ ALL_MACHINES = \
 	cpu-pj.lo \
 	cpu-plugin.lo \
 	cpu-powerpc.lo \
+	cpu-pru.lo \
 	cpu-rs6000.lo \
 	cpu-rl78.lo \
 	cpu-rx.lo \
@@ -529,6 +530,7 @@ ALL_MACHINES_CFILES = \
 	cpu-pj.c \
 	cpu-plugin.c \
 	cpu-powerpc.c \
+	cpu-pru.c \
 	cpu-rs6000.c \
 	cpu-rl78.c \
 	cpu-rx.c \
@@ -655,6 +657,7 @@ BFD32_BACKENDS = \
 	elf32-or1k.lo \
 	elf32-pj.lo \
 	elf32-ppc.lo \
+	elf32-pru.lo \
 	elf32-rl78.lo \
 	elf32-rx.lo \
 	elf32-s390.lo \
@@ -842,6 +845,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-or1k.c \
 	elf32-pj.c \
 	elf32-ppc.c \
+	elf32-pru.c \
 	elf32-rl78.c \
 	elf32-rx.c \
 	elf32-s390.c \
@@ -1358,6 +1362,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-pj.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-plugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-powerpc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-pru.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-rl78.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-rs6000.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-rx.Plo@am__quote@
@@ -1445,6 +1450,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-or1k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-pj.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-ppc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-pru.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-rl78.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-rx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-s390.Plo@am__quote@
diff --git a/bfd/archures.c b/bfd/archures.c
index 9b47504..039e498 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -493,6 +493,8 @@ DESCRIPTION
 .#define bfd_mach_aarch64_ilp32	32
 .  bfd_arch_nios2,
 .#define bfd_mach_nios2	0
+.  bfd_arch_pru,
+.#define bfd_mach_pru	0
 .  bfd_arch_last
 .  };
 */
@@ -594,6 +596,7 @@ extern const bfd_arch_info_type bfd_pj_arch;
 extern const bfd_arch_info_type bfd_plugin_arch;
 extern const bfd_arch_info_type bfd_powerpc_archs[];
 #define bfd_powerpc_arch bfd_powerpc_archs[0]
+extern const bfd_arch_info_type bfd_pru_arch;
 extern const bfd_arch_info_type bfd_rs6000_arch;
 extern const bfd_arch_info_type bfd_rl78_arch;
 extern const bfd_arch_info_type bfd_rx_arch;
@@ -680,6 +683,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_or1k_arch,
     &bfd_pdp11_arch,
     &bfd_powerpc_arch,
+    &bfd_pru_arch,
     &bfd_rs6000_arch,
     &bfd_rl78_arch,
     &bfd_rx_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index d9056ce..7e3a436 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -2278,6 +2278,8 @@ enum bfd_architecture
 #define bfd_mach_aarch64_ilp32 32
   bfd_arch_nios2,
 #define bfd_mach_nios2 0
+  bfd_arch_pru,
+#define bfd_mach_pru   0
   bfd_arch_last
   };
 
@@ -5276,6 +5278,17 @@ a matching LO8XG part.  */
   BFD_RELOC_NIOS2_CALL_LO,
   BFD_RELOC_NIOS2_CALL_HA,
 
+/* Relocations used by the TI PRU processor.  */
+  BFD_RELOC_PRU_U8,
+  BFD_RELOC_PRU_U16,
+  BFD_RELOC_PRU_IMM5,
+  BFD_RELOC_PRU_HI16,
+  BFD_RELOC_PRU_LO16,
+  BFD_RELOC_PRU_U16_PMEMIMM,
+  BFD_RELOC_PRU_S10_PCREL,
+  BFD_RELOC_PRU_32_PMEM,
+  BFD_RELOC_PRU_16_PMEM,
+
 /* IQ2000 Relocations.  */
   BFD_RELOC_IQ2000_OFFSET_16,
   BFD_RELOC_IQ2000_OFFSET_21,
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 1f822f2..628bc3a 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -120,6 +120,7 @@ or1k*|or1knd*)	 targ_archs=bfd_or1k_arch ;;
 pdp11*)		 targ_archs=bfd_pdp11_arch ;;
 pj*)		 targ_archs="bfd_pj_arch bfd_i386_arch";;
 powerpc*)	 targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
+pru*)            targ_archs=bfd_pru_arch ;;
 rs6000)		 targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
 s390*)		 targ_archs=bfd_s390_arch ;;
 sh*)		 targ_archs=bfd_sh_arch ;;
@@ -1312,6 +1313,10 @@ case "${targ}" in
     targ_selvecs="powerpc_pei_le_vec powerpc_pei_vec powerpc_pe_le_vec powerpc_pe_vec"
     ;;
 
+  pru-*-*)
+    targ_defvec=pru_elf32_vec
+    ;;
+
   rl78-*-elf)
     targ_defvec=rl78_elf32_vec
     ;;
diff --git a/bfd/configure b/bfd/configure
index f3df01c..7067546 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -15436,6 +15436,7 @@ do
     powerpc_pei_vec)		 tb="$tb pei-ppc.lo peigen.lo cofflink.lo" ;;
     powerpc_pei_le_vec)		 tb="$tb pei-ppc.lo peigen.lo cofflink.lo" ;;
     powerpc_xcoff_vec)		 tb="$tb coff-rs6000.lo xcofflink.lo" ;;
+    pru_elf32_vec)		 tb="$tb elf32-pru.lo elf32.lo $elf" ;;
     rl78_elf32_vec)		 tb="$tb elf32-rl78.lo elf32.lo $elf" ;;
     rs6000_xcoff64_vec)		 tb="$tb coff64-rs6000.lo xcofflink.lo aix5ppc-core.lo"; target_size=64 ;;
     rs6000_xcoff64_aix_vec)	 tb="$tb coff64-rs6000.lo xcofflink.lo aix5ppc-core.lo"; target_size=64 ;;
diff --git a/bfd/configure.in b/bfd/configure.in
index 2cc4499..0bf37fb 100644
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -912,6 +912,7 @@ do
     powerpc_pei_vec)		 tb="$tb pei-ppc.lo peigen.lo cofflink.lo" ;;
     powerpc_pei_le_vec)		 tb="$tb pei-ppc.lo peigen.lo cofflink.lo" ;;
     powerpc_xcoff_vec)		 tb="$tb coff-rs6000.lo xcofflink.lo" ;;
+    pru_elf32_vec)         	 tb="$tb elf32-pru.lo elf32.lo $elf" ;;
     rl78_elf32_vec)		 tb="$tb elf32-rl78.lo elf32.lo $elf" ;;
     rs6000_xcoff64_vec)		 tb="$tb coff64-rs6000.lo xcofflink.lo aix5ppc-core.lo"; target_size=64 ;;
     rs6000_xcoff64_aix_vec)	 tb="$tb coff64-rs6000.lo xcofflink.lo aix5ppc-core.lo"; target_size=64 ;;
diff --git a/bfd/cpu-pru.c b/bfd/cpu-pru.c
new file mode 100644
index 0000000..9a558c3
--- /dev/null
+++ b/bfd/cpu-pru.c
@@ -0,0 +1,43 @@
+/* BFD support for the TI PRU microprocessor.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+#define N(BITS_WORD, BITS_ADDR, NUMBER, PRINT, DEFAULT, NEXT)		\
+  {							\
+    BITS_WORD, /*  bits in a word */			\
+    BITS_ADDR, /* bits in an address */			\
+    8,	/* 8 bits in a byte */				\
+    bfd_arch_pru,					\
+    NUMBER,						\
+    "pru",						\
+    PRINT,						\
+    3,							\
+    DEFAULT,						\
+    bfd_default_compatible,				\
+    bfd_default_scan,					\
+    bfd_arch_default_fill,			       	\
+    NEXT						\
+  }
+
+const bfd_arch_info_type bfd_pru_arch = N (32, 32, 0, "pru", TRUE, NULL);
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index a06c54b..c2d20e8 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -424,6 +424,7 @@ enum elf_target_id
   OR1K_ELF_DATA,
   PPC32_ELF_DATA,
   PPC64_ELF_DATA,
+  PRU_ELF_DATA,
   S390_ELF_DATA,
   SH_ELF_DATA,
   SPARC_ELF_DATA,
diff --git a/bfd/elf32-pru.c b/bfd/elf32-pru.c
new file mode 100644
index 0000000..bd7b128
--- /dev/null
+++ b/bfd/elf32-pru.c
@@ -0,0 +1,903 @@
+/* 32-bit ELF support for TI PRU.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+   Based on elf32-nios2.c
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* This file handles TI PRU ELF targets.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "bfdlink.h"
+#include "genlink.h"
+#include "elf-bfd.h"
+#include "elf/pru.h"
+#include "opcode/pru.h"
+
+/* Use RELA relocations.  */
+#ifndef USE_RELA
+#define USE_RELA
+#endif
+
+#ifdef USE_REL
+#undef USE_REL
+#endif
+
+/* Forward declarations.  */
+static bfd_reloc_status_type pru_elf32_hi16_relocate
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type pru_elf32_lo16_relocate
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type pru_elf32_pmem_relocate
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type pru_elf32_s10_pcrel_relocate
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+
+/* Target vector.  */
+extern const bfd_target pru_elf32_vec;
+
+/* The relocation table used for SHT_REL sections.  */
+static reloc_howto_type elf_pru_howto_table_rel[] = {
+  /* No relocation.  */
+  HOWTO (R_PRU_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_PRU_NONE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 8-bit unsigned immediate relocation.  */
+  HOWTO (R_PRU_U8,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 16,			/* bitpos */
+	 complain_overflow_unsigned,	/* complain on overflow */
+	 bfd_elf_generic_reloc,	/* special function */
+	 "R_PRU_U8",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ff0000,		/* src_mask */
+	 0x00ff0000,		/* dest_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 16-bit unsigned immediate relocation.  */
+  HOWTO (R_PRU_U16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 8,			/* bitpos */
+	 complain_overflow_unsigned,	/* complain on overflow */
+	 bfd_elf_generic_reloc,	/* special function */
+	 "R_PRU_U16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ffff00,		/* src_mask */
+	 0x00ffff00,		/* dest_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_PRU_IMM5,
+	 0,
+	 2,
+	 5,
+	 FALSE,
+	 16,
+	 complain_overflow_bitfield,
+	 bfd_elf_generic_reloc,
+	 "R_PRU_IMM5",
+	 FALSE,
+	 0x00ff0000,
+	 0x00ff0000,
+	 FALSE),
+
+  HOWTO (R_PRU_HI16,
+	 0,
+	 2,
+	 32,
+	 FALSE,
+	 8,
+	 complain_overflow_dont,
+	 pru_elf32_hi16_relocate,
+	 "R_PRU_HI16",
+	 FALSE,
+	 0x00ffff00,
+	 0x00ffff00,
+	 FALSE),
+
+  HOWTO (R_PRU_LO16,
+	 0,
+	 2,
+	 32,
+	 FALSE,
+	 8,
+	 complain_overflow_dont,
+	 pru_elf32_lo16_relocate,
+	 "R_PRU_LO16",
+	 FALSE,
+	 0x00ffff00,
+	 0x00ffff00,
+	 FALSE),
+
+  HOWTO (R_PRU_U16_PMEMIMM,
+	 2,
+	 2,
+	 32,
+	 FALSE,
+	 8,
+	 complain_overflow_unsigned,
+	 pru_elf32_pmem_relocate,
+	 "R_PRU_U16_PMEMIMM",
+	 FALSE,
+	 0x00ffff00,
+	 0x00ffff00,
+	 FALSE),
+
+  HOWTO (R_PRU_S10_PCREL,
+	 2,
+	 2,
+	 10,
+	 TRUE,
+	 0,
+	 complain_overflow_bitfield,
+	 pru_elf32_s10_pcrel_relocate,
+	 "R_PRU_S10_PCREL",
+	 FALSE,
+	 0x060000ff,
+	 0x060000ff,
+	 TRUE),
+
+  HOWTO (R_PRU_32_PMEM,
+	 2,
+	 2,			/* long */
+	 32,
+	 FALSE,
+	 0,
+	 complain_overflow_dont,
+	 pru_elf32_pmem_relocate,
+	 "R_PRU_32_PMEM",
+	 FALSE,
+	 0xffffffff,
+	 0xffffffff,
+	 FALSE),
+
+  HOWTO (R_PRU_16_PMEM,
+	 2,
+	 1,			/* short */
+	 32,
+	 FALSE,
+	 0,
+	 complain_overflow_dont,
+	 bfd_elf_generic_reloc,
+	 "R_PRU_16_PMEM",
+	 FALSE,
+	 0xffff,
+	 0xffff,
+	 FALSE),
+
+  HOWTO (R_PRU_BFD_RELOC_32,
+	 0,
+	 2,			/* long */
+	 32,
+	 FALSE,
+	 0,
+	 complain_overflow_dont,
+	 bfd_elf_generic_reloc,
+	 "R_PRU_BFD_RELOC32",
+	 FALSE,
+	 0xffffffff,
+	 0xffffffff,
+	 FALSE),
+
+  HOWTO (R_PRU_BFD_RELOC_16,
+	 0,
+	 1,			/* short */
+	 16,
+	 FALSE,
+	 0,
+	 complain_overflow_bitfield,
+	 bfd_elf_generic_reloc,
+	 "R_PRU_BFD_RELOC16",
+	 FALSE,
+	 0x0000ffff,
+	 0x0000ffff,
+	 FALSE),
+
+  HOWTO (R_PRU_BFD_RELOC_8,
+	 0,
+	 0,			/* byte */
+	 8,
+	 FALSE,
+	 0,
+	 complain_overflow_bitfield,
+	 bfd_elf_generic_reloc,
+	 "R_PRU_BFD_RELOC8",
+	 FALSE,
+	 0x000000ff,
+	 0x000000ff,
+	 FALSE),
+
+/* Add other relocations here.  */
+};
+
+static unsigned char elf_code_to_howto_index[R_PRU_ILLEGAL + 1];
+
+/* Return the howto for relocation RTYPE.  */
+static reloc_howto_type *
+lookup_howto (unsigned int rtype)
+{
+  static int initialized = 0;
+  int i;
+  int howto_tbl_size = (int) (sizeof (elf_pru_howto_table_rel)
+			      / sizeof (elf_pru_howto_table_rel[0]));
+
+  if (!initialized)
+    {
+      initialized = 1;
+      memset (elf_code_to_howto_index, 0xff,
+	      sizeof (elf_code_to_howto_index));
+      for (i = 0; i < howto_tbl_size; i++)
+	elf_code_to_howto_index[elf_pru_howto_table_rel[i].type] = i;
+    }
+
+  BFD_ASSERT (rtype <= R_PRU_ILLEGAL);
+  i = elf_code_to_howto_index[rtype];
+  if (i >= howto_tbl_size)
+    return 0;
+  return elf_pru_howto_table_rel + i;
+}
+
+/* Map for converting BFD reloc types to PRU reloc types.  */
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_pru_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map pru_reloc_map[] = {
+  {BFD_RELOC_PRU_U8, R_PRU_U8},
+  {BFD_RELOC_PRU_U16, R_PRU_U16},
+  {BFD_RELOC_PRU_IMM5, R_PRU_IMM5},
+  {BFD_RELOC_PRU_HI16, R_PRU_HI16},
+  {BFD_RELOC_PRU_LO16, R_PRU_LO16},
+  {BFD_RELOC_PRU_U16_PMEMIMM, R_PRU_U16_PMEMIMM},
+  {BFD_RELOC_PRU_S10_PCREL, R_PRU_S10_PCREL},
+  {BFD_RELOC_PRU_32_PMEM, R_PRU_32_PMEM},
+  {BFD_RELOC_PRU_16_PMEM, R_PRU_16_PMEM},
+  {BFD_RELOC_32, R_PRU_BFD_RELOC_32},
+  {BFD_RELOC_16, R_PRU_BFD_RELOC_16},
+  {BFD_RELOC_8, R_PRU_BFD_RELOC_8},
+};
+
+/* PRU ELF linker hash entry.  */
+
+struct elf32_pru_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+};
+
+#define elf32_pru_hash_entry(ent) \
+  ((struct elf32_pru_link_hash_entry *) (ent))
+
+/* Get the PRU elf linker hash table from a link_info structure.  */
+#define elf32_pru_hash_table(info) \
+  ((struct elf32_pru_link_hash_table *) ((info)->hash))
+
+/* PRU ELF linker hash table.  */
+struct elf32_pru_link_hash_table
+  {
+    /* The main hash table.  */
+    struct elf_link_hash_table root;
+  };
+
+
+/* Assorted hash table functions.  */
+
+/* Create an entry in a PRU ELF linker hash table.  */
+static struct bfd_hash_entry *
+link_hash_newfunc (struct bfd_hash_entry *entry,
+		   struct bfd_hash_table *table, const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+				 sizeof (struct elf32_pru_link_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
+
+  return entry;
+}
+
+/* Implement bfd_elf32_bfd_reloc_type_lookup:
+   Given a BFD reloc type, return a howto structure.  */
+static reloc_howto_type *
+pru_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				   bfd_reloc_code_real_type code)
+{
+  int i;
+  for (i = 0;
+       i < (int) (sizeof (pru_reloc_map) / sizeof (struct elf_reloc_map));
+       ++i)
+    if (pru_reloc_map[i].bfd_val == code)
+      return &elf_pru_howto_table_rel[(int) pru_reloc_map[i].elf_val];
+  return NULL;
+}
+
+/* Implement bfd_elf32_bfd_reloc_name_lookup:
+   Given a reloc name, return a howto structure.  */
+static reloc_howto_type *
+pru_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				   const char *r_name)
+{
+  unsigned int i;
+  for (i = 0;
+       i < (sizeof (elf_pru_howto_table_rel)
+	    / sizeof (elf_pru_howto_table_rel[0]));
+       i++)
+    if (elf_pru_howto_table_rel[i].name
+	&& strcasecmp (elf_pru_howto_table_rel[i].name, r_name) == 0)
+      return &elf_pru_howto_table_rel[i];
+
+  return NULL;
+}
+
+/* Implement elf_info_to_howto:
+   Given a ELF32 relocation, fill in a arelent structure.  */
+static void
+pru_elf32_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
+			   Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < R_PRU_ILLEGAL);
+  cache_ptr->howto = &elf_pru_howto_table_rel[r_type];
+}
+
+/* Do the relocations that require special handling.  */
+static bfd_reloc_status_type
+pru_elf32_do_hi16_relocate (bfd *abfd, reloc_howto_type *howto,
+			      asection *input_section,
+			      bfd_byte *data, bfd_vma offset,
+			      bfd_vma symbol_value, bfd_vma addend)
+{
+  symbol_value = symbol_value + addend;
+  addend = 0;
+  symbol_value = (symbol_value >> 16) & 0xffff;
+  return _bfd_final_link_relocate (howto, abfd, input_section,
+				   data, offset, symbol_value, addend);
+}
+
+static bfd_reloc_status_type
+pru_elf32_do_lo16_relocate (bfd *abfd, reloc_howto_type *howto,
+			      asection *input_section,
+			      bfd_byte *data, bfd_vma offset,
+			      bfd_vma symbol_value, bfd_vma addend)
+{
+  symbol_value = symbol_value + addend;
+  addend = 0;
+  symbol_value = symbol_value & 0xffff;
+  return _bfd_final_link_relocate (howto, abfd, input_section,
+				   data, offset, symbol_value, addend);
+}
+
+/* Produce a word address for program memory. Linker scripts will put .text
+   at a high offset in order to differentiate it from .data. So here we also
+   mask the high bits of PMEM address.
+
+   But why 1MB when internal Program Memory much smaller? We want to catch
+   unintended overflows.
+
+   Why not use (1<<31) as an offset and a mask? Sitara DDRAM usually resides
+   there, and users might want to put some shared carveout memory region in
+   their linker scripts. So 0x80000000 might be a valid .data address.
+
+   Note that we still keep and pass down the original howto. This way we
+   can reuse this function for several different relocations. */
+static bfd_reloc_status_type
+pru_elf32_do_pmem_relocate (bfd *abfd, reloc_howto_type *howto,
+			      asection *input_section,
+			      bfd_byte *data, bfd_vma offset,
+			      bfd_vma symbol_value, bfd_vma addend)
+{
+  symbol_value = symbol_value + addend;
+  addend = 0;
+  symbol_value &= 0x3fffff;
+  return _bfd_final_link_relocate (howto, abfd, input_section,
+				   data, offset, symbol_value, addend);
+}
+
+/* Direct copy of _bfd_final_link_relocate, but with special
+   "fill-in". This copy-paste mumbo jumbo is only needed because BFD
+   cannot deal coorectly with non-contiguous bit fields. */
+static bfd_reloc_status_type
+pru_elf32_do_s10_pcrel_relocate (bfd *input_bfd, reloc_howto_type *howto,
+				    asection *input_section,
+				    bfd_byte *contents, bfd_vma address,
+				    bfd_vma relocation, bfd_vma addend)
+{
+  bfd_byte *location;
+  bfd_vma x = 0;
+  bfd_vma qboff;
+  bfd_reloc_status_type flag = bfd_reloc_ok;
+
+  /* Sanity check the address.  */
+  if (address > bfd_get_section_limit (input_bfd, input_section))
+    return bfd_reloc_outofrange;
+
+  BFD_ASSERT (howto->pc_relative);
+  BFD_ASSERT (howto->pcrel_offset);
+
+  relocation = relocation + addend - (input_section->output_section->vma
+		+ input_section->output_offset) - address;
+
+  location = contents + address;
+
+  /* Get the value we are going to relocate.  */
+  BFD_ASSERT (bfd_get_reloc_size (howto) == 4);
+  x = bfd_get_32 (input_bfd, location);
+
+  qboff = GET_BROFF_SIGNED (x) << howto->rightshift;
+  relocation += qboff;
+
+  BFD_ASSERT (howto->complain_on_overflow == complain_overflow_bitfield);
+
+  if (relocation > 2047 && relocation < (bfd_vma)-2048l)
+    flag = bfd_reloc_overflow;
+
+  /* Check that target address is word-aligned. */
+  if (relocation & ((1 << howto->rightshift) - 1))
+    flag = bfd_reloc_outofrange;
+
+  relocation >>= (bfd_vma) howto->rightshift;
+
+  /* Fill-in the RELOCATION to the right bits of X.  */
+  SET_BROFF_URAW (x, relocation);
+
+  bfd_put_32 (input_bfd, x, location);
+
+  return flag;
+}
+
+/* HOWTO handlers for relocations that require special handling.  */
+
+static bfd_reloc_status_type
+pru_elf32_hi16_relocate (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			   void *data, asection *input_section,
+			   bfd *output_bfd,
+			   char **error_message ATTRIBUTE_UNUSED)
+{
+  /* This part is from bfd_elf_generic_reloc.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != NULL)
+    /* FIXME: See bfd_perform_relocation.  Is this right?  */
+    return bfd_reloc_continue;
+
+  return pru_elf32_do_hi16_relocate (abfd, reloc_entry->howto,
+				       input_section,
+				       data, reloc_entry->address,
+				       (symbol->value
+					+ symbol->section->output_section->vma
+					+ symbol->section->output_offset),
+				       reloc_entry->addend);
+}
+
+static bfd_reloc_status_type
+pru_elf32_lo16_relocate (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
+			   void *data, asection *input_section,
+			   bfd *output_bfd,
+			   char **error_message ATTRIBUTE_UNUSED)
+{
+  /* This part is from bfd_elf_generic_reloc.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != NULL)
+    /* FIXME: See bfd_perform_relocation.  Is this right?  */
+    return bfd_reloc_continue;
+
+  return pru_elf32_do_lo16_relocate (abfd, reloc_entry->howto,
+				       input_section,
+				       data, reloc_entry->address,
+				       (symbol->value
+					+ symbol->section->output_section->vma
+					+ symbol->section->output_offset),
+				       reloc_entry->addend);
+}
+
+static bfd_reloc_status_type
+pru_elf32_pmem_relocate (bfd *abfd, arelent *reloc_entry,
+			    asymbol *symbol, void *data,
+			    asection *input_section, bfd *output_bfd,
+			   char **error_message ATTRIBUTE_UNUSED)
+{
+  /* This part is from bfd_elf_generic_reloc.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != NULL)
+    /* FIXME: See bfd_perform_relocation.  Is this right?  */
+    return bfd_reloc_continue;
+
+  return pru_elf32_do_pmem_relocate (abfd, reloc_entry->howto,
+				       input_section,
+				       data, reloc_entry->address,
+				       (symbol->value
+					+ symbol->section->output_section->vma
+					+ symbol->section->output_offset),
+				       reloc_entry->addend);
+}
+
+static bfd_reloc_status_type
+pru_elf32_s10_pcrel_relocate (bfd *abfd, arelent *reloc_entry,
+				 asymbol *symbol, void *data,
+				 asection *input_section, bfd *output_bfd,
+				 char **error_message ATTRIBUTE_UNUSED)
+{
+  /* This part is from bfd_elf_generic_reloc.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  if (output_bfd != NULL)
+    /* FIXME: See bfd_perform_relocation.  Is this right?  */
+    return bfd_reloc_continue;
+
+  return pru_elf32_do_s10_pcrel_relocate (
+    abfd, reloc_entry->howto, input_section, data, reloc_entry->address,
+    (symbol->value + symbol->section->output_section->vma
+     + symbol->section->output_offset),
+    reloc_entry->addend);
+}
+
+/* Implement elf_backend_relocate_section.  */
+static bfd_boolean
+pru_elf32_relocate_section (bfd *output_bfd,
+			      struct bfd_link_info *info,
+			      bfd *input_bfd,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      Elf_Internal_Rela *relocs,
+			      Elf_Internal_Sym *local_syms,
+			      asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+  relend = relocs + input_section->reloc_count;
+
+  for (rel = relocs; rel < relend; rel++)
+    {
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_reloc_status_type r = bfd_reloc_ok;
+      const char *name = NULL;
+      const char* msg = (const char*) NULL;
+      bfd_boolean unresolved_reloc;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      howto = lookup_howto ((unsigned) ELF32_R_TYPE (rel->r_info));
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+	}
+      else
+	{
+	  bfd_boolean warned, ignored;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned, ignored);
+	}
+
+      if (sec && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      /* Nothing more to do unless this is a final link.  */
+      if (info->relocatable)
+	continue;
+
+      if (howto)
+	{
+	  switch (howto->type)
+	    {
+	    case R_PRU_HI16:
+	      r = pru_elf32_do_hi16_relocate (input_bfd, howto,
+						input_section,
+						contents, rel->r_offset,
+						relocation, rel->r_addend);
+	      break;
+	    case R_PRU_LO16:
+	      r = pru_elf32_do_lo16_relocate (input_bfd, howto,
+						input_section,
+						contents, rel->r_offset,
+						relocation, rel->r_addend);
+	      break;
+	    case R_PRU_U16_PMEMIMM:
+	    case R_PRU_32_PMEM:
+	    case R_PRU_16_PMEM:
+	      r = pru_elf32_do_pmem_relocate (input_bfd, howto,
+						input_section,
+						contents, rel->r_offset,
+						relocation, rel->r_addend);
+	      break;
+	    case R_PRU_S10_PCREL:
+	      r = pru_elf32_do_s10_pcrel_relocate (input_bfd, howto,
+						      input_section,
+						      contents,
+						      rel->r_offset,
+						      relocation,
+						      rel->r_addend);
+	      break;
+	    default:
+	      r = _bfd_final_link_relocate (howto, input_bfd,
+					    input_section, contents,
+					    rel->r_offset, relocation,
+					    rel->r_addend);
+	      break;
+	    }
+	}
+      else
+	r = bfd_reloc_notsupported;
+
+      if (r != bfd_reloc_ok)
+	{
+	  if (h != NULL)
+	    name = h->root.root.string;
+	  else
+	    {
+	      name = bfd_elf_string_from_elf_section (input_bfd,
+						      symtab_hdr->sh_link,
+						      sym->st_name);
+	      if (name == NULL || *name == '\0')
+		name = bfd_section_name (input_bfd, sec);
+	    }
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      r = info->callbacks->reloc_overflow (info, NULL, name,
+						   howto->name, (bfd_vma) 0,
+						   input_bfd, input_section,
+						   rel->r_offset);
+	      break;
+
+	    case bfd_reloc_undefined:
+	      r = info->callbacks->undefined_symbol (info, name, input_bfd,
+						     input_section,
+						     rel->r_offset, TRUE);
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      if (msg == NULL)
+		msg = _("relocation out of range");
+	      break;
+
+	    case bfd_reloc_notsupported:
+	      if (msg == NULL)
+		msg = _("unsupported relocation");
+	      break;
+
+	    case bfd_reloc_dangerous:
+	      if (msg == NULL)
+		msg = _("dangerous relocation");
+	      break;
+
+	    default:
+	      if (msg == NULL)
+		msg = _("unknown error");
+	      break;
+	    }
+
+	  if (msg)
+	    {
+	      r = info->callbacks->warning
+		(info, msg, name, input_bfd, input_section, rel->r_offset);
+	      return FALSE;
+	    }
+	}
+    }
+  return TRUE;
+}
+
+/* Implement elf_backend_check_relocs:
+   Look through the relocs for a section during the first phase.  */
+static bfd_boolean
+pru_elf32_check_relocs (bfd *abfd, struct bfd_link_info *info,
+			  asection *sec, const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+
+  if (info->relocatable)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  sym_hashes_end = (sym_hashes
+		    + symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
+  if (!elf_bad_symtab (abfd))
+    sym_hashes_end -= symtab_hdr->sh_info;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned int r_type;
+      struct elf_link_hash_entry *h;
+      unsigned long r_symndx;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  /* PR15323, ref flags aren't set for references in the same
+	     object.  */
+	  h->root.non_ir_ref = 1;
+	}
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+
+      switch (r_type)
+	{
+
+#if 0
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_PRU_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_PRU_GNU_VTENTRY:
+	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+	    return FALSE;
+	  break;
+#endif
+	}
+    }
+
+  return TRUE;
+}
+
+
+/* Free the derived linker hash table.  */
+static void
+pru_elf32_link_hash_table_free (bfd *obfd)
+{
+  _bfd_elf_link_hash_table_free (obfd);
+}
+
+/* Implement bfd_elf32_bfd_link_hash_table_create.  */
+static struct bfd_link_hash_table *
+pru_elf32_link_hash_table_create (bfd *abfd)
+{
+  struct elf32_pru_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf32_pru_link_hash_table);
+
+  ret = bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      link_hash_newfunc,
+				      sizeof (struct
+					      elf32_pru_link_hash_entry),
+				      PRU_ELF_DATA))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  ret->root.root.hash_table_free = pru_elf32_link_hash_table_free;
+
+  return &ret->root.root;
+}
+
+#define ELF_ARCH			bfd_arch_pru
+#define ELF_TARGET_ID			PRU_ELF_DATA
+#define ELF_MACHINE_CODE		EM_PRU
+
+#define ELF_MAXPAGESIZE			1
+
+#define bfd_elf32_bfd_link_hash_table_create \
+					  pru_elf32_link_hash_table_create
+
+/* Relocation table lookup macros.  */
+
+#define bfd_elf32_bfd_reloc_type_lookup	  pru_elf32_bfd_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	  pru_elf32_bfd_reloc_name_lookup
+
+/* elf_info_to_howto (using RELA relocations).  */
+
+#define elf_info_to_howto		  pru_elf32_info_to_howto
+
+/* elf backend functions.  */
+
+#define elf_backend_can_gc_sections	1
+#define elf_backend_can_refcount	1
+#define elf_backend_rela_normal		1
+
+#define elf_backend_relocate_section	  pru_elf32_relocate_section
+#define elf_backend_check_relocs	  pru_elf32_check_relocs
+
+#define TARGET_LITTLE_SYM		pru_elf32_vec
+#define TARGET_LITTLE_NAME		"elf32-pru"
+
+#include "elf32-target.h"
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index 3bb3726..d332662 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -2559,6 +2559,15 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_NIOS2_GOT_HA",
   "BFD_RELOC_NIOS2_CALL_LO",
   "BFD_RELOC_NIOS2_CALL_HA",
+  "BFD_RELOC_PRU_U8",
+  "BFD_RELOC_PRU_U16",
+  "BFD_RELOC_PRU_IMM5",
+  "BFD_RELOC_PRU_HI16",
+  "BFD_RELOC_PRU_LO16",
+  "BFD_RELOC_PRU_U16_PMEMIMM",
+  "BFD_RELOC_PRU_S10_PCREL",
+  "BFD_RELOC_PRU_32_PMEM",
+  "BFD_RELOC_PRU_16_PMEM",
   "BFD_RELOC_IQ2000_OFFSET_16",
   "BFD_RELOC_IQ2000_OFFSET_21",
   "BFD_RELOC_IQ2000_UHI16",
diff --git a/bfd/po/SRC-POTFILES.in b/bfd/po/SRC-POTFILES.in
index 3e5cbd0..61c89be 100644
--- a/bfd/po/SRC-POTFILES.in
+++ b/bfd/po/SRC-POTFILES.in
@@ -116,6 +116,7 @@ cpu-pdp11.c
 cpu-pj.c
 cpu-plugin.c
 cpu-powerpc.c
+cpu-pru.c
 cpu-rl78.c
 cpu-rs6000.c
 cpu-rx.c
@@ -206,6 +207,7 @@ elf32-nios2.c
 elf32-or1k.c
 elf32-pj.c
 elf32-ppc.c
+elf32-pru.c
 elf32-rl78.c
 elf32-rx.c
 elf32-s390.c
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 7f46c58..78b3373 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -6133,6 +6133,27 @@ ENUMDOC
   Relocations used by the Altera Nios II core.
 
 ENUM
+  BFD_RELOC_PRU_U8
+ENUMX
+  BFD_RELOC_PRU_U16
+ENUMX
+  BFD_RELOC_PRU_IMM5
+ENUMX
+  BFD_RELOC_PRU_HI16
+ENUMX
+  BFD_RELOC_PRU_LO16
+ENUMX
+  BFD_RELOC_PRU_U16_PMEMIMM
+ENUMX
+  BFD_RELOC_PRU_S10_PCREL
+ENUMX
+  BFD_RELOC_PRU_32_PMEM
+ENUMX
+  BFD_RELOC_PRU_16_PMEM
+ENUMDOC
+  Relocations used by the TI PRU processor.
+
+ENUM
   BFD_RELOC_IQ2000_OFFSET_16
 ENUMX
   BFD_RELOC_IQ2000_OFFSET_21
diff --git a/bfd/targets.c b/bfd/targets.c
index 0860dc5..ec4d0a6 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -787,6 +787,7 @@ extern const bfd_target powerpc_pe_le_vec;
 extern const bfd_target powerpc_pei_vec;
 extern const bfd_target powerpc_pei_le_vec;
 extern const bfd_target powerpc_xcoff_vec;
+extern const bfd_target pru_elf32_vec;
 extern const bfd_target rl78_elf32_vec;
 extern const bfd_target rs6000_xcoff64_vec;
 extern const bfd_target rs6000_xcoff64_aix_vec;
@@ -1275,6 +1276,8 @@ static const bfd_target * const _bfd_target_vector[] =
 	&powerpc_xcoff_vec,
 #endif
 
+	&pru_elf32_vec,
+
 	&rl78_elf32_vec,
 
 #ifdef BFD64
diff --git a/binutils/readelf.c b/binutils/readelf.c
index af6463e..a579049 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -137,6 +137,7 @@
 #include "elf/pj.h"
 #include "elf/ppc.h"
 #include "elf/ppc64.h"
+#include "elf/pru.h"
 #include "elf/rl78.h"
 #include "elf/rx.h"
 #include "elf/s390.h"
@@ -630,6 +631,7 @@ guess_is_rela (unsigned int e_machine)
     case EM_OR1K:
     case EM_PPC64:
     case EM_PPC:
+    case EM_PRU:
     case EM_RL78:
     case EM_RX:
     case EM_S390:
@@ -1319,6 +1321,10 @@ dump_relocations (FILE * file,
 	case EM_ALTERA_NIOS2:
 	  rtype = elf_nios2_reloc_type (type);
 	  break;
+
+	case EM_PRU:
+	  rtype = elf_pru_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -2089,6 +2095,7 @@ get_machine_name (unsigned e_machine)
     case EM_TILEGX:		return "Tilera TILE-Gx multicore architecture family";
     case EM_CUDA:		return "NVIDIA CUDA architecture";
     case EM_XGATE:		return "Motorola XGATE embedded processor";
+    case EM_PRU:		return "TI PRU I/O processor";
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
       return buff;
@@ -10501,6 +10508,8 @@ is_32bit_abs_reloc (unsigned int reloc_type)
       return reloc_type == 1; /* R_PPC64_ADDR32.  */
     case EM_PPC:
       return reloc_type == 1; /* R_PPC_ADDR32.  */
+    case EM_PRU:
+      return reloc_type == 12; /* R_PRU_BFD_RELOC_32.  */
     case EM_RL78:
       return reloc_type == 1; /* R_RL78_DIR32.  */
     case EM_RX:
@@ -10821,6 +10830,8 @@ is_none_reloc (unsigned int reloc_type)
 	      || reloc_type == 19  /* R_XTENSA_DIFF32.  */);
     case EM_METAG:
       return reloc_type == 3; /* R_METAG_NONE.  */
+    case EM_PRU:  /* R_PRU_NONE.  */
+      return reloc_type == 0;
     }
   return FALSE;
 }
diff --git a/config.sub b/config.sub
index d654d03..ee198e9 100755
--- a/config.sub
+++ b/config.sub
@@ -301,6 +301,7 @@ case $basic_machine in
 	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
+	| pru \
 	| pyramid \
 	| rl78 | rx \
 	| score \
@@ -422,6 +423,7 @@ case $basic_machine in
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
+	| pru-* \
 	| pyramid-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
diff --git a/elfcpp/elfcpp.h b/elfcpp/elfcpp.h
index 561b54a..9b2bed3 100644
--- a/elfcpp/elfcpp.h
+++ b/elfcpp/elfcpp.h
@@ -284,7 +284,8 @@ enum EM
   // Vitesse IQ2000
   EM_IQ2000 = 0xfeba,
   // NIOS
-  EM_NIOS32 = 0xfebb
+  EM_NIOS32 = 0xfebb,
+  EM_PRU = 0xfebc
   // Old AVR objects used 0x1057 (EM_AVR is correct).
   // Old MSP430 objects used 0x1059 (EM_MSP430 is correct).
   // Old FR30 objects used 0x3330 (EM_FR30 is correct).
diff --git a/gas/Makefile.am b/gas/Makefile.am
index 669ab19..b4148bf 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -171,6 +171,7 @@ TARGET_CPU_CFILES = \
 	config/tc-pdp11.c \
 	config/tc-pj.c \
 	config/tc-ppc.c \
+	config/tc-pru.c \
 	config/tc-rl78.c \
 	config/tc-rx.c \
 	config/tc-s390.c \
@@ -242,6 +243,7 @@ TARGET_CPU_HFILES = \
 	config/tc-pdp11.h \
 	config/tc-pj.h \
 	config/tc-ppc.h \
+	config/tc-pru.h \
 	config/tc-rl78.h \
 	config/tc-rx.h \
 	config/tc-s390.h \
diff --git a/gas/Makefile.in b/gas/Makefile.in
index 2ca56df..b1ae8d5 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -440,6 +440,7 @@ TARGET_CPU_CFILES = \
 	config/tc-pdp11.c \
 	config/tc-pj.c \
 	config/tc-ppc.c \
+	config/tc-pru.c \
 	config/tc-rl78.c \
 	config/tc-rx.c \
 	config/tc-s390.c \
@@ -511,6 +512,7 @@ TARGET_CPU_HFILES = \
 	config/tc-pdp11.h \
 	config/tc-pj.h \
 	config/tc-ppc.h \
+	config/tc-pru.h \
 	config/tc-rl78.h \
 	config/tc-rx.h \
 	config/tc-s390.h \
@@ -864,6 +866,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-pdp11.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-pj.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-ppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-pru.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-rl78.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-rx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-s390.Po@am__quote@
@@ -1569,6 +1572,20 @@ tc-ppc.obj: config/tc-ppc.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-ppc.obj `if test -f 'config/tc-ppc.c'; then $(CYGPATH_W) 'config/tc-ppc.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-ppc.c'; fi`
 
+tc-pru.o: config/tc-pru.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-pru.o -MD -MP -MF $(DEPDIR)/tc-pru.Tpo -c -o tc-pru.o `test -f 'config/tc-pru.c' || echo '$(srcdir)/'`config/tc-pru.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-pru.Tpo $(DEPDIR)/tc-pru.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-pru.c' object='tc-pru.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-pru.o `test -f 'config/tc-pru.c' || echo '$(srcdir)/'`config/tc-pru.c
+
+tc-pru.obj: config/tc-pru.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-pru.obj -MD -MP -MF $(DEPDIR)/tc-pru.Tpo -c -o tc-pru.obj `if test -f 'config/tc-pru.c'; then $(CYGPATH_W) 'config/tc-pru.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-pru.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-pru.Tpo $(DEPDIR)/tc-pru.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-pru.c' object='tc-pru.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-pru.obj `if test -f 'config/tc-pru.c'; then $(CYGPATH_W) 'config/tc-pru.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-pru.c'; fi`
+
 tc-rl78.o: config/tc-rl78.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-rl78.o -MD -MP -MF $(DEPDIR)/tc-rl78.Tpo -c -o tc-rl78.o `test -f 'config/tc-rl78.c' || echo '$(srcdir)/'`config/tc-rl78.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-rl78.Tpo $(DEPDIR)/tc-rl78.Po
diff --git a/gas/config/obj-elf.c b/gas/config/obj-elf.c
index e406f7b..5e4e1c5 100644
--- a/gas/config/obj-elf.c
+++ b/gas/config/obj-elf.c
@@ -64,6 +64,10 @@
 #include "elf/nios2.h"
 #endif
 
+#ifdef TC_PRU
+#include "elf/pru.h"
+#endif
+
 static void obj_elf_line (int);
 static void obj_elf_size (int);
 static void obj_elf_type (int);
diff --git a/gas/config/tc-pru.c b/gas/config/tc-pru.c
new file mode 100644
index 0000000..26c0884
--- /dev/null
+++ b/gas/config/tc-pru.c
@@ -0,0 +1,1605 @@
+/* TI PRU assembler.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+   Based on tc-nios2.c
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "as.h"
+#include "opcode/pru.h"
+#include "elf/pru.h"
+#include "tc-pru.h"
+#include "bfd.h"
+#include "dwarf2dbg.h"
+#include "subsegs.h"
+#include "safe-ctype.h"
+#include "dw2gencfi.h"
+
+#ifndef OBJ_ELF
+/* We are not supporting any other target so we throw a compile time error.  */
+OBJ_ELF not defined
+#endif
+
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful.  */
+const char comment_chars[] = "#";
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output.  */
+/* Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+   #NO_APP at the beginning of its output.  */
+/* Also note that C style comments are always supported.  */
+const char line_comment_chars[] = "#";
+
+/* This array holds machine specific line separator characters.  */
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant from exp in floating point nums.  */
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant.  */
+/* As in 0f12.456 */
+/* or	 0d1.2345e12 */
+const char FLT_CHARS[] = "rRsSfFdDxXpP";
+
+/* Machine-dependent command-line options.  */
+
+const char *md_shortopts = "r";
+
+struct option md_longopts[] = {
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+
+typedef struct pru_insn_reloc
+{
+  /* Any expression in the instruction is parsed into this field,
+     which is passed to fix_new_exp() to generate a fixup.  */
+  expressionS reloc_expression;
+
+  /* The type of the relocation to be applied.  */
+  bfd_reloc_code_real_type reloc_type;
+
+  /* PC-relative.  */
+  unsigned int reloc_pcrel;
+
+  /* The next relocation to be applied to the instruction.  */
+  struct pru_insn_reloc *reloc_next;
+} pru_insn_relocS;
+
+/* This struct is used to hold state when assembling instructions.  */
+typedef struct pru_insn_info
+{
+  /* Assembled instruction.  */
+  unsigned long insn_code;
+  /* Pointer to the relevant bit of the opcode table.  */
+  const struct pru_opcode *insn_pru_opcode;
+  /* After parsing ptrs to the tokens in the instruction fill this array
+     it is terminated with a null pointer (hence the first +1).
+     The second +1 is because in some parts of the code the opcode
+     is not counted as a token, but still placed in this array.  */
+  const char *insn_tokens[PRU_MAX_INSN_TOKENS + 1 + 1];
+
+  /* This holds information used to generate fixups
+     and eventually relocations if it is not null.  */
+  pru_insn_relocS *insn_reloc;
+} pru_insn_infoS;
+
+/* Opcode hash table.  */
+static struct hash_control *pru_opcode_hash = NULL;
+#define pru_opcode_lookup(NAME) \
+  ((struct pru_opcode *) hash_find (pru_opcode_hash, (NAME)))
+
+/* Register hash table.  */
+static struct hash_control *pru_reg_hash = NULL;
+#define pru_reg_lookup(NAME) \
+  ((struct pru_reg *) hash_find (pru_reg_hash, (NAME)))
+
+/* The known current alignment of the current section.  */
+static int pru_current_align;
+static segT pru_current_align_seg;
+
+static int pru_auto_align_on = 1;
+
+/* The last seen label in the current section.  This is used to auto-align
+   labels preceeding instructions.  */
+static symbolS *pru_last_label;
+
+
+/** Utility routines.  */
+/* Function md_chars_to_number takes the sequence of
+   bytes in buf and returns the corresponding value
+   in an int. n must be 1, 2 or 4.  */
+static valueT
+md_chars_to_number (char *buf, int n)
+{
+  int i;
+  valueT val;
+
+  gas_assert (n == 1 || n == 2 || n == 4);
+
+  val = 0;
+  for (i = 0; i < n; ++i)
+    val = val | ((buf[i] & 0xff) << 8 * i);
+  return val;
+}
+
+
+/* This function turns a C long int, short int or char
+   into the series of bytes that represent the number
+   on the target machine.  */
+void
+md_number_to_chars (char *buf, valueT val, int n)
+{
+  gas_assert (n == 1 || n == 2 || n == 4 || n == 8);
+  number_to_chars_littleendian (buf, val, n);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type TYPE, and store the appropriate bytes in *LITP.  The number
+   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
+   returned, or NULL on OK.  */
+char *
+md_atof (int type, char *litP, int *sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, FALSE);
+}
+
+/* Return true if STR starts with PREFIX, which should be a string literal.  */
+#define strprefix(STR, PREFIX) \
+  (strncmp ((STR), PREFIX, strlen (PREFIX)) == 0)
+
+/* Return true if STR is prefixed with a special relocation operator.  */
+static int
+pru_special_relocation_p (const char *str)
+{
+  return (strprefix (str, "%lo")
+	  || strprefix (str, "%hi")
+	  || strprefix (str, "%pmem"));
+}
+
+/* nop fill pattern for text section.  */
+static char const nop[4] = { 0x00, 0x00, 0x00, 0xA0 };
+
+/* Handles all machine-dependent alignment needs.  */
+static void
+pru_align (int log_size, const char *pfill, symbolS *label)
+{
+  int align;
+  long max_alignment = 15;
+
+  /* The front end is prone to changing segments out from under us
+     temporarily when -g is in effect.  */
+  int switched_seg_p = (pru_current_align_seg != now_seg);
+
+  align = log_size;
+  if (align > max_alignment)
+    {
+      align = max_alignment;
+      as_bad (_("Alignment too large: %d. assumed"), align);
+    }
+  else if (align < 0)
+    {
+      as_warn (_("Alignment negative: 0 assumed"));
+      align = 0;
+    }
+
+  if (align != 0)
+    {
+      if (subseg_text_p (now_seg) && align >= 2)
+	{
+	  /* First, make sure we're on a four-byte boundary, in case
+	     someone has been putting .byte values the text section.  */
+	  if (pru_current_align < 2 || switched_seg_p)
+	    frag_align (2, 0, 0);
+
+	  /* Now fill in the alignment pattern.  */
+	  if (pfill != NULL)
+	    frag_align_pattern (align, pfill, sizeof nop, 0);
+	  else
+	    frag_align (align, 0, 0);
+	}
+      else
+	frag_align (align, 0, 0);
+
+      if (!switched_seg_p)
+	pru_current_align = align;
+
+      /* If the last label was in a different section we can't align it.  */
+      if (label != NULL && !switched_seg_p)
+	{
+	  symbolS *sym;
+	  int label_seen = FALSE;
+	  struct frag *old_frag;
+	  valueT old_value;
+	  valueT new_value;
+
+	  gas_assert (S_GET_SEGMENT (label) == now_seg);
+
+	  old_frag = symbol_get_frag (label);
+	  old_value = S_GET_VALUE (label);
+	  new_value = (valueT) frag_now_fix ();
+
+	  /* It is possible to have more than one label at a particular
+	     address, especially if debugging is enabled, so we must
+	     take care to adjust all the labels at this address in this
+	     fragment.  To save time we search from the end of the symbol
+	     list, backwards, since the symbols we are interested in are
+	     almost certainly the ones that were most recently added.
+	     Also to save time we stop searching once we have seen at least
+	     one matching label, and we encounter a label that is no longer
+	     in the target fragment.  Note, this search is guaranteed to
+	     find at least one match when sym == label, so no special case
+	     code is necessary.  */
+	  for (sym = symbol_lastP; sym != NULL; sym = symbol_previous (sym))
+	    if (symbol_get_frag (sym) == old_frag
+		&& S_GET_VALUE (sym) == old_value)
+	      {
+		label_seen = TRUE;
+		symbol_set_frag (sym, frag_now);
+		S_SET_VALUE (sym, new_value);
+	      }
+	    else if (label_seen && symbol_get_frag (sym) != old_frag)
+	      break;
+	}
+      record_alignment (now_seg, align);
+    }
+}
+
+
+/** Support for self-check mode.  */
+
+/* Mode of the assembler.  */
+typedef enum
+{
+  PRU_MODE_ASSEMBLE,		/* Ordinary operation.  */
+  PRU_MODE_TEST		/* Hidden mode used for self testing.  */
+} PRU_MODE;
+
+static PRU_MODE pru_mode = PRU_MODE_ASSEMBLE;
+
+/* This function is used to in self-checking mode
+   to check the assembled instruction
+   opcode should be the assembled opcode, and exp_opcode
+   the parsed string representing the expected opcode.  */
+static void
+pru_check_assembly (unsigned int opcode, const char *exp_opcode)
+{
+  if (pru_mode == PRU_MODE_TEST)
+    {
+      if (exp_opcode == NULL)
+	as_bad (_("expecting opcode string in self test mode"));
+      else if (opcode != strtoul (exp_opcode, NULL, 16))
+	as_bad (_("assembly 0x%08x, expected %s"), opcode, exp_opcode);
+    }
+}
+
+
+/** Support for machine-dependent assembler directives.  */
+/* Handle the .align pseudo-op.  This aligns to a power of two.  It
+   also adjusts any current instruction label.  We treat this the same
+   way the MIPS port does: .align 0 turns off auto alignment.  */
+static void
+s_pru_align (int ignore ATTRIBUTE_UNUSED)
+{
+  int align;
+  char fill;
+  const char *pfill = NULL;
+  long max_alignment = 15;
+
+  align = get_absolute_expression ();
+  if (align > max_alignment)
+    {
+      align = max_alignment;
+      as_bad (_("Alignment too large: %d. assumed"), align);
+    }
+  else if (align < 0)
+    {
+      as_warn (_("Alignment negative: 0 assumed"));
+      align = 0;
+    }
+
+  if (*input_line_pointer == ',')
+    {
+      input_line_pointer++;
+      fill = get_absolute_expression ();
+      pfill = (const char *) &fill;
+    }
+  else if (subseg_text_p (now_seg))
+    pfill = (const char *) &nop;
+  else
+    {
+      pfill = NULL;
+      pru_last_label = NULL;
+    }
+
+  if (align != 0)
+    {
+      pru_auto_align_on = 1;
+      pru_align (align, pfill, pru_last_label);
+      pru_last_label = NULL;
+    }
+  else
+    pru_auto_align_on = 0;
+
+  demand_empty_rest_of_line ();
+}
+
+/* Handle the .text pseudo-op.  This is like the usual one, but it
+   clears the saved last label and resets known alignment.  */
+static void
+s_pru_text (int i)
+{
+  s_text (i);
+  pru_last_label = NULL;
+  pru_current_align = 0;
+  pru_current_align_seg = now_seg;
+}
+
+/* Handle the .data pseudo-op.  This is like the usual one, but it
+   clears the saved last label and resets known alignment.  */
+static void
+s_pru_data (int i)
+{
+  s_data (i);
+  pru_last_label = NULL;
+  pru_current_align = 0;
+  pru_current_align_seg = now_seg;
+}
+
+/* Handle the .section pseudo-op.  This is like the usual one, but it
+   clears the saved last label and resets known alignment.  */
+static void
+s_pru_section (int ignore)
+{
+  obj_elf_section (ignore);
+  pru_last_label = NULL;
+  pru_current_align = 0;
+  pru_current_align_seg = now_seg;
+}
+
+/* Explicitly unaligned cons.  */
+static void
+s_pru_ucons (int nbytes)
+{
+  int hold;
+  hold = pru_auto_align_on;
+  pru_auto_align_on = 0;
+  cons (nbytes);
+  pru_auto_align_on = hold;
+}
+
+/* Machine-dependent assembler directives.
+   Format of each entry is:
+   { "directive", handler_func, param }	 */
+const pseudo_typeS md_pseudo_table[] = {
+  {"align", s_pru_align, 0},
+  {"text", s_pru_text, 0},
+  {"data", s_pru_data, 0},
+  {"section", s_pru_section, 0},
+  {"section.s", s_pru_section, 0},
+  {"sect", s_pru_section, 0},
+  {"sect.s", s_pru_section, 0},
+  /* .dword and .half are included for compatibility with MIPS.  */
+  {"dword", cons, 8},
+  {"half", cons, 2},
+  /* PRU native word size is 4 bytes, so we override
+     the GAS default of 2.  */
+  {"word", cons, 4},
+  /* Explicitly unaligned directives.  */
+  {"2byte", s_pru_ucons, 2},
+  {"4byte", s_pru_ucons, 4},
+  {"8byte", s_pru_ucons, 8},
+  {"16byte", s_pru_ucons, 16},
+  {NULL, NULL, 0}
+};
+
+
+
+int
+md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
+			       asection *seg ATTRIBUTE_UNUSED)
+{
+  abort ();
+  return 0;
+}
+
+void
+md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT segment ATTRIBUTE_UNUSED,
+		 fragS *fragp ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+
+/** Fixups and overflow checking.  */
+
+/* Check a fixup for overflow. */
+static bfd_boolean
+pru_check_overflow (valueT fixup, reloc_howto_type *howto)
+{
+  /* Apply the rightshift before checking for overflow.  */
+  fixup = ((signed)fixup) >> howto->rightshift;
+
+  /* Check for overflow - return TRUE if overflow, FALSE if not.  */
+  switch (howto->complain_on_overflow)
+    {
+    case complain_overflow_dont:
+      break;
+    case complain_overflow_bitfield:
+      if ((fixup >> howto->bitsize) != 0
+	  && ((signed) fixup >> howto->bitsize) != -1)
+	return TRUE;
+      break;
+    case complain_overflow_signed:
+      if ((fixup & 0x80000000) > 0)
+	{
+	  /* Check for negative overflow.  */
+	  if ((signed) fixup < ((signed) 0x80000000 >> howto->bitsize))
+	    return TRUE;
+	}
+      else
+	{
+	  /* Check for positive overflow.  */
+	  if (fixup >= ((unsigned) 1 << (howto->bitsize - 1)))
+	    return TRUE;
+	}
+      break;
+    case complain_overflow_unsigned:
+      if ((fixup >> howto->bitsize) != 0)
+	return TRUE;
+      break;
+    default:
+      as_bad (_("error checking for overflow - broken assembler"));
+      break;
+    }
+  return FALSE;
+}
+
+/* Emit diagnostic for fixup overflow.  */
+static void
+pru_diagnose_overflow (valueT fixup, reloc_howto_type *howto,
+			 fixS *fixP, valueT value)
+{
+  if (fixP->fx_r_type == BFD_RELOC_8
+      || fixP->fx_r_type == BFD_RELOC_16
+      || fixP->fx_r_type == BFD_RELOC_32
+      || fixP->fx_r_type == BFD_RELOC_PRU_U8
+      || fixP->fx_r_type == BFD_RELOC_PRU_IMM5)
+    /* These relocs are against data, not instructions.  */
+    as_bad_where (fixP->fx_file, fixP->fx_line,
+		  _("immediate value 0x%x truncated to 0x%x"),
+		  (unsigned int) fixup,
+		  (unsigned int) (~(~(valueT) 0 << howto->bitsize) & fixup));
+  else
+    {
+      /* What opcode is the instruction?  This will determine
+	 whether we check for overflow in immediate values
+	 and what error message we get.  */
+      const struct pru_opcode *opcode;
+      enum overflow_type overflow_msg_type;
+      unsigned int range_min;
+      unsigned int range_max;
+      unsigned int address;
+      gas_assert (fixP->fx_size == 4);
+      opcode = pru_find_opcode (value);
+      gas_assert (opcode);
+      overflow_msg_type = opcode->overflow_msg;
+      switch (overflow_msg_type)
+	{
+	case call_target_overflow:
+	  range_min
+	    = ((fixP->fx_frag->fr_address + fixP->fx_where) & 0xf0000000);
+	  range_max = range_min + 0x0fffffff;
+	  address = fixup | range_min;
+
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("call target address 0x%08x out of range 0x%08x to 0x%08x"),
+			address, range_min, range_max);
+	  break;
+	case qbranch_target_overflow:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("quick branch offset %d out of range %d to %d"),
+			(int)fixup, -((1<<9) * 4), (1 << 9) * 4);
+	  break;
+	case address_offset_overflow:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("%s offset %d out of range %d to %d"),
+			opcode->name, (int)fixup, -32768, 32767);
+	  break;
+	case signed_immed16_overflow:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("immediate value %d out of range %d to %d"),
+			(int)fixup, -32768, 32767);
+	  break;
+	case unsigned_immed16_overflow:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("immediate value %u out of range %u to %u"),
+			(unsigned int)fixup, 0, 65535);
+	  break;
+	case unsigned_immed5_overflow:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("immediate value %u out of range %u to %u"),
+			(unsigned int)fixup, 0, 31);
+	  break;
+	default:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("overflow in immediate argument"));
+	  break;
+	}
+    }
+}
+
+/* Apply a fixup to the object file.  */
+void
+md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
+{
+  /* Assert that the fixup is one we can handle.  */
+  gas_assert (fixP != NULL && valP != NULL
+	      && (fixP->fx_r_type == BFD_RELOC_8
+		  || fixP->fx_r_type == BFD_RELOC_16
+		  || fixP->fx_r_type == BFD_RELOC_32
+		  || fixP->fx_r_type == BFD_RELOC_64
+		  || fixP->fx_r_type == BFD_RELOC_PRU_U8
+		  || fixP->fx_r_type == BFD_RELOC_PRU_U16
+		  || fixP->fx_r_type == BFD_RELOC_PRU_IMM5
+		  || fixP->fx_r_type == BFD_RELOC_PRU_HI16
+		  || fixP->fx_r_type == BFD_RELOC_PRU_LO16
+		  || fixP->fx_r_type == BFD_RELOC_PRU_U16_PMEMIMM
+		  || fixP->fx_r_type == BFD_RELOC_PRU_S10_PCREL
+		  || fixP->fx_r_type == BFD_RELOC_PRU_32_PMEM
+		  || fixP->fx_r_type == BFD_RELOC_PRU_16_PMEM
+		  /* Add other relocs here as we generate them.  */
+		  ));
+
+  if (fixP->fx_r_type == BFD_RELOC_64)
+    {
+      /* We may reach here due to .8byte directives, but we never output
+	 BFD_RELOC_64; it must be resolved.  */
+      if (fixP->fx_addsy != NULL)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("cannot create 64-bit relocation"));
+      else
+	{
+	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
+			      *valP, 8);
+	  fixP->fx_done = 1;
+	}
+      return;
+    }
+
+  gas_assert (had_errors() || !fixP->fx_subsy);
+
+  /* The value passed in valP can be the value of a fully
+     resolved expression, or it can be the value of a partially
+     resolved expression.  In the former case, both fixP->fx_addsy
+     and fixP->fx_subsy are NULL, and fixP->fx_offset == *valP, and
+     we can fix up the instruction that fixP relates to.
+     In the latter case, one or both of fixP->fx_addsy and
+     fixP->fx_subsy are not NULL, and fixP->fx_offset may or may not
+     equal *valP.  We don't need to check for fixP->fx_subsy being null
+     because the generic part of the assembler generates an error if
+     it is not an absolute symbol.  */
+  if (fixP->fx_addsy != NULL)
+    /* Partially resolved expression.  */
+    {
+      fixP->fx_addnumber = fixP->fx_offset;
+      fixP->fx_done = 0;
+    }
+  else
+    /* Fully resolved fixup.  */
+    {
+      reloc_howto_type *howto
+	= bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
+
+      if (howto == NULL)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("relocation is not supported"));
+      else
+	{
+	  valueT fixup = *valP;
+	  valueT value;
+	  char *buf;
+
+	  /* Get the instruction or data to be fixed up.  */
+	  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
+	  value = md_chars_to_number (buf, fixP->fx_size);
+
+	  /* Check for overflow, emitting a diagnostic if necessary.  */
+	  if (pru_check_overflow (fixup, howto))
+	    pru_diagnose_overflow (fixup, howto, fixP, value);
+
+	  /* Apply the right shift.  */
+	  fixup = ((signed)fixup) >> howto->rightshift;
+
+	  /* Truncate the fixup to right size.  */
+	  switch (fixP->fx_r_type)
+	    {
+	    case BFD_RELOC_PRU_HI16:
+	      fixup = (fixup >> 16) & 0xFFFF;
+	      break;
+	    case BFD_RELOC_PRU_LO16:
+	      fixup = fixup & 0xFFFF;
+	      break;
+	    default:
+	      {
+		long n = sizeof (fixup) * 8 - howto->bitsize;
+		fixup = (fixup << n) >> n;
+		break;
+	      }
+	    }
+
+	  /* Fix up the instruction. Non-contiguous bitfields need
+	     special handling. */
+	  if (fixP->fx_r_type == BFD_RELOC_PRU_S10_PCREL)
+	    SET_BROFF_URAW (value, fixup);
+	  else
+	    value = (value & ~howto->dst_mask) | (fixup << howto->bitpos);
+	  md_number_to_chars (buf, value, fixP->fx_size);
+	}
+
+      fixP->fx_done = 1;
+    }
+
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
+    {
+      fixP->fx_done = 0;
+      if (fixP->fx_addsy
+	  && !S_IS_DEFINED (fixP->fx_addsy) && !S_IS_WEAK (fixP->fx_addsy))
+	S_SET_WEAK (fixP->fx_addsy);
+    }
+  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    fixP->fx_done = 0;
+}
+
+
+
+/** Instruction parsing support. */
+
+/* Special relocation directive strings.  */
+
+struct pru_special_relocS
+{
+  const char *string;
+  bfd_reloc_code_real_type reloc_type;
+};
+
+/* This table is sorted so that prefix strings are listed after the longer
+   strings that include them. */
+
+struct pru_special_relocS pru_special_reloc[] = {
+  {"%hi", BFD_RELOC_PRU_HI16},
+  {"%lo", BFD_RELOC_PRU_LO16},
+  {"%pmem", BFD_RELOC_PRU_U16_PMEMIMM},
+};
+
+#define PRU_NUM_SPECIAL_RELOCS \
+	(sizeof(pru_special_reloc)/sizeof(pru_special_reloc[0]))
+const int pru_num_special_relocs = PRU_NUM_SPECIAL_RELOCS;
+
+/* Creates a new pru_insn_relocS and returns a pointer to it.  */
+static pru_insn_relocS *
+pru_insn_reloc_new (bfd_reloc_code_real_type reloc_type, unsigned int pcrel)
+{
+  pru_insn_relocS *retval;
+  retval = (pru_insn_relocS *) malloc (sizeof (pru_insn_relocS));
+  if (retval == NULL)
+    {
+      as_bad (_("can't create relocation"));
+      abort ();
+    }
+
+  /* Fill out the fields with default values.  */
+  retval->reloc_next = NULL;
+  retval->reloc_type = reloc_type;
+  retval->reloc_pcrel = pcrel;
+  return retval;
+}
+
+/* Frees up memory previously allocated by pru_insn_reloc_new().  */
+static void
+pru_insn_reloc_destroy (pru_insn_relocS *reloc)
+{
+  pru_insn_relocS *next;
+
+  while (reloc)
+    {
+      next = reloc->reloc_next;
+      free (reloc);
+      reloc = next;
+    }
+}
+
+/* The various pru_assemble_* functions call this
+   function to generate an expression from a string representing an expression.
+   It then tries to evaluate the expression, and if it can, returns its value.
+   If not, it creates a new pru_insn_relocS and stores the expression and
+   reloc_type for future use.  */
+static unsigned long
+pru_assemble_expression (const char *exprstr,
+			   pru_insn_infoS *insn,
+			   pru_insn_relocS *prev_reloc,
+			   bfd_reloc_code_real_type reloc_type,
+			   unsigned int pcrel)
+{
+  expressionS *ep;
+  pru_insn_relocS *reloc;
+  char *saved_line_ptr;
+  unsigned short value;
+  int i;
+
+  gas_assert (exprstr != NULL);
+  gas_assert (insn != NULL);
+
+  /* Check for relocation operators.
+     Change the relocation type and advance the ptr to the start of
+     the expression proper. */
+  for (i = 0; i < pru_num_special_relocs; i++)
+    if (strstr (exprstr, pru_special_reloc[i].string) != NULL)
+      {
+	reloc_type = pru_special_reloc[i].reloc_type;
+	exprstr += strlen (pru_special_reloc[i].string) + 1;
+
+	break;
+      }
+
+  /* We potentially have a relocation.  */
+  reloc = pru_insn_reloc_new (reloc_type, pcrel);
+  if (prev_reloc != NULL)
+    prev_reloc->reloc_next = reloc;
+  else
+    insn->insn_reloc = reloc;
+
+  /* Parse the expression string.  */
+  ep = &reloc->reloc_expression;
+  saved_line_ptr = input_line_pointer;
+  input_line_pointer = (char *) exprstr;
+  SKIP_WHITESPACE ();
+  expression (ep);
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer)
+    as_bad (_("trailing garbage after expression: %s"), input_line_pointer);
+  input_line_pointer = saved_line_ptr;
+
+
+  if (ep->X_op == O_illegal || ep->X_op == O_absent)
+    as_bad (_("expected expression, got %s"), exprstr);
+
+  /* This is redundant as the fixup will put this into
+     the instruction, but it is included here so that
+     self-test mode (-r) works.  */
+  value = 0;
+  if (pru_mode == PRU_MODE_TEST && ep->X_op == O_constant)
+    value = ep->X_add_number;
+
+  return (unsigned long) value;
+}
+
+/* Try to parse a non-relocatable expression. */
+static unsigned long
+pru_assemble_noreloc_expression (const char *exprstr)
+{
+  expressionS exp;
+  char *saved_line_ptr;
+  unsigned long val;
+
+  gas_assert (exprstr != NULL);
+
+  saved_line_ptr = input_line_pointer;
+  input_line_pointer = (char *) exprstr;
+  SKIP_WHITESPACE ();
+  expression (&exp);
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer)
+    as_bad (_("trailing garbage after expression: %s"), input_line_pointer);
+  input_line_pointer = saved_line_ptr;
+
+  val = 0;
+  if (exp.X_op != O_constant)
+    as_bad (_("expected constant expression, got %s"), exprstr);
+  else
+    val = exp.X_add_number;
+
+  return val;
+}
+
+/* Argument assemble functions.
+   All take an instruction argument string, and a pointer
+   to an instruction opcode. Upon return the insn_opcode
+   has the relevant fields filled in to represent the arg
+   string.  The return value is NULL if successful, or
+   an error message if an error was detected. */
+
+static void
+pru_assemble_arg_d (pru_insn_infoS *insn_info, const char *argstr)
+{
+  struct pru_reg *dst = pru_reg_lookup (argstr);
+
+  if (dst == NULL)
+    as_bad (_("unknown register %s"), argstr);
+  else
+    {
+      SET_INSN_FIELD (RD, insn_info->insn_code, dst->index);
+      SET_INSN_FIELD (RDSEL, insn_info->insn_code, dst->regsel);
+    }
+}
+
+static void
+pru_assemble_arg_D (pru_insn_infoS *insn_info, const char *argstr)
+{
+  struct pru_reg *dst = pru_reg_lookup (argstr);
+
+  if (dst == NULL)
+    as_bad (_("unknown register %s"), argstr);
+  else
+    {
+      unsigned long rxb = 0;
+
+      switch (dst->regsel)
+	{
+	case RSEL_31_0: rxb = 0; break;	/* whole register defaults to .b0 */
+	case RSEL_7_0: rxb = 0; break;
+	case RSEL_15_8: rxb = 1; break;
+	case RSEL_23_16: rxb = 2; break;
+	case RSEL_31_24: rxb = 3; break;
+	default:
+	  as_bad (_("data transfer register cannot be halfword"));
+	}
+
+      SET_INSN_FIELD (RD, insn_info->insn_code, dst->index);
+      SET_INSN_FIELD (RDB, insn_info->insn_code, rxb);
+    }
+}
+
+static void
+pru_assemble_arg_s (pru_insn_infoS *insn_info, const char *argstr)
+{
+  struct pru_reg *src1 = pru_reg_lookup (argstr);
+
+  if (src1 == NULL)
+    as_bad (_("unknown register %s"), argstr);
+  else
+    {
+      SET_INSN_FIELD (RS1, insn_info->insn_code, src1->index);
+      SET_INSN_FIELD (RS1SEL, insn_info->insn_code, src1->regsel);
+    }
+}
+
+static void
+pru_assemble_arg_S (pru_insn_infoS *insn_info, const char *argstr)
+{
+  struct pru_reg *src1 = pru_reg_lookup (argstr);
+
+  if (src1 == NULL)
+    as_bad (_("unknown register %s"), argstr);
+  else
+    {
+      if (src1->regsel != RSEL_31_0)
+	as_bad (_("cannot use partial register %s for addressing"), argstr);
+      SET_INSN_FIELD (RS1, insn_info->insn_code, src1->index);
+    }
+}
+
+static void
+pru_assemble_arg_b (pru_insn_infoS *insn_info, const char *argstr)
+{
+  struct pru_reg *src2 = pru_reg_lookup (argstr);
+  if (src2 == NULL)
+    {
+      unsigned long imm8 =
+	pru_assemble_expression (argstr, insn_info,
+				 insn_info->insn_reloc,
+				 BFD_RELOC_PRU_U8, 0);
+      SET_INSN_FIELD (IMM8, insn_info->insn_code, imm8);
+      SET_INSN_FIELD (IO, insn_info->insn_code, 1);
+    }
+  else
+    {
+      SET_INSN_FIELD (IO, insn_info->insn_code, 0);
+      SET_INSN_FIELD (RS2, insn_info->insn_code, src2->index);
+      SET_INSN_FIELD (RS2SEL, insn_info->insn_code, src2->regsel);
+    }
+
+}
+
+static void
+pru_assemble_arg_j (pru_insn_infoS *insn_info, const char *argstr)
+{
+  struct pru_reg *src2 = pru_reg_lookup (argstr);
+
+  if (src2 == NULL)
+    {
+      unsigned long imm16 =
+	pru_assemble_expression (argstr, insn_info,
+				 insn_info->insn_reloc,
+				 BFD_RELOC_PRU_U16_PMEMIMM, 0);
+      SET_INSN_FIELD (IMM16, insn_info->insn_code, imm16);
+      SET_INSN_FIELD (IO, insn_info->insn_code, 1);
+    }
+  else
+    {
+      SET_INSN_FIELD (IO, insn_info->insn_code, 0);
+      SET_INSN_FIELD (RS2, insn_info->insn_code, src2->index);
+      SET_INSN_FIELD (RS2SEL, insn_info->insn_code, src2->regsel);
+    }
+}
+
+static void
+pru_assemble_arg_W (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long imm16 = pru_assemble_expression (argstr, insn_info,
+						 insn_info->insn_reloc,
+						 BFD_RELOC_PRU_U16, 0);
+  /* QUIRK: LDI must clear IO bit high, even though it has immediate arg. */
+  SET_INSN_FIELD (IO, insn_info->insn_code, 0);
+  SET_INSN_FIELD (IMM16, insn_info->insn_code, imm16);
+}
+
+static void
+pru_assemble_arg_o (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long imm10 =
+    pru_assemble_expression (argstr, insn_info,
+			     insn_info->insn_reloc,
+			     BFD_RELOC_PRU_S10_PCREL, 1);
+  SET_BROFF_URAW (insn_info->insn_code, imm10);
+}
+
+static void
+pru_assemble_arg_l (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long burstlen = 0;
+  struct pru_reg *blreg = pru_reg_lookup (argstr);
+
+  if (blreg == NULL)
+    {
+      burstlen = pru_assemble_noreloc_expression (argstr);
+      if (!burstlen || burstlen > LSSBBO_BYTECOUNT_R0_BITS7_0)
+	as_bad (_("byte count constant %ld is out of range [1..%d]"),
+		burstlen, LSSBBO_BYTECOUNT_R0_BITS7_0);
+      burstlen--;
+    }
+  else
+    {
+      if (blreg->index != 0)
+	as_bad (_("only r0 can be used as byte count register"));
+      else if (blreg->regsel > RSEL_31_24)
+	as_bad (_("only r0.bX byte fields of r0 can be used as byte count"));
+      else
+	burstlen = LSSBBO_BYTECOUNT_R0_BITS7_0 + blreg->regsel;
+    }
+    SET_BURSTLEN (insn_info->insn_code, burstlen);
+}
+
+static void
+pru_assemble_arg_n (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long burstlen = 0;
+  struct pru_reg *blreg = pru_reg_lookup (argstr);
+
+  if (blreg == NULL)
+    {
+      burstlen = pru_assemble_noreloc_expression (argstr);
+      if (!burstlen || burstlen > LSSBBO_BYTECOUNT_R0_BITS7_0)
+	as_bad (_("byte count constant %ld is out of range [1..%d]"),
+		burstlen, LSSBBO_BYTECOUNT_R0_BITS7_0);
+      burstlen--;
+    }
+  else
+    {
+      if (blreg->index != 0)
+	as_bad (_("only r0 can be used as byte count register"));
+      else if (blreg->regsel > RSEL_31_24)
+	as_bad (_("only r0.bX byte fields of r0 can be used as byte count"));
+      else
+	burstlen = LSSBBO_BYTECOUNT_R0_BITS7_0 + blreg->regsel;
+    }
+    SET_INSN_FIELD (XFR_LENGTH, insn_info->insn_code, burstlen);
+}
+
+static void
+pru_assemble_arg_c (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long cb = pru_assemble_noreloc_expression (argstr);
+
+  if (cb > 31)
+    as_bad (_("invalid constant table offset %ld"), cb);
+  else
+    SET_INSN_FIELD (CB, insn_info->insn_code, cb);
+}
+
+static void
+pru_assemble_arg_w (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long wk = pru_assemble_noreloc_expression (argstr);
+
+  if (wk != 0 && wk != 1)
+    as_bad (_("invalid WakeOnStatus %ld"), wk);
+  else
+    SET_INSN_FIELD (WAKEONSTATUS, insn_info->insn_code, wk);
+}
+
+static void
+pru_assemble_arg_x (pru_insn_infoS *insn_info, const char *argstr)
+{
+  unsigned long wba = pru_assemble_noreloc_expression (argstr);
+
+  if (wba > 255)
+    as_bad (_("invalid XFR WideBus Address %ld"), wba);
+  else
+    SET_INSN_FIELD (XFR_WBA, insn_info->insn_code, wba);
+}
+
+/* The function consume_arg takes a pointer into a string
+   of instruction tokens (args) and a pointer into a string
+   representing the expected sequence of tokens and separators.
+   It checks whether the first argument in argstr is of the
+   expected type, throwing an error if it is not, and returns
+   the pointer argstr.  */
+static char *
+pru_consume_arg (char *argstr, const char *parsestr)
+{
+  char *temp;
+
+  switch (*parsestr)
+    {
+    case 'W':
+      if (*argstr == '%')
+	{
+	  if (pru_special_relocation_p (argstr))
+	    {
+	      /* We zap the parentheses because we don't want them confused
+		 with separators.  */
+	      temp = strchr (argstr, '(');
+	      if (temp != NULL)
+		*temp = ' ';
+	      temp = strchr (argstr, ')');
+	      if (temp != NULL)
+		*temp = ' ';
+	    }
+	  else
+	    as_bad (_("badly formed expression near %s"), argstr);
+	}
+      break;
+    case 'b':
+    case 'd':
+    case 'D':
+    case 'j':
+    case 's':
+    case 'S':
+    case 'c':
+    case 'l':
+    case 'n':
+    case 'o':
+    case 'w':
+    case 'x':
+      /* We can't have %hi, %lo or %hiadj here.  */
+      if (*argstr == '%')
+	as_bad (_("badly formed expression near %s"), argstr);
+      break;
+    default:
+      BAD_CASE (*parsestr);
+      break;
+    }
+
+  return argstr;
+}
+
+/* The function consume_separator takes a pointer into a string
+   of instruction tokens (args) and a pointer into a string representing
+   the expected sequence of tokens and separators.  It finds the first
+   instance of the character pointed to by separator in argstr, and
+   returns a pointer to the next element of argstr, which is the
+   following token in the sequence.  */
+static char *
+pru_consume_separator (char *argstr, const char *separator)
+{
+  char *p;
+
+  p = strchr (argstr, *separator);
+
+  if (p != NULL)
+    *p++ = 0;
+  else
+    as_bad (_("expecting %c near %s"), *separator, argstr);
+  return p;
+}
+
+
+/* The principal argument parsing function which takes a string argstr
+   representing the instruction arguments for insn, and extracts the argument
+   tokens matching parsestr into parsed_args.  */
+static void
+pru_parse_args (pru_insn_infoS *insn ATTRIBUTE_UNUSED, char *argstr,
+		  const char *parsestr, char **parsed_args)
+{
+  char *p;
+  char *end = NULL;
+  int i;
+  p = argstr;
+  i = 0;
+  bfd_boolean terminate = FALSE;
+
+  /* This rest of this function is it too fragile and it mostly works,
+     therefore special case this one.  */
+  if (*parsestr == 0 && argstr != 0)
+    {
+      as_bad (_("too many arguments"));
+      parsed_args[0] = NULL;
+      return;
+    }
+
+  while (p != NULL && !terminate && i < PRU_MAX_INSN_TOKENS)
+    {
+      parsed_args[i] = pru_consume_arg (p, parsestr);
+      ++parsestr;
+      if (*parsestr != '\0')
+	{
+	  p = pru_consume_separator (p, parsestr);
+	  ++parsestr;
+	}
+      else
+	{
+	  /* Check that the argument string has no trailing arguments.  */
+	  /* If we've got a %lo etc relocation, we've zapped the parens with
+	     spaces.  */
+	  if (pru_special_relocation_p (p))
+	    end = strpbrk (p, ",");
+	  else
+	    end = strpbrk (p, " ,");
+
+	  if (end != NULL)
+	    as_bad (_("too many arguments"));
+	}
+
+      if (*parsestr == '\0' || (p != NULL && *p == '\0'))
+	terminate = TRUE;
+      ++i;
+    }
+
+  parsed_args[i] = NULL;
+
+  /* There are no instructions with optional arguments; complain. */
+  if (*parsestr != '\0')
+    as_bad (_("missing argument"));
+}
+
+
+/** Assembler output support.  */
+
+/* Output a normal instruction.  */
+static void
+output_insn (pru_insn_infoS *insn)
+{
+  char *f;
+  pru_insn_relocS *reloc;
+
+  f = frag_more (4);
+  /* This allocates enough space for the instruction
+     and puts it in the current frag.  */
+  md_number_to_chars (f, insn->insn_code, 4);
+  /* Emit debug info.  */
+  dwarf2_emit_insn (4);
+  /* Create any fixups to be acted on later.  */
+  for (reloc = insn->insn_reloc; reloc != NULL; reloc = reloc->reloc_next)
+    fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
+		 &reloc->reloc_expression, reloc->reloc_pcrel,
+		 reloc->reloc_type);
+}
+
+
+/** External interfaces.  */
+
+/* The following functions are called by machine-independent parts of
+   the assembler. */
+int
+md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
+{
+  switch (c)
+    {
+    case 'r':
+      /* Hidden option for self-test mode.  */
+      pru_mode = PRU_MODE_TEST;
+      break;
+    default:
+      return 0;
+      break;
+    }
+
+  return 1;
+}
+
+const char *
+pru_target_format (void)
+{
+  return "elf32-pru";
+}
+
+/* Machine-dependent usage message. */
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream, "	    PRU options: none at the moment\n");
+}
+
+/* This function is called once, at assembler startup time.
+   It should set up all the tables, etc. that the MD part of the
+   assembler will need. */
+void
+md_begin (void)
+{
+  int i;
+  const char *inserted;
+
+  /* Create and fill a hashtable for the PRU opcodes, registers and
+     arguments.  */
+  pru_opcode_hash = hash_new ();
+  pru_reg_hash = hash_new ();
+
+  for (i = 0; i < NUMOPCODES; ++i)
+    {
+      inserted
+	= hash_insert (pru_opcode_hash, pru_opcodes[i].name,
+		       (PTR) & pru_opcodes[i]);
+      if (inserted != NULL)
+	{
+	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
+		   pru_opcodes[i].name, inserted);
+	  /* Probably a memory allocation problem?  Give up now.  */
+	  as_fatal (_("Broken assembler.  No assembly attempted."));
+	}
+    }
+
+  for (i = 0; i < pru_num_regs; ++i)
+    {
+      inserted
+	= hash_insert (pru_reg_hash, pru_regs[i].name,
+		       (PTR) & pru_regs[i]);
+      if (inserted != NULL)
+	{
+	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
+		   pru_regs[i].name, inserted);
+	  /* Probably a memory allocation problem?  Give up now.  */
+	  as_fatal (_("Broken assembler.  No assembly attempted."));
+	}
+
+    }
+
+  /* Initialize the alignment data.  */
+  pru_current_align_seg = now_seg;
+  pru_last_label = NULL;
+  pru_current_align = 0;
+}
+
+
+/* Assembles a single line of PRU assembly language.  */
+void
+md_assemble (char *op_str)
+{
+  char *argstr;
+  char *op_strdup = NULL;
+  pru_insn_infoS thisinsn;
+  pru_insn_infoS *insn = &thisinsn;
+
+  /* Make sure we are aligned on a 4-byte boundary.  */
+  if (pru_current_align < 2)
+    pru_align (2, NULL, pru_last_label);
+  else if (pru_current_align > 2)
+    pru_current_align = 2;
+  pru_last_label = NULL;
+
+  /* We don't want to clobber to op_str
+     because we want to be able to use it in messages.  */
+  op_strdup = strdup (op_str);
+  insn->insn_tokens[0] = strtok (op_strdup, " ");
+  argstr = strtok (NULL, "");
+
+  /* Assemble the opcode.  */
+  insn->insn_pru_opcode = pru_opcode_lookup (insn->insn_tokens[0]);
+  insn->insn_reloc = NULL;
+
+  if (insn->insn_pru_opcode != NULL)
+    {
+      const char *argsfmt = insn->insn_pru_opcode->args;
+      const char **argtk = &insn->insn_tokens[1];
+      const char *argp;
+
+      /* Set the opcode for the instruction.  */
+      insn->insn_code = insn->insn_pru_opcode->match;
+
+      if (pru_mode == PRU_MODE_TEST)
+	{
+	  /* Add the "expected" instruction parameter used for validation */
+	  argsfmt = malloc (strlen(argsfmt) + 3);
+	  sprintf ((char *)argsfmt, "%s,E", insn->insn_pru_opcode->args);
+        }
+      pru_parse_args (insn, argstr, argsfmt,
+                      (char **) &insn->insn_tokens[1]);
+
+      for (argp = argsfmt; !had_errors() && *argp && *argtk; ++argp)
+	{
+	  gas_assert (argtk <= &insn->insn_tokens[PRU_MAX_INSN_TOKENS]);
+
+	  switch (*argp)
+	    {
+	    case ',':
+	      continue;
+
+	    case 'd':
+	      pru_assemble_arg_d (insn, *argtk++);
+	      continue;
+	    case 'D':
+	      pru_assemble_arg_D (insn, *argtk++);
+	      continue;
+	    case 's':
+	      pru_assemble_arg_s (insn, *argtk++);
+	      continue;
+	    case 'S':
+	      pru_assemble_arg_S (insn, *argtk++);
+	      continue;
+	    case 'b':
+	      pru_assemble_arg_b (insn, *argtk++);
+	      continue;
+	    case 'j':
+	      pru_assemble_arg_j (insn, *argtk++);
+	      continue;
+	    case 'W':
+	      pru_assemble_arg_W (insn, *argtk++);
+	      continue;
+	    case 'o':
+	      pru_assemble_arg_o (insn, *argtk++);
+	      continue;
+	    case 'l':
+	      pru_assemble_arg_l (insn, *argtk++);
+	      continue;
+	    case 'n':
+	      pru_assemble_arg_n (insn, *argtk++);
+	      continue;
+	    case 'c':
+	      pru_assemble_arg_c (insn, *argtk++);
+	      continue;
+	    case 'w':
+	      pru_assemble_arg_w (insn, *argtk++);
+	      continue;
+	    case 'x':
+	      pru_assemble_arg_x (insn, *argtk++);
+	      continue;
+
+	    case 'E':
+	      pru_check_assembly (insn->insn_code, *argtk++);
+	    default:
+	      BAD_CASE (*argp);
+	    }
+	}
+
+      if (*argp && !had_errors())
+	as_bad (_("missing argument"));
+
+      if (!had_errors())
+	output_insn (insn);
+
+      if (pru_mode == PRU_MODE_TEST)
+	free ((char *)argsfmt);
+    }
+  else
+    /* Unrecognised instruction - error.  */
+    as_bad (_("unrecognised instruction %s"), insn->insn_tokens[0]);
+
+  /* Don't leak memory.  */
+  pru_insn_reloc_destroy (insn->insn_reloc);
+  free (op_strdup);
+}
+
+/* Round up section size.  */
+valueT
+md_section_align (asection *seg, valueT addr)
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+/* Implement tc_fix_adjustable.  */
+int
+pru_fix_adjustable (fixS *fixp)
+{
+  if (fixp->fx_addsy == NULL)
+    return 1;
+
+#ifdef OBJ_ELF
+  /* Prevent all adjustments to global symbols.  */
+  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
+      && (S_IS_EXTERNAL (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)))
+    return 0;
+#endif
+  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 0;
+
+  /* Preserve relocations against symbols with function type.  */
+  if (symbol_get_bfdsym (fixp->fx_addsy)->flags & BSF_FUNCTION)
+    return 0;
+
+  return 1;
+}
+
+/* The function tc_gen_reloc creates a relocation structure for the
+   fixup fixp, and returns a pointer to it.  This structure is passed
+   to bfd_install_relocation so that it can be written to the object
+   file for linking.  */
+arelent *
+tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
+{
+  arelent *reloc = (arelent *) xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->addend = fixp->fx_offset;  /* fixp->fx_addnumber; */
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("can't represent relocation type %s"),
+		    bfd_get_reloc_code_name (fixp->fx_r_type));
+
+      /* Set howto to a garbage value so that we can keep going.  */
+      reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
+      gas_assert (reloc->howto != NULL);
+    }
+  return reloc;
+}
+
+long
+md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
+{
+  return fixP->fx_where + fixP->fx_frag->fr_address;
+}
+
+/* Called just before the assembler exits.  */
+void
+md_end ()
+{
+  /* FIXME - not yet implemented */
+}
+
+/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
+   Otherwise we have no need to default values of symbols.  */
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+/* Implement tc_frob_label.  */
+void
+pru_frob_label (symbolS *lab)
+{
+  /* Emit dwarf information.  */
+  dwarf2_emit_label (lab);
+
+  /* Update the label's address with the current output pointer.  */
+  symbol_set_frag (lab, frag_now);
+  S_SET_VALUE (lab, (valueT) frag_now_fix ());
+
+  /* Record this label for future adjustment after we find out what
+     kind of data it references, and the required alignment therewith.  */
+  pru_last_label = lab;
+}
+
+static inline char *
+skip_space (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    ++s;
+  return s;
+}
+
+/* Parse special CONS expression: pmem (expression). Idea from AVR.
+ 
+   Used to catch and mark code (program memory) in constant expression
+   relocations. Return non-zero for program memory. */
+
+int
+pru_parse_cons_expression (expressionS *exp, int nbytes)
+{
+  int is_pmem = FALSE;
+  char *tmp;
+
+  tmp = input_line_pointer = skip_space (input_line_pointer);
+
+  if (nbytes == 4)
+    {
+      const char *pmem_str = "%pmem";
+      int len = strlen (pmem_str);
+
+      if (strncasecmp (input_line_pointer, pmem_str, len) == 0)
+	{
+	  input_line_pointer = skip_space (input_line_pointer + len);
+
+	  if (*input_line_pointer == '(')
+	    {
+	      input_line_pointer = skip_space (input_line_pointer + 1);
+	      is_pmem = TRUE;
+	      expression (exp);
+
+	      if (*input_line_pointer == ')')
+		++input_line_pointer;
+	      else
+		{
+		  as_bad (_("`)' required"));
+		  is_pmem = FALSE;
+		}
+
+	      return is_pmem;
+	    }
+
+	  input_line_pointer = tmp;
+	}
+    }
+
+  expression (exp);
+
+  return is_pmem;
+}
+
+/* Implement TC_CONS_FIX_NEW.  */
+void
+pru_cons_fix_new (fragS *frag, int where, unsigned int nbytes,
+		    expressionS *exp, const int is_pmem)
+{
+  bfd_reloc_code_real_type r;
+
+  switch (nbytes | (!!is_pmem << 8))
+    {
+    case 1 | (0 << 8): r = BFD_RELOC_8; break;
+    case 2 | (0 << 8): r = BFD_RELOC_16; break;
+    case 4 | (0 << 8): r = BFD_RELOC_32; break;
+    case 8 | (0 << 8): r = BFD_RELOC_64; break;
+    case 2 | (1 << 8): r = BFD_RELOC_PRU_16_PMEM; break;
+    case 4 | (1 << 8): r = BFD_RELOC_PRU_32_PMEM; break;
+    default:
+      as_bad (_("illegal %s relocation size: %d"),
+	      is_pmem ? "text" : "data", nbytes);
+      return;
+    }
+
+  fix_new_exp (frag, where, (int) nbytes, exp, 0, r);
+}
+
+/* Implement tc_regname_to_dw2regnum, to convert REGNAME to a DWARF-2
+   register number.  */
+int
+pru_regname_to_dw2regnum (char *regname)
+{
+  struct pru_reg *r = pru_reg_lookup (regname);
+  if (r == NULL)
+    return -1;
+  return r->index;
+}
+
+/* Implement tc_cfi_frame_initial_instructions, to initialize the DWARF-2
+   unwind information for this procedure.  */
+void
+pru_frame_initial_instructions (void)
+{
+  cfi_add_CFA_def_cfa (28, 0);
+}
diff --git a/gas/config/tc-pru.h b/gas/config/tc-pru.h
new file mode 100644
index 0000000..f4c4121
--- /dev/null
+++ b/gas/config/tc-pru.h
@@ -0,0 +1,91 @@
+/* Definitions for TI PRU assembler.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef TC_PRU
+#define TC_PRU
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+/* Words are big enough to hold addresses.  */
+#define WORKING_DOT_WORD	1
+
+#ifdef OBJ_ELF
+extern const char *pru_target_format (void);
+#define TARGET_FORMAT  pru_target_format ()
+#define TARGET_ARCH    bfd_arch_pru
+#endif
+
+/* A PRU instruction consists of tokens and separator characters
+   the tokens are things like the instruction name (add, or jmp etc),
+   the register indices ($5, $7 etc), and constant expressions. The
+   separator characters are commas, brackets and space.
+   The instruction name is always separated from other tokens by a space
+   The maximum number of tokens in an instruction is 6 (the instruction name,
+   4 arguments, and a 4th string representing the expected instructin opcode
+   after assembly. The latter is only used when the assemble is running in
+   self test mode, otherwise its presence will generate an error.  */
+#define PRU_MAX_INSN_TOKENS	7
+
+/* There are no machine-specific operands so we #define this to nothing.  */
+#define md_operand(x)
+
+/* Function prototypes exported to rest of GAS.  */
+extern void md_assemble (char *op_str);
+extern void md_end (void);
+extern void md_begin (void);
+
+#define tc_fix_adjustable(fixp) pru_fix_adjustable (fixp)
+extern int pru_fix_adjustable (struct fix *);
+
+#define tc_frob_label(lab)	     pru_frob_label (lab)
+extern void pru_frob_label (symbolS *);
+
+extern void md_convert_frag (bfd * headers, segT sec, fragS * fragP);
+
+#define DIFF_EXPR_OK
+
+/* Nios2 ABI doesn't have 32-bit PCREL relocation, and, as relocations for
+   CFI information will be in section other than .text, we can't use PC-biased
+   relocs.  */
+#define CFI_DIFF_EXPR_OK 0
+
+#define TC_PARSE_CONS_RETURN_TYPE int
+#define TC_PARSE_CONS_RETURN_NONE 0
+
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) \
+	pru_parse_cons_expression (EXP, NBYTES)
+extern int pru_parse_cons_expression (expressionS *exp, int size);
+
+#define TC_CONS_FIX_NEW pru_cons_fix_new
+extern void pru_cons_fix_new (struct frag *frag, int where,
+				unsigned int nbytes, struct expressionS *exp,
+				const int is_pmem);
+
+/* We want .cfi_* pseudo-ops for generating unwind info.  */
+#define TARGET_USE_CFIPOP 1
+#define DWARF2_DEFAULT_RETURN_COLUMN 31
+#define DWARF2_CIE_DATA_ALIGNMENT (-4)
+#define tc_regname_to_dw2regnum pru_regname_to_dw2regnum
+extern int pru_regname_to_dw2regnum (char *regname);
+#define tc_cfi_frame_initial_instructions  pru_frame_initial_instructions
+extern void pru_frame_initial_instructions (void);
+
+#endif /* TC_PRU */
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 7d5afa9..32bbb88 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -378,6 +378,8 @@ case ${generic_target} in
   ppc-*-kaos*)				fmt=elf ;;
   ppc-*-lynxos*)			fmt=elf em=lynx ;;
 
+  pru-*-*)				fmt=elf ;;
+
   s390-*-linux-*)			fmt=elf em=linux ;;
   s390-*-tpf*)				fmt=elf ;;
 
diff --git a/gas/po/POTFILES.in b/gas/po/POTFILES.in
index dc63835..03db21d 100644
--- a/gas/po/POTFILES.in
+++ b/gas/po/POTFILES.in
@@ -129,6 +129,8 @@ config/tc-pj.c
 config/tc-pj.h
 config/tc-ppc.c
 config/tc-ppc.h
+config/tc-pru.c
+config/tc-pru.h
 config/tc-rl78.c
 config/tc-rl78.h
 config/tc-rx.c
diff --git a/gas/testsuite/gas/pru/alu.d b/gas/testsuite/gas/pru/alu.d
new file mode 100644
index 0000000..e984ec7
--- /dev/null
+++ b/gas/testsuite/gas/pru/alu.d
@@ -0,0 +1,32 @@
+#objdump: -dr --prefix-addresses --show-raw-insn
+#name: PRU ALU
+
+# Test the ALU instructions
+
+.*: +file format elf32-pru
+
+Disassembly of section .text:
+0+0000 <[^>]*> 00e4e4e4 	add	r4, r4, r4
+0+0004 <[^>]*> 01ffe4e4 	add	r4, r4, 255
+0+0008 <[^>]*> 0100e4e4 	add	r4, r4, 0
+0+000c <[^>]*> 0100e4e4 	add	r4, r4, 0
+0+0010 <[^>]*> 0100a424 	add	r4.b1, r4.w1, 0
+0+0014 <[^>]*> 00634221 	add	r1.b1, r2.b2, r3.b3
+0+0018 <[^>]*> 02634221 	adc	r1.b1, r2.b2, r3.b3
+0+001c <[^>]*> 03634221 	adc	r1.b1, r2.b2, 99
+0+0020 <[^>]*> 00e0e0e0 	add	r0, r0, r0
+0+0024 <[^>]*> 02e0e0e0 	adc	r0, r0, r0
+0+0028 <[^>]*> 050affe1 	sub	r1, r31, 10
+0+002c <[^>]*> 070affe1 	suc	r1, r31, 10
+0+0030 <[^>]*> 090affff 	lsl	r31, r31, 10
+0+0034 <[^>]*> 0b0affff 	lsr	r31, r31, 10
+0+0038 <[^>]*> 0d0a70f0 	rsb	r16, r16.b3, 10
+0+003c <[^>]*> 0f0a70f0 	rsc	r16, r16.b3, 10
+0+0040 <[^>]*> 11aa61a1 	and	r1.w1, r1.b3, 170
+0+0044 <[^>]*> 13aa61a1 	or	r1.w1, r1.b3, 170
+0+0048 <[^>]*> 15aa61a1 	xor	r1.w1, r1.b3, 170
+0+004c <[^>]*> 1700e1e2 	not	r2, r1
+0+0050 <[^>]*> 18e2e1e1 	min	r1, r1, r2
+0+0054 <[^>]*> 1ac3e2e1 	max	r1, r2, r3.w2
+0+0058 <[^>]*> 1cc3e2e1 	clr	r1, r2, r3.w2
+0+005c <[^>]*> 1f0ce2e1 	set	r1, r2, 12
diff --git a/gas/testsuite/gas/pru/alu.s b/gas/testsuite/gas/pru/alu.s
new file mode 100644
index 0000000..01d8c50
--- /dev/null
+++ b/gas/testsuite/gas/pru/alu.s
@@ -0,0 +1,30 @@
+# Source file used to test the ALU class of instructions.
+
+foo:
+	# Test various addressing modes
+	add	r4, r4, r4
+	add	r4, r4, 0xff
+	add	r4, r4, 0
+	add	r4, r4, 0
+	add	r4.b1, r4.w1, 0
+	add	r1.b1, r2.b2, r3.b3
+	adc	r1.b1, r2.b2, r3.b3
+	adc	r1.b1, r2.b2, 101-2
+
+	# Test ALU opcodes
+	add	r0, r0, r0
+	adc	r0, r0, r0
+	sub	r1, r31, 10
+	suc	r1, r31, 10
+	lsl	r31, r31, 10
+	lsr	r31, r31, 10
+	rsb	r16, r16.b3, 10
+	rsc	r16, r16.b3, 10
+	and	r1.w1, r1.b3, 0xaa
+	or	r1.w1, r1.b3, 0xaa
+	xor	r1.w1, r1.b3, 0xaa
+	not	r2, r1
+	min	r1, r1, r2
+	max	r1, r2, r3.w2
+	clr	r1, r2, r3.w2
+	set	r1, r2, 12
diff --git a/gas/testsuite/gas/pru/branch.d b/gas/testsuite/gas/pru/branch.d
new file mode 100644
index 0000000..7125040
--- /dev/null
+++ b/gas/testsuite/gas/pru/branch.d
@@ -0,0 +1,35 @@
+#objdump: -dr --prefix-addresses --show-raw-insn
+#name: PRU branch
+
+# Test the branch instructions
+
+.*: +file format elf32-pru
+
+Disassembly of section .text:
+0+0000 <[^>]*> 20ea0000 	jmp	r10
+0+0004 <[^>]*> 208a0000 	jmp	r10.w0
+0+0008 <[^>]*> 21004000 	jmp	00000100 <[^>]*>
+0+000c <[^>]*> 22ca00f6 	jal	r22, r10.w2
+0+0010 <[^>]*> 230000f7 	jal	r23, 00000000 <[^>]*>
+0+0014 <[^>]*> 23ffffb7 	jal	r23.w1, 0003fffc <[^>]*>
+0+0018 <[^>]*> 6100f712 	qbgt	00000060 <L5>, r23, 0
+0+001c <[^>]*> 71ff5711 	qbge	00000060 <L5>, r23.b2, 255
+0+0020 <[^>]*> 4820b610 	qblt	00000060 <L5>, r22.w1, r0.b1
+0+0024 <[^>]*> 5821000f 	qble	00000060 <L5>, r0.b0, r1.b1
+0+0028 <[^>]*> 5003410e 	qbeq	00000060 <L5>, r1.b2, r3.b0
+0+002c <[^>]*> 68f6f50d 	qbne	00000060 <L5>, r21, r22
+0+0030 <[^>]*> 7800000c 	qba	00000060 <L5>
+0+0034 <[^>]*> d0edec0b 	qbbs	00000060 <L5>, r12, r13
+0+0038 <[^>]*> d105ec0a 	qbbs	00000060 <L5>, r12, 5
+0+003c <[^>]*> c8edec09 	qbbc	00000060 <L5>, r12, r13
+0+0040 <[^>]*> c905ec08 	qbbc	00000060 <L5>, r12, 5
+0+0044 <[^>]*> 6700f7f2 	qbgt	0000000c <L2>, r23, 0
+0+0048 <[^>]*> 77ff57f1 	qbge	0000000c <L2>, r23.b2, 255
+0+004c <[^>]*> 4e20b6f0 	qblt	0000000c <L2>, r22.w1, r0.b1
+0+0050 <[^>]*> 5e2100ef 	qble	0000000c <L2>, r0.b0, r1.b1
+0+0054 <[^>]*> 560341ee 	qbeq	0000000c <L2>, r1.b2, r3.b0
+0+0058 <[^>]*> 6ef6f5ed 	qbne	0000000c <L2>, r21, r22
+0+005c <[^>]*> 7e0000ec 	qba	0000000c <L2>
+0+0060 <[^>]*> d6edeceb 	qbbs	0000000c <L2>, r12, r13
+0+0064 <[^>]*> d705ecea 	qbbs	0000000c <L2>, r12, 5
+0+0068 <[^>]*> ceedece9 	qbbc	0000000c <L2>, r12, r13
diff --git a/gas/testsuite/gas/pru/branch.s b/gas/testsuite/gas/pru/branch.s
new file mode 100644
index 0000000..ab43c74
--- /dev/null
+++ b/gas/testsuite/gas/pru/branch.s
@@ -0,0 +1,42 @@
+# Source file used to test the miscellaneous instructions.
+
+foo:
+L1:
+	jmp	r10
+	jmp	r10.w0
+	jmp	0x100
+
+L2:
+	jal	r22, r10.w2
+	jal	r23, 0
+	jal	r23.w1, 0x3fffc
+
+	# relative branches - forward jump
+L3:
+	qbgt	L5, r23, 0
+	qbge	L5, r23.b2, 255
+	qblt	L5, r22.w1, r0.b1
+	qble	L5, r0.b0, r1.b1
+	qbeq	L5, r1.b2, r3.b0
+	qbne	L5, r21, r22
+	qba	L5
+
+	qbbs	L5, r12, r13
+	qbbs	L5, r12, 5
+	qbbc	L5, r12, r13
+	qbbc	L5, r12, 5
+
+	# relative branches - backward jump
+L4:
+	qbgt	L2, r23, 0
+	qbge	L2, r23.b2, 255
+	qblt	L2, r22.w1, r0.b1
+	qble	L2, r0.b0, r1.b1
+	qbeq	L2, r1.b2, r3.b0
+	qbne	L2, r21, r22
+	qba	L2
+
+L5:
+	qbbs	L2, r12, r13
+	qbbs	L2, r12, 5
+	qbbc	L2, r12, r13
diff --git a/gas/testsuite/gas/pru/illegal.l b/gas/testsuite/gas/pru/illegal.l
new file mode 100644
index 0000000..64de14b
--- /dev/null
+++ b/gas/testsuite/gas/pru/illegal.l
@@ -0,0 +1,5 @@
+.*illegal.s: Assembler messages:
+.*illegal.s:5: Error: unknown register r56
+.*illegal.s:8: Error: unrecognised instruction fop
+.*illegal.s:10: Error: too many arguments
+.*illegal.s:11: Error: too many arguments
diff --git a/gas/testsuite/gas/pru/illegal.s b/gas/testsuite/gas/pru/illegal.s
new file mode 100644
index 0000000..1571f74
--- /dev/null
+++ b/gas/testsuite/gas/pru/illegal.s
@@ -0,0 +1,11 @@
+# Source file used to test illegal operands.
+
+foo:
+# Illegal registers
+	add r56,r4,r5
+	add r4,r0,r2
+# Illegal opcodes
+	fop r3,r4,r5
+# Extra operands
+	nop Crapola
+	add r2, r2, r2, r4
diff --git a/gas/testsuite/gas/pru/ldst.d b/gas/testsuite/gas/pru/ldst.d
new file mode 100644
index 0000000..7e44b6d
--- /dev/null
+++ b/gas/testsuite/gas/pru/ldst.d
@@ -0,0 +1,33 @@
+#objdump: -dr --prefix-addresses --show-raw-insn
+#name: PRU load-store
+
+# Test the load/store operations
+
+.*: +file format elf32-pru
+
+Disassembly of section .text:
+0+0000 <[^>]*> 240000f0 	ldi	r16, 0
+0+0004 <[^>]*> 24fffff0 	ldi	r16, 65535
+0+0008 <[^>]*> 2401fff0 	ldi	r16, 511
+0+000c <[^>]*> f0611e20 	lbbo	r0.b1, r30, r1.b3, 1
+0+0010 <[^>]*> fe41bec0 	lbbo	r0.b2, r30, r1.b2, 124
+0+0014 <[^>]*> f1ff1e60 	lbbo	r0.b3, r30, 255, 1
+0+0018 <[^>]*> f1011e80 	lbbo	r0.b0, r30, 1, 2
+0+001c <[^>]*> fb005e00 	lbbo	r0.b0, r30, 0, 85
+0+0020 <[^>]*> fea1d912 	lbbo	r18.b0, r25, r1.w1, r0.b0
+0+0024 <[^>]*> ff65d992 	lbbo	r18.b0, r25, 101, r0.b1
+0+0028 <[^>]*> fee1f992 	lbbo	r18.b0, r25, r1, r0.b3
+0+002c <[^>]*> e0611e20 	sbbo	r0.b1, r30, r1.b3, 1
+0+0030 <[^>]*> ee41bec0 	sbbo	r0.b2, r30, r1.b2, 124
+0+0034 <[^>]*> e1ff1e60 	sbbo	r0.b3, r30, 255, 1
+0+0038 <[^>]*> e1011e80 	sbbo	r0.b0, r30, 1, 2
+0+003c <[^>]*> eb005e00 	sbbo	r0.b0, r30, 0, 85
+0+0040 <[^>]*> eee1d912 	sbbo	r18.b0, r25, r1, r0.b0
+0+0044 <[^>]*> ef65d992 	sbbo	r18.b0, r25, 101, r0.b1
+0+0048 <[^>]*> eee1f992 	sbbo	r18.b0, r25, r1, r0.b3
+0+004c <[^>]*> 9105608a 	lbco	r10.b0, 0, 5, 8
+0+0050 <[^>]*> 90ab618a 	lbco	r10.b0, 1, r11.w1, 8
+0+0054 <[^>]*> 91057f8a 	lbco	r10.b0, 31, 5, 8
+0+0058 <[^>]*> 8105608a 	sbco	r10.b0, 0, 5, 8
+0+005c <[^>]*> 80ab618a 	sbco	r10.b0, 1, r11.w1, 8
+0+0060 <[^>]*> 81057f8a 	sbco	r10.b0, 31, 5, 8
diff --git a/gas/testsuite/gas/pru/ldst.s b/gas/testsuite/gas/pru/ldst.s
new file mode 100644
index 0000000..96fdd15
--- /dev/null
+++ b/gas/testsuite/gas/pru/ldst.s
@@ -0,0 +1,37 @@
+# Source file used to test the load/store instructions.
+
+foo:
+	# immediate load
+	ldi	r16, 0
+	ldi	r16, 0xffff
+	ldi	r16, 511
+
+	# load
+	lbbo	r0.b1, r30, r1.b3, 1
+	lbbo	r0.b2, r30, r1.b2, 124
+	lbbo	r0.b3, r30, 255, 1
+	lbbo	r0, r30, 1, 2
+	lbbo	r0, r30, 0, 0x55
+	lbbo	r18, r25, r1.w1, r0.b0
+	lbbo	r18, r25, 101, r0.b1
+	lbbo	r18, r25, r1, r0.b3
+
+	# store
+	sbbo	r0.b1, r30, r1.b3, 1
+	sbbo	r0.b2, r30, r1.b2, 124
+	sbbo	r0.b3, r30, 255, 1
+	sbbo	r0, r30, 1, 2
+	sbbo	r0, r30, 0, 0x55
+	sbbo	r18, r25, r1, r0.b0
+	sbbo	r18, r25, 101, r0.b1
+	sbbo	r18, r25, r1, r0.b3
+
+	# load with constant table address
+	lbco	r10, 0, 5, 8
+	lbco	r10, 1, r11.w1, 8
+	lbco	r10, 31, 5, 8
+
+	# store with constant table address
+	sbco	r10, 0, 5, 8
+	sbco	r10, 1, r11.w1, 8
+	sbco	r10, 31, 5, 8
diff --git a/gas/testsuite/gas/pru/misc.d b/gas/testsuite/gas/pru/misc.d
new file mode 100644
index 0000000..40a116e
--- /dev/null
+++ b/gas/testsuite/gas/pru/misc.d
@@ -0,0 +1,12 @@
+#objdump: -dr --prefix-addresses --show-raw-insn
+#name: PRU misc
+
+# Test the miscellaneous instruction
+
+.*: +file format elf32-pru
+
+Disassembly of section .text:
+0+0000 <[^>]*> 2a000000 	halt
+0+0004 <[^>]*> 3e800000 	slp	1
+0+0008 <[^>]*> 3e000000 	slp	0
+
diff --git a/gas/testsuite/gas/pru/misc.s b/gas/testsuite/gas/pru/misc.s
new file mode 100644
index 0000000..cfe4d88
--- /dev/null
+++ b/gas/testsuite/gas/pru/misc.s
@@ -0,0 +1,6 @@
+# Source file used to test the miscellaneous instructions.
+
+foo:
+	halt
+	slp	1
+	slp	0
diff --git a/gas/testsuite/gas/pru/pru.exp b/gas/testsuite/gas/pru/pru.exp
new file mode 100644
index 0000000..ec70f3a
--- /dev/null
+++ b/gas/testsuite/gas/pru/pru.exp
@@ -0,0 +1,25 @@
+# Copyright (C) 2014 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  
+
+#
+# Some generic PRU tests
+#
+
+if { [istarget pru-*-*] } {
+    run_dump_tests [lsort [glob -nocomplain $srcdir/$subdir/*.d]]
+    
+    run_list_test "illegal" ""
+}
diff --git a/gas/testsuite/gas/pru/pseudo.d b/gas/testsuite/gas/pru/pseudo.d
new file mode 100644
index 0000000..8271744
--- /dev/null
+++ b/gas/testsuite/gas/pru/pseudo.d
@@ -0,0 +1,10 @@
+#objdump: -dr --prefix-addresses --show-raw-insn
+#name: PRU pseudo
+
+# Test the pseudo instruction
+
+.*: +file format elf32-pru
+
+Disassembly of section .text:
+0+0000 <[^>]*> 1300e2e1 	mov	r1, r2
+0+0004 <[^>]*> 12e0e0e0 	nop
diff --git a/gas/testsuite/gas/pru/pseudo.s b/gas/testsuite/gas/pru/pseudo.s
new file mode 100644
index 0000000..92b6a66
--- /dev/null
+++ b/gas/testsuite/gas/pru/pseudo.s
@@ -0,0 +1,5 @@
+# Source file used to test the pseudo instructions.
+
+foo:
+	mov	r1, r2
+	nop
diff --git a/gas/testsuite/gas/pru/xfr.d b/gas/testsuite/gas/pru/xfr.d
new file mode 100644
index 0000000..239a0cc
--- /dev/null
+++ b/gas/testsuite/gas/pru/xfr.d
@@ -0,0 +1,44 @@
+#objdump: -dr --prefix-addresses --show-raw-insn
+#name: PRU xfr
+
+# Test the XFR class of instruction
+
+.*: +file format elf32-pru
+
+Disassembly of section .text:
+0+0000 <[^>]*> 2eff8002 	zero	r2.b0, 1
+0+0004 <[^>]*> 2eff81d7 	zero	r23.b2, 4
+0+0008 <[^>]*> 2effbd80 	zero	r0.b0, 124
+0+000c <[^>]*> 2eff0002 	fill	r2.b0, 1
+0+0010 <[^>]*> 2eff01b7 	fill	r23.b1, 4
+0+0014 <[^>]*> 2eff3d80 	fill	r0.b0, 124
+0+0018 <[^>]*> 2e80000a 	xin	0, r10.b0, 1
+0+001c <[^>]*> 2e803daa 	xin	0, r10.b1, 124
+0+0020 <[^>]*> 2efe806a 	xin	253, r10.b3, 1
+0+0024 <[^>]*> 2efebdca 	xin	253, r10.b2, 124
+0+0028 <[^>]*> 2eaaaa0c 	xin	85, r12.b0, 85
+0+002c <[^>]*> 2f00000a 	xout	0, r10.b0, 1
+0+0030 <[^>]*> 2f003daa 	xout	0, r10.b1, 124
+0+0034 <[^>]*> 2f7e806a 	xout	253, r10.b3, 1
+0+0038 <[^>]*> 2f7ebdca 	xout	253, r10.b2, 124
+0+003c <[^>]*> 2f2aaa0c 	xout	85, r12.b0, 85
+0+0040 <[^>]*> 2f80000a 	xchg	0, r10.b0, 1
+0+0044 <[^>]*> 2f803daa 	xchg	0, r10.b1, 124
+0+0048 <[^>]*> 2ffe806a 	xchg	253, r10.b3, 1
+0+004c <[^>]*> 2ffebdca 	xchg	253, r10.b2, 124
+0+0050 <[^>]*> 2faaaa0c 	xchg	85, r12.b0, 85
+0+0054 <[^>]*> 2e80400a 	sxin	0, r10.b0, 1
+0+0058 <[^>]*> 2e807daa 	sxin	0, r10.b1, 124
+0+005c <[^>]*> 2efec06a 	sxin	253, r10.b3, 1
+0+0060 <[^>]*> 2efefdca 	sxin	253, r10.b2, 124
+0+0064 <[^>]*> 2eaaea0c 	sxin	85, r12.b0, 85
+0+0068 <[^>]*> 2f00400a 	sxout	0, r10.b0, 1
+0+006c <[^>]*> 2f007daa 	sxout	0, r10.b1, 124
+0+0070 <[^>]*> 2f7ec06a 	sxout	253, r10.b3, 1
+0+0074 <[^>]*> 2f7efdca 	sxout	253, r10.b2, 124
+0+0078 <[^>]*> 2f2aea0c 	sxout	85, r12.b0, 85
+0+007c <[^>]*> 2f80400a 	sxchg	0, r10.b0, 1
+0+0080 <[^>]*> 2f807daa 	sxchg	0, r10.b1, 124
+0+0084 <[^>]*> 2ffec06a 	sxchg	253, r10.b3, 1
+0+0088 <[^>]*> 2ffefdca 	sxchg	253, r10.b2, 124
+0+008c <[^>]*> 2faaea0c 	sxchg	85, r12.b0, 85
diff --git a/gas/testsuite/gas/pru/xfr.s b/gas/testsuite/gas/pru/xfr.s
new file mode 100644
index 0000000..875e1ca
--- /dev/null
+++ b/gas/testsuite/gas/pru/xfr.s
@@ -0,0 +1,52 @@
+# Source file used to test the XFR-class of instructions.
+
+foo:
+	# register clear and fill
+	zero	r2, 1
+	zero	r23.b2, 4
+	zero	r0, 124
+	fill	r2, 1
+	fill	r23.b1, 4
+	fill	r0, 124
+
+	# XIN
+	xin	0, r10, 1
+	xin	0, r10.b1, 124
+	xin	253, r10.b3, 1
+	xin	253, r10.b2, 124
+	xin	85, r12.b0, 85
+
+	# XOUT
+	xout	0, r10, 1
+	xout	0, r10.b1, 124
+	xout	253, r10.b3, 1
+	xout	253, r10.b2, 124
+	xout	85, r12.b0, 85
+
+	# XCHG
+	xchg	0, r10, 1
+	xchg	0, r10.b1, 124
+	xchg	253, r10.b3, 1
+	xchg	253, r10.b2, 124
+	xchg	85, r12.b0, 85
+
+	# SXIN
+	sxin	0, r10, 1
+	sxin	0, r10.b1, 124
+	sxin	253, r10.b3, 1
+	sxin	253, r10.b2, 124
+	sxin	85, r12.b0, 85
+
+	# SXOUT
+	sxout	0, r10, 1
+	sxout	0, r10.b1, 124
+	sxout	253, r10.b3, 1
+	sxout	253, r10.b2, 124
+	sxout	85, r12.b0, 85
+
+	# XCHG
+	sxchg	0, r10, 1
+	sxchg	0, r10.b1, 124
+	sxchg	253, r10.b3, 1
+	sxchg	253, r10.b2, 124
+	sxchg	85, r12.b0, 85
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 1b653b5..3e5db5e 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -279,6 +279,7 @@ extern int print_insn_ns32k		(bfd_vma, disassemble_info *);
 extern int print_insn_or1k		(bfd_vma, disassemble_info *);
 extern int print_insn_pdp11		(bfd_vma, disassemble_info *);
 extern int print_insn_pj		(bfd_vma, disassemble_info *);
+extern int print_insn_pru		(bfd_vma, disassemble_info *);
 extern int print_insn_rs6000		(bfd_vma, disassemble_info *);
 extern int print_insn_s390		(bfd_vma, disassemble_info *);
 extern int print_insn_sh		(bfd_vma, disassemble_info *);
diff --git a/include/elf/common.h b/include/elf/common.h
index e8ae3ac..efb7681 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -391,6 +391,9 @@
 /* NIOS magic number - no EABI available.  */
 #define EM_NIOS32		0xFEBB
 
+/* PRU magic number */
+#define EM_PRU			0xFEBC
+
 #define EM_CYGNUS_MEP		0xF00D  /* Toshiba MeP */
 
 #define EM_MOXIE                0xFEED  /* Moxie */
diff --git a/include/elf/pru.h b/include/elf/pru.h
new file mode 100644
index 0000000..05f8c76
--- /dev/null
+++ b/include/elf/pru.h
@@ -0,0 +1,54 @@
+/* TI PRU ELF support for BFD.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* This file holds definitions specific to the TI PRU ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_PRU_H
+#define _ELF_PRU_H
+
+#include "elf/reloc-macros.h"
+
+/* The order of these numbers must match the order in
+   the elf_pru_howto_table_rel table for the lookup
+   function to work properly.  */
+
+START_RELOC_NUMBERS (elf_pru_reloc_type)
+  RELOC_NUMBER (R_PRU_NONE,	    0)
+  RELOC_NUMBER (R_PRU_U8,	    1)
+  RELOC_NUMBER (R_PRU_U16,	    2)
+  RELOC_NUMBER (R_PRU_IMM5,	    3)
+  RELOC_NUMBER (R_PRU_HI16,	    4)
+  RELOC_NUMBER (R_PRU_LO16,	    5)
+  RELOC_NUMBER (R_PRU_U16_PMEMIMM,  6)
+  RELOC_NUMBER (R_PRU_S10_PCREL,    7)
+  RELOC_NUMBER (R_PRU_32_PMEM,	    8)
+  RELOC_NUMBER (R_PRU_16_PMEM,	    9)
+  RELOC_NUMBER (R_PRU_BFD_RELOC_32, 10)
+  RELOC_NUMBER (R_PRU_BFD_RELOC_16, 11)
+  RELOC_NUMBER (R_PRU_BFD_RELOC_8,  12)
+  RELOC_NUMBER (R_PRU_ILLEGAL,	    13)
+END_RELOC_NUMBERS (R_PRU_maxext)
+
+/* Processor-specific section flags.  */
+
+#endif /* _ELF_PRU_H */
diff --git a/include/opcode/pru.h b/include/opcode/pru.h
new file mode 100644
index 0000000..2b66537
--- /dev/null
+++ b/include/opcode/pru.h
@@ -0,0 +1,379 @@
+/* TI PRU opcode list for GAS, the GNU assembler.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of GAS, the GNU Assembler, and GDB, the GNU disassembler.
+
+   GAS/GDB is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS/GDB is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS or GDB; see the file COPYING3.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#ifndef _PRU_H_
+#define _PRU_H_
+
+#include "bfd.h"
+
+/****************************************************************************
+ * This file contains structures, bit masks and shift counts used
+ * by the GNU toolchain to define the PRU instruction set and
+ * access various opcode fields.
+ ****************************************************************************/
+
+/* Identify different overflow situations for error messages.  */
+enum overflow_type
+{
+  call_target_overflow = 0,
+  qbranch_target_overflow,
+  address_offset_overflow,
+  signed_immed16_overflow,
+  unsigned_immed16_overflow,
+  unsigned_immed8_overflow,
+  unsigned_immed5_overflow,
+  no_overflow
+};
+
+enum opcode_format_type {
+    opcode_format1,
+    opcode_format2ab,
+    opcode_format2abl,
+    opcode_format2c,
+    opcode_format2de,
+    opcode_format45,
+    opcode_format6
+};
+
+/* This structure holds information for a particular instruction.
+
+   The args field is a string describing the operands.  The following
+   letters can appear in the args:
+     b - a 5.3-bit right source register index OR 8-bit unsigned immediate
+     c - a 5 bit unsigned immediate for constant table offset
+     d - a 5.3-bit destination register index
+     D - a 5.2-bit destination register index
+     j - a 5.3-bit right source register index OR 18-bit PC address
+     l - burst length (unsigned 7-bit immediate or r0.b[0-3]) for xLBCO
+     n - burst length (unsigned 7-bit immediate or r0.b[0-3]) for XFR
+     o - a 10-bit signed PC-relative offset
+     s - a 5.3-bit left source register index
+     S - a 5-bit left source register index
+     w - a single bit for "WakeOnStatus"
+     W - a 16-bit unsigned immediate with IO=0 field (LDI)
+     x - an 8-bit XFR wide-bus address immediate
+   Literal ',' character may also appear in the args as delimiter.
+
+   Most of the macro names are from [1].
+
+   The pinfo field is INSN_MACRO for a macro.  Otherwise, it is a collection
+   of bits describing the instruction, notably any relevant hazard
+   information.
+
+   When assembling, the match field contains the opcode template, which
+   is modified by the arguments to produce the actual opcode
+   that is emitted.  If pinfo is INSN_MACRO, then this is 0.
+
+   If pinfo is INSN_MACRO, the mask field stores the macro identifier.
+   Otherwise this is a bit mask for the relevant portions of the opcode
+   when disassembling.  If the actual opcode anded with the match field
+   equals the opcode field, then we have found the correct instruction.
+
+  [1] http://processors.wiki.ti.com/index.php/Programmable_Realtime_Unit  */
+
+struct pru_opcode
+{
+  const char *name;		/* The name of the instruction.  */
+  const char *args;		/* A string describing the arguments for this
+                                   instruction.  */
+  unsigned long match;		/* The basic opcode for the instruction.  */
+  unsigned long mask;		/* Mask for the opcode field of the
+				   instruction.  */
+  unsigned long pinfo;		/* Is this a real instruction or instruction
+				   macro?  */
+  enum overflow_type overflow_msg;  /* Used to generate informative
+				       message when fixup overflows.  */
+};
+
+/* This value is used in the pru_opcode.pinfo field to indicate that the
+   instruction is a macro or pseudo-op.  This requires special treatment by
+   the assembler, and is used by the disassembler to determine whether to
+   check for a nop.  */
+#define PRU_INSN_MACRO		0x80000000
+
+/* Associates a register name with a 5-bit index and 3-bit regsel.  */
+struct pru_reg
+{
+  const char *name;		/* Name, e.g. "r10" */
+  const unsigned int index;	/* Index, e.g. 10 */
+  const unsigned int regsel;	/* Register field selector, .e.g RSEL_31_0 */
+};
+
+/* Macros for getting and setting an instruction field.  */
+#define GET_INSN_FIELD(X, i) \
+  (((i) & OP_MASK_##X) >> OP_SH_##X)
+#define SET_INSN_FIELD(X, i, v) \
+  ((i) = (((i) & ~OP_MASK_##X) | (((v) << OP_SH_##X) & OP_MASK_##X)))
+
+#define CHECK_INSN_FIELD(X, i) \
+  (((i) & OP_MASK_##X) == OP_MATCH_##X)
+
+/* Masks, values, shifts and macros for accessing the various opcode fields */
+
+/* TODO - missing opcodes MVI, WBC, LOOP, ILOOP,
+
+   TODO - add core variants (v0 through v4?)
+ */
+
+#define OP_SH_FMT1_OP			29
+#define OP_MASK_FMT1_OP			(0x7u << 29)
+#define OP_MATCH_FMT1_OP		(0x0u << 29)
+
+#define OP_SH_FMT2_OP			29
+#define OP_MASK_FMT2_OP			(0x7u << 29)
+#define OP_MATCH_FMT2_OP		(0x1u << 29)
+
+#define OP_SH_FMT4_OP			30
+#define OP_MASK_FMT4_OP			(0x3u << 30)
+#define OP_MATCH_FMT4_OP		(0x1u << 30)
+
+#define OP_SH_FMT5_OP			29
+#define OP_MASK_FMT5_OP			(0x7u << 29)
+#define OP_MATCH_FMT5_OP		(0x6u << 29)
+
+#define OP_SH_FMT6AB_OP			29
+#define OP_MASK_FMT6AB_OP		(0x7u << 29)
+#define OP_MATCH_FMT6AB_OP		(0x7u << 29)
+
+#define OP_SH_FMT6CD_OP			29
+#define OP_MASK_FMT6CD_OP		(0x7u << 29)
+#define OP_MATCH_FMT6CD_OP		(0x4u << 29)
+
+/* Generic fields */
+#define OP_SH_SUBOP			25
+#define OP_MASK_SUBOP			(0xfu << 25)
+
+#define OP_SH_IO			24
+#define OP_MASK_IO			(0x1u << 24)
+
+#define OP_SH_RS2SEL			21
+#define OP_MASK_RS2SEL			(0x7u << 21)
+#define OP_SH_RS2			16
+#define OP_MASK_RS2			(0x1fu << 16)
+#define OP_SH_RS1SEL			13
+#define OP_MASK_RS1SEL			(0x7u << 13)
+#define OP_SH_RS1			8
+#define OP_MASK_RS1			(0x1fu << 8)
+#define OP_SH_RDSEL			5
+#define OP_MASK_RDSEL			(0x7u << 5)
+#define OP_SH_RD			0
+#define OP_MASK_RD			(0x1fu << 0)
+#define OP_SH_IMM8			16
+#define OP_MASK_IMM8			(0xffu << 16)
+#define OP_SH_IMM16			8
+#define OP_MASK_IMM16			(0xffffu << 8)
+
+#define RSEL_7_0			0u
+#define RSEL_15_8			1u
+#define RSEL_23_16			2u
+#define RSEL_31_24			3u
+#define RSEL_15_0			4u
+#define RSEL_23_8			5u
+#define RSEL_31_16			6u
+#define RSEL_31_0			7u
+#define RSEL_NUM_ITEMS			8u
+
+/* Format 1 specific fields */
+#define SUBOP_ADD			0u
+#define SUBOP_ADC			1u
+#define SUBOP_SUB			2u
+#define SUBOP_SUC			3u
+#define SUBOP_LSL			4u
+#define SUBOP_LSR			5u
+#define SUBOP_RSB			6u
+#define SUBOP_RSC			7u
+#define SUBOP_AND			8u
+#define SUBOP_OR			9u
+#define SUBOP_XOR			10u
+#define SUBOP_NOT			11u
+#define SUBOP_MIN			12u
+#define SUBOP_MAX			13u
+#define SUBOP_CLR			14u
+#define SUBOP_SET			15u
+
+/* Format 2 specific fields */
+#define SUBOP_JMP			0u
+#define SUBOP_JAL			1u
+#define SUBOP_LDI			2u
+#define SUBOP_LMBD			3u
+#define SUBOP_SCAN			4u
+#define SUBOP_HALT			5u
+#define SUBOP_RSVD_FOR_MVIx		6u
+#define SUBOP_XFR			7u
+#define SUBOP_RSVD_FOR_RFI		14u
+#define SUBOP_SLP			15u
+
+#define OP_SH_WAKEONSTATUS		23
+#define OP_MASK_WAKEONSTATUS		(0x1u << 23)
+
+/* Format 2 XFR specific fields */
+#define OP_SH_SUBOP_XFR			23
+#define OP_MASK_SUBOP_XFR		(3u << 23)
+#define OP_SH_XFR_WBA			15
+#define OP_MASK_XFR_WBA			(0xffu << 15)
+#define OP_SH_XFR_S			14
+#define OP_MASK_XFR_S			(1u << 14)
+#define OP_SH_XFR_LENGTH		7
+#define OP_MASK_XFR_LENGTH		(0x7fu << 7)
+
+#define SUBOP_XFR_XIN			1u
+#define SUBOP_XFR_XOUT			2u
+#define SUBOP_XFR_XCHG			3u
+
+/* Format 4 specific fields */
+#define OP_SH_BROFF98			25
+#define OP_MASK_BROFF98			(0x3u << 25)
+#define OP_SH_BROFF70			0
+#define OP_MASK_BROFF70			(0xffu << 0)
+#define OP_SH_GT			29
+#define OP_MASK_GT			(0x1u << 29)
+#define OP_SH_EQ			28
+#define OP_MASK_EQ			(0x1u << 28)
+#define OP_SH_LT			27
+#define OP_MASK_LT			(0x1u << 27)
+#define OP_MASK_CMP			(OP_MASK_GT | OP_MASK_EQ | OP_MASK_LT)
+
+
+/* Format 5 specific fields */
+#define OP_SH_BS			28
+#define OP_MASK_BS			(0x1u << 28)
+#define OP_SH_BC			27
+#define OP_MASK_BC			(0x1u << 27)
+#define OP_MASK_BCMP			(OP_MASK_BS | OP_MASK_BC)
+
+/* Format 6 specific fields */
+#define OP_SH_LOADSTORE			28
+#define OP_MASK_LOADSTORE		(0x1u << 28)
+#define OP_SH_BURSTLEN64		25
+#define OP_MASK_BURSTLEN64	      	(0x7u << 25)
+#define OP_SH_BURSTLEN31		13
+#define OP_MASK_BURSTLEN31	      	(0x7u << 13)
+#define OP_SH_CB			8
+#define OP_MASK_CB	      		(0x1fu << 8)
+#define OP_SH_BURSTLEN0			7
+#define OP_MASK_BURSTLEN0	      	(0x1u << 7)
+#define OP_SH_RDB			5
+#define OP_MASK_RDB	      		(0x3u << 5)
+
+#define LSSBBO_BYTECOUNT_R0_BITS7_0	124u
+#define LSBBO_BYTECOUNT_R0_BITS15_8	125u
+#define LSBBO_BYTECOUNT_R0_BITS23_16	126u
+#define LSBBO_BYTECOUNT_R0_BITS31_24	127u
+
+/* The following macros define the opcode matches for each
+   instruction code & OP_MASK_INST == OP_MATCH_INST.  */
+#define OP_MATCH_ADD	(OP_MATCH_FMT1_OP | (SUBOP_ADD << OP_SH_SUBOP))
+#define OP_MATCH_ADC	(OP_MATCH_FMT1_OP | (SUBOP_ADC << OP_SH_SUBOP))
+#define OP_MATCH_SUB	(OP_MATCH_FMT1_OP | (SUBOP_SUB << OP_SH_SUBOP))
+#define OP_MATCH_SUC	(OP_MATCH_FMT1_OP | (SUBOP_SUC << OP_SH_SUBOP))
+#define OP_MATCH_LSL	(OP_MATCH_FMT1_OP | (SUBOP_LSL << OP_SH_SUBOP))
+#define OP_MATCH_LSR	(OP_MATCH_FMT1_OP | (SUBOP_LSR << OP_SH_SUBOP))
+#define OP_MATCH_RSB	(OP_MATCH_FMT1_OP | (SUBOP_RSB << OP_SH_SUBOP))
+#define OP_MATCH_RSC	(OP_MATCH_FMT1_OP | (SUBOP_RSC << OP_SH_SUBOP))
+#define OP_MATCH_AND	(OP_MATCH_FMT1_OP | (SUBOP_AND << OP_SH_SUBOP))
+#define OP_MATCH_OR	(OP_MATCH_FMT1_OP | (SUBOP_OR << OP_SH_SUBOP))
+#define OP_MATCH_XOR	(OP_MATCH_FMT1_OP | (SUBOP_XOR << OP_SH_SUBOP))
+#define OP_MATCH_NOT	(OP_MATCH_FMT1_OP | (SUBOP_NOT << OP_SH_SUBOP))
+#define OP_MATCH_MIN	(OP_MATCH_FMT1_OP | (SUBOP_MIN << OP_SH_SUBOP))
+#define OP_MATCH_MAX	(OP_MATCH_FMT1_OP | (SUBOP_MAX << OP_SH_SUBOP))
+#define OP_MATCH_CLR	(OP_MATCH_FMT1_OP | (SUBOP_CLR << OP_SH_SUBOP))
+#define OP_MATCH_SET	(OP_MATCH_FMT1_OP | (SUBOP_SET << OP_SH_SUBOP))
+
+#define OP_MATCH_JMP	(OP_MATCH_FMT2_OP | (SUBOP_JMP << OP_SH_SUBOP))
+#define OP_MATCH_JAL	(OP_MATCH_FMT2_OP | (SUBOP_JAL << OP_SH_SUBOP))
+#define OP_MATCH_LDI	(OP_MATCH_FMT2_OP | (SUBOP_LDI << OP_SH_SUBOP))
+#define OP_MATCH_LMBD	(OP_MATCH_FMT2_OP | (SUBOP_LMBD << OP_SH_SUBOP))
+#define OP_MATCH_SCAN	(OP_MATCH_FMT2_OP | (SUBOP_SCAN << OP_SH_SUBOP))
+#define OP_MATCH_HALT	(OP_MATCH_FMT2_OP | (SUBOP_HALT << OP_SH_SUBOP))
+#define OP_MATCH_SLP	(OP_MATCH_FMT2_OP | (SUBOP_SLP << OP_SH_SUBOP))
+#define OP_MATCH_XFR	(OP_MATCH_FMT2_OP | (SUBOP_XFR << OP_SH_SUBOP))
+#define OP_MATCH_SXFR	(OP_MATCH_XFR | OP_MASK_XFR_S)
+#define OP_MATCH_XIN	(OP_MATCH_XFR | (SUBOP_XFR_XIN << OP_SH_SUBOP_XFR))
+#define OP_MATCH_XOUT	(OP_MATCH_XFR | (SUBOP_XFR_XOUT << OP_SH_SUBOP_XFR))
+#define OP_MATCH_XCHG	(OP_MATCH_XFR | (SUBOP_XFR_XCHG << OP_SH_SUBOP_XFR))
+#define OP_MATCH_SXIN	(OP_MATCH_SXFR | (SUBOP_XFR_XIN << OP_SH_SUBOP_XFR))
+#define OP_MATCH_SXOUT	(OP_MATCH_SXFR | (SUBOP_XFR_XOUT << OP_SH_SUBOP_XFR))
+#define OP_MATCH_SXCHG	(OP_MATCH_SXFR | (SUBOP_XFR_XCHG << OP_SH_SUBOP_XFR))
+
+#define OP_MATCH_QBGT	(OP_MATCH_FMT4_OP | OP_MASK_GT)
+#define OP_MATCH_QBGE	(OP_MATCH_FMT4_OP | OP_MASK_GT | OP_MASK_EQ)
+#define OP_MATCH_QBLT	(OP_MATCH_FMT4_OP | OP_MASK_LT)
+#define OP_MATCH_QBLE	(OP_MATCH_FMT4_OP | OP_MASK_LT | OP_MASK_EQ)
+#define OP_MATCH_QBEQ	(OP_MATCH_FMT4_OP | OP_MASK_EQ)
+#define OP_MATCH_QBNE	(OP_MATCH_FMT4_OP | OP_MASK_GT | OP_MASK_LT)
+#define OP_MATCH_QBA	(OP_MATCH_FMT4_OP | OP_MASK_GT | OP_MASK_LT | OP_MASK_EQ)
+
+#define OP_MATCH_QBBS	(OP_MATCH_FMT5_OP | OP_MASK_BS)
+#define OP_MATCH_QBBC	(OP_MATCH_FMT5_OP | OP_MASK_BC)
+
+#define OP_MATCH_LBBO	(OP_MATCH_FMT6AB_OP | OP_MASK_LOADSTORE)
+#define OP_MATCH_SBBO	(OP_MATCH_FMT6AB_OP)
+#define OP_MATCH_LBCO	(OP_MATCH_FMT6CD_OP | OP_MASK_LOADSTORE)
+#define OP_MATCH_SBCO	(OP_MATCH_FMT6CD_OP)
+
+/* Some special extractions. */
+#define OP_MASK_BROFF		  (OP_MASK_BROFF98 | OP_MASK_BROFF70)
+
+#define GET_BROFF_URAW(i)	  \
+  ( (GET_INSN_FIELD (BROFF98, i) << 8) | (GET_INSN_FIELD (BROFF70, i) << 0) )
+
+#define GET_BROFF_SIGNED(i)	  \
+  ((long)(GET_BROFF_URAW (i) - (!!(GET_BROFF_URAW (i) & (1 << 9)) << 10)))
+
+#define SET_BROFF_URAW(i, v)		      \
+  do {					      \
+      SET_INSN_FIELD (BROFF98, (i), (v) >> 8);    \
+      SET_INSN_FIELD (BROFF70, (i), (v) & 0xff);  \
+  } while (0)
+
+#define GET_BURSTLEN(i)	  \
+  ( (GET_INSN_FIELD (BURSTLEN64, (i)) << 4) |   \
+    (GET_INSN_FIELD (BURSTLEN31, (i)) << 1) |   \
+    (GET_INSN_FIELD (BURSTLEN0, (i)) << 0))
+
+#define SET_BURSTLEN(i, v)		      \
+  do {					      \
+      SET_INSN_FIELD (BURSTLEN64, (i), (v) >> 4); \
+      SET_INSN_FIELD (BURSTLEN31, (i), (v) >> 1); \
+      SET_INSN_FIELD (BURSTLEN0, (i), (v) >> 0);  \
+  } while (0)
+
+/* Miscellaneous helpers */
+#define OP_MASK_XFR_OP		(OP_MASK_FMT2_OP | OP_MASK_SUBOP \
+				 | OP_MASK_SUBOP_XFR | OP_MASK_XFR_S)
+
+/* These are the data structures we use to hold the instruction information.  */
+extern const struct pru_opcode pru_opcodes[];
+extern const int bfd_pru_num_opcodes;
+
+/* These are the data structures used to hold the register information.  */
+extern const struct pru_reg pru_regs[];
+extern const int pru_num_regs;
+
+/* Machine-independent macro for number of opcodes.  */
+#define NUMOPCODES bfd_pru_num_opcodes
+#define NUMREGISTERS pru_num_regs;
+
+/* This is made extern so that the assembler can use it to find out
+   what instruction caused an error.  */
+extern const struct pru_opcode *pru_find_opcode (unsigned long);
+
+#endif /* _PRU_H */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index 66795b3..93afc01 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -1583,6 +1583,11 @@ eppcnw.c:	$(srcdir)/emulparams/ppcnw.sh \
 eppcpe.c: $(srcdir)/emulparams/ppcpe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/ppcpe.sc ${GEN_DEPENDS}
 
+epruelf.c: $(srcdir)/emulparams/pruelf.sh \
+  $(srcdir)/emultempl/elf32.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/pru.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pruelf "$(tdir_pruelf)"
+
 eriscix.c: $(srcdir)/emulparams/riscix.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 
diff --git a/ld/Makefile.in b/ld/Makefile.in
index 6a534ca..17b06f9 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -3021,6 +3021,11 @@ eppcnw.c:	$(srcdir)/emulparams/ppcnw.sh \
 eppcpe.c: $(srcdir)/emulparams/ppcpe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/ppcpe.sc ${GEN_DEPENDS}
 
+epruelf.c: $(srcdir)/emulparams/pruelf.sh \
+  $(srcdir)/emultempl/elf32.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/pru.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pruelf "$(tdir_pruelf)"
+
 eriscix.c: $(srcdir)/emulparams/riscix.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 0eb743d..db99ce1 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -599,6 +599,7 @@ powerpc-*-aix*)		targ_emul=aixppc ;;
 powerpc-*-beos*)	targ_emul=aixppc ;;
 powerpc-*-windiss*)	targ_emul=elf32ppcwindiss ;;
 powerpc-*-lynxos*)	targ_emul=ppclynx ;;
+pru*-*-*)		targ_emul=pruelf ;;
 rs6000-*-aix[5-9]*)	targ_emul=aix5rs6 ;;
 rs6000-*-aix*)		targ_emul=aixrs6
 			;;
diff --git a/ld/emulparams/pruelf.sh b/ld/emulparams/pruelf.sh
new file mode 100644
index 0000000..8cfd10f
--- /dev/null
+++ b/ld/emulparams/pruelf.sh
@@ -0,0 +1,18 @@
+SCRIPT_NAME=elf
+TEMPLATE_NAME=elf32
+OUTPUT_FORMAT="elf32-pru"
+LITTLE_OUTPUT_FORMAT="elf32-pru"
+SCRIPT_NAME=pru
+
+ARCH=pru
+MACHINE=
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
+EMBEDDED=yes
+
+TEXT_ORIGIN=0x20000000
+TEXT_LENGTH=8K
+DATA_ORIGIN=0x0
+DATA_LENGTH=8K
+
+ENTRY=_start
diff --git a/ld/scripttempl/pru.sc b/ld/scripttempl/pru.sc
new file mode 100644
index 0000000..381792a
--- /dev/null
+++ b/ld/scripttempl/pru.sc
@@ -0,0 +1,194 @@
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}","${OUTPUT_FORMAT}","${OUTPUT_FORMAT}")
+OUTPUT_ARCH(${ARCH})
+
+MEMORY
+{
+  text   (x)   : ORIGIN = $TEXT_ORIGIN, LENGTH = $TEXT_LENGTH
+  data   (rw!x) : ORIGIN = $DATA_ORIGIN, LENGTH = $DATA_LENGTH
+}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash        ${RELOCATING-0} : { *(.hash)		}
+  .dynsym      ${RELOCATING-0} : { *(.dynsym)		}
+  .dynstr      ${RELOCATING-0} : { *(.dynstr)		}
+  .gnu.version ${RELOCATING-0} : { *(.gnu.version)	}
+  .gnu.version_d ${RELOCATING-0} : { *(.gnu.version_d)	}
+  .gnu.version_r ${RELOCATING-0} : { *(.gnu.version_r)	}
+
+  .rel.init    ${RELOCATING-0} : { *(.rel.init)		}
+  .rela.init   ${RELOCATING-0} : { *(.rela.init)	}
+  .rel.text    ${RELOCATING-0} :
+    {
+      *(.rel.text)
+      ${RELOCATING+*(.rel.text.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.t*)}
+    }
+  .rela.text   ${RELOCATING-0} :
+    {
+      *(.rela.text)
+      ${RELOCATING+*(.rela.text.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.t*)}
+    }
+  .rel.fini    ${RELOCATING-0} : { *(.rel.fini)		}
+  .rela.fini   ${RELOCATING-0} : { *(.rela.fini)	}
+  .rel.rodata  ${RELOCATING-0} :
+    {
+      *(.rel.rodata)
+      ${RELOCATING+*(.rel.rodata.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.r*)}
+    }
+  .rela.rodata ${RELOCATING-0} :
+    {
+      *(.rela.rodata)
+      ${RELOCATING+*(.rela.rodata.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.r*)}
+    }
+  .rel.data    ${RELOCATING-0} :
+    {
+      *(.rel.data)
+      ${RELOCATING+*(.rel.data.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.d*)}
+    }
+  .rela.data   ${RELOCATING-0} :
+    {
+      *(.rela.data)
+      ${RELOCATING+*(.rela.data.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.d*)}
+    }
+  .rel.ctors   ${RELOCATING-0} : { *(.rel.ctors)	}
+  .rela.ctors  ${RELOCATING-0} : { *(.rela.ctors)	}
+  .rel.dtors   ${RELOCATING-0} : { *(.rel.dtors)	}
+  .rela.dtors  ${RELOCATING-0} : { *(.rela.dtors)	}
+  .rel.got     ${RELOCATING-0} : { *(.rel.got)		}
+  .rela.got    ${RELOCATING-0} : { *(.rela.got)		}
+  .rel.bss     ${RELOCATING-0} : { *(.rel.bss)		}
+  .rela.bss    ${RELOCATING-0} : { *(.rela.bss)		}
+  .rel.plt     ${RELOCATING-0} : { *(.rel.plt)		}
+  .rela.plt    ${RELOCATING-0} : { *(.rela.plt)		}
+
+  /* Internal text space or external memory.  */
+  .text ${RELOCATING-0} :
+  {
+    *(.reset)
+    KEEP(*(.reset))
+
+    ${RELOCATING+ *(.text*)}
+
+    ${CONSTRUCTING+ __ctors_start = . ; }
+    ${CONSTRUCTING+ *(.ctors) }
+    ${CONSTRUCTING+ __ctors_end = . ; }
+    ${CONSTRUCTING+ __dtors_start = . ; }
+    ${CONSTRUCTING+ *(.dtors) }
+    ${CONSTRUCTING+ __dtors_end = . ; }
+    KEEP(SORT(*)(.ctors))
+    KEEP(SORT(*)(.dtors))
+
+    /* From this point on, we don't bother about wether the insns are
+       below or above the 16 bits boundary.  */
+    *(.init0)  /* Start here after reset.  */
+    KEEP (*(.init0))
+    *(.init1)
+    KEEP (*(.init1))
+    *(.init2)  /* Clear __zero_reg__, set up stack pointer.  */
+    KEEP (*(.init2))
+    *(.init3)
+    KEEP (*(.init3))
+    *(.init4)  /* Initialize data and BSS.  */
+    KEEP (*(.init4))
+    *(.init5)
+    KEEP (*(.init5))
+    *(.init6)  /* C++ constructors.  */
+    KEEP (*(.init6))
+    *(.init7)
+    KEEP (*(.init7))
+    *(.init8)
+    KEEP (*(.init8))
+    *(.init9)  /* Call main().  */
+    KEEP (*(.init9))
+    *(.text)
+    ${RELOCATING+. = ALIGN(4);}
+    ${RELOCATING+ *(.text.*)}
+    ${RELOCATING+. = ALIGN(4);}
+    *(.fini9)  /* _exit() starts here.  */
+    KEEP (*(.fini9))
+    *(.fini8)
+    KEEP (*(.fini8))
+    *(.fini7)
+    KEEP (*(.fini7))
+    *(.fini6)  /* C++ destructors.  */
+    KEEP (*(.fini6))
+    *(.fini5)
+    KEEP (*(.fini5))
+    *(.fini4)
+    KEEP (*(.fini4))
+    *(.fini3)
+    KEEP (*(.fini3))
+    *(.fini2)
+    KEEP (*(.fini2))
+    *(.fini1)
+    KEEP (*(.fini1))
+    *(.fini0)  /* Infinite loop after program termination.  */
+    KEEP (*(.fini0))
+    ${RELOCATING+ _etext = . ; }
+  } ${RELOCATING+ > text}
+
+  .data        ${RELOCATING-0} :
+  {
+    /* Data memory is at address 0. But NULL should be an invalid address!
+     * So ignore the first word to satisfy the C compiler.
+     *
+     * TODO - can we put the NULL address into use? */
+    . += 4;
+    ${RELOCATING+ PROVIDE (__data_start = .) ; }
+    /* --gc-sections will delete empty .data. This leads to wrong start
+       addresses for subsequent sections because -Tdata= from the command
+       line will have no effect, see PR13697.  Thus, keep .data  */
+    KEEP (*(.data))
+    ${RELOCATING+ *(.data*)}
+    *(.rodata)  /* We need to include .rodata here if gcc is used */
+    ${RELOCATING+ *(.rodata*)} /* with -fdata-sections.  */
+    *(.gnu.linkonce.d*)
+    ${RELOCATING+. = ALIGN(4);}
+    ${RELOCATING+ _edata = . ; }
+    ${RELOCATING+ PROVIDE (__data_end = .) ; }
+  } ${RELOCATING+ > data }
+
+  .bss ${RELOCATING-0} :${RELOCATING+ AT (ADDR (.bss))}
+  {
+    ${RELOCATING+ PROVIDE (__bss_start = .) ; }
+    *(.bss)
+    ${RELOCATING+ *(.bss*)}
+    *(COMMON)
+    ${RELOCATING+ PROVIDE (__bss_end = .) ; }
+  } ${RELOCATING+ > data}
+
+  /* Global data not cleared after reset.  */
+  .noinit ${RELOCATING-0}:
+  {
+    ${RELOCATING+ PROVIDE (__noinit_start = .) ; }
+    *(.noinit*)
+    ${RELOCATING+ PROVIDE (__noinit_end = .) ; }
+    ${RELOCATING+ _end = . ;  }
+    ${RELOCATING+ PROVIDE (__heap_start = .) ; }
+  } ${RELOCATING+ > data}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .note.gnu.build-id : { *(.note.gnu.build-id) }
+EOF
+
+. $srcdir/scripttempl/DWARF.sc
+
+cat <<EOF
+}
+EOF
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 9ff6a38..f7d4f17 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -221,6 +221,8 @@ TARGET_LIBOPCODES_CFILES = \
 	pj-opc.c \
 	ppc-dis.c \
 	ppc-opc.c \
+	pru-dis.c \
+	pru-opc.c \
 	rl78-decode.c \
 	rl78-dis.c \
 	rx-decode.c \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index f83f1d9..41dd939 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -493,6 +493,8 @@ TARGET_LIBOPCODES_CFILES = \
 	pj-opc.c \
 	ppc-dis.c \
 	ppc-opc.c \
+	pru-dis.c \
+	pru-opc.c \
 	rl78-decode.c \
 	rl78-dis.c \
 	rx-decode.c \
@@ -896,6 +898,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pj-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ppc-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ppc-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pru-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pru-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rl78-decode.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rl78-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rx-decode.Plo@am__quote@
diff --git a/opcodes/configure b/opcodes/configure
index 40a2b85..1d558f5 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -12592,6 +12592,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_pj_arch)		ta="$ta pj-dis.lo pj-opc.lo" ;;
 	bfd_powerpc_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
 	bfd_powerpc_64_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
+	bfd_pru_arch)		ta="$ta pru-dis.lo pru-opc.lo" ;;
 	bfd_pyramid_arch)	;;
 	bfd_romp_arch)		;;
 	bfd_rs6000_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
diff --git a/opcodes/configure.in b/opcodes/configure.in
index 3ffcaa0..3692907 100644
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -312,6 +312,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_pj_arch)		ta="$ta pj-dis.lo pj-opc.lo" ;;
 	bfd_powerpc_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
 	bfd_powerpc_64_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
+	bfd_pru_arch)		ta="$ta pru-dis.lo pru-opc.lo" ;;
 	bfd_pyramid_arch)	;;
 	bfd_romp_arch)		;;
 	bfd_rs6000_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 0a0814e..bac34a5 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -72,6 +72,7 @@
 #define ARCH_pdp11
 #define ARCH_pj
 #define ARCH_powerpc
+#define ARCH_pru
 #define ARCH_rs6000
 #define ARCH_rl78
 #define ARCH_rx
@@ -373,6 +374,11 @@ disassembler (abfd)
 	disassemble = print_insn_little_powerpc;
       break;
 #endif
+#ifdef ARCH_pru
+    case bfd_arch_pru:
+      disassemble = print_insn_pru;
+      break;
+#endif
 #ifdef ARCH_rs6000
     case bfd_arch_rs6000:
       if (bfd_get_mach (abfd) == bfd_mach_ppc_620)
diff --git a/opcodes/pru-dis.c b/opcodes/pru-dis.c
new file mode 100644
index 0000000..614a19b
--- /dev/null
+++ b/opcodes/pru-dis.c
@@ -0,0 +1,265 @@
+/* TI PRU disassemble routines
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov <dinuxbg@gmail.com>
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include "opcode/pru.h"
+#include "libiberty.h"
+#include <string.h>
+#include <assert.h>
+
+/* No symbol table is available when this code runs out in an embedded
+   system as when it is used for disassembler support in a monitor.  */
+#if !defined(EMBEDDED_ENV)
+#define SYMTAB_AVAILABLE 1
+#include "elf-bfd.h"
+#include "elf/pru.h"
+#endif
+
+/* Length of PRU instruction in bytes.  */
+#define INSNLEN 4
+
+/* Return a pointer to an pru_opcode struct for a given instruction
+   opcode, or NULL if there is an error.  */
+const struct pru_opcode *
+pru_find_opcode (unsigned long opcode)
+{
+  const struct pru_opcode *p;
+  const struct pru_opcode *op = NULL;
+  const struct pru_opcode *pseudo_op = NULL;
+
+  for (p = pru_opcodes; p < &pru_opcodes[NUMOPCODES]; p++)
+    {
+      if ((p->mask & opcode) == p->match)
+	{
+	  if ((p->pinfo & PRU_INSN_MACRO) == PRU_INSN_MACRO)
+	    pseudo_op = p;
+	  else
+	    op = p;
+	}
+    }
+
+  return pseudo_op ? pseudo_op : op;
+}
+
+/* There are 32 regular registers, each with 8 possible subfield selectors. */
+#define NUMREGNAMES (32 * 8)
+
+static void
+pru_print_insn_arg_reg (unsigned int r, unsigned int sel,
+                       disassemble_info *info)
+{
+  unsigned int i = r * RSEL_NUM_ITEMS + sel;
+  assert (i < (unsigned int)pru_num_regs);
+  assert (i < NUMREGNAMES);
+  (*info->fprintf_func) (info->stream, "%s", pru_regs[i].name);
+}
+
+/* The function pru_print_insn_arg uses the character pointed
+   to by ARGPTR to determine how it print the next token or separator
+   character in the arguments to an instruction.  */
+static int
+pru_print_insn_arg (const char *argptr,
+		      unsigned long opcode, bfd_vma address,
+		      disassemble_info *info)
+{
+  long offs = 0;
+  unsigned long i = 0;
+  unsigned long io = 0;
+
+  switch (*argptr)
+    {
+    case ',':
+      (*info->fprintf_func) (info->stream, "%c ", *argptr);
+      break;
+    case 'd':
+      pru_print_insn_arg_reg (GET_INSN_FIELD (RD, opcode),
+			      GET_INSN_FIELD (RDSEL, opcode),
+			      info);
+      break;
+    case 'D':
+      /* The first 4 values for RDB and RSEL are the same, so we
+         can reuse some code */
+      pru_print_insn_arg_reg (GET_INSN_FIELD (RD, opcode),
+			      GET_INSN_FIELD (RDB, opcode),
+			      info);
+      break;
+    case 's':
+      pru_print_insn_arg_reg (GET_INSN_FIELD (RS1, opcode),
+			      GET_INSN_FIELD (RS1SEL, opcode),
+			      info);
+      break;
+    case 'S':
+      pru_print_insn_arg_reg (GET_INSN_FIELD (RS1, opcode),
+			      RSEL_31_0,
+			      info);
+      break;
+    case 'b':
+      io = GET_INSN_FIELD (IO, opcode);
+
+      if (io)
+	{
+	  i = GET_INSN_FIELD (IMM8, opcode);
+	  (*info->fprintf_func) (info->stream, "%ld", i);
+	}
+      else
+	{
+	pru_print_insn_arg_reg (GET_INSN_FIELD (RS2, opcode),
+				GET_INSN_FIELD (RS2SEL, opcode),
+				info);
+	}
+      break;
+    case 'j':
+      io = GET_INSN_FIELD (IO, opcode);
+
+      if (io)
+	{
+	  /* For the sake of pretty-printing, dump text addresses with
+	     their "virtual" offset that we use for distinguishing
+	     PMEM vs DMEM. This is needed for printing the correct text
+	     labels. */
+	  bfd_vma text_offset = address & ~0x3fffff;
+	  i = GET_INSN_FIELD (IMM16, opcode) * 4;
+	  (*info->print_address_func) (i + text_offset, info);
+	}
+      else
+	{
+	  pru_print_insn_arg_reg (GET_INSN_FIELD (RS2, opcode),
+				GET_INSN_FIELD (RS2SEL, opcode),
+				info);
+	}
+      break;
+    case 'W':
+      i = GET_INSN_FIELD (IMM16, opcode);
+      (*info->fprintf_func) (info->stream, "%ld", i);
+      break;
+    case 'o':
+      offs = GET_BROFF_SIGNED (opcode) * 4;
+      (*info->print_address_func) (address + offs, info);
+      break;
+    case 'l':
+      i = GET_BURSTLEN (opcode);
+      if (i < LSSBBO_BYTECOUNT_R0_BITS7_0)
+	(*info->fprintf_func) (info->stream, "%ld", i + 1);
+      else
+	{
+	  i -= LSSBBO_BYTECOUNT_R0_BITS7_0;
+	  (*info->fprintf_func) (info->stream, "r0.b%ld", i);
+	}
+      break;
+    case 'n':
+      i = GET_INSN_FIELD (XFR_LENGTH, opcode);
+      if (i < LSSBBO_BYTECOUNT_R0_BITS7_0)
+	(*info->fprintf_func) (info->stream, "%ld", i + 1);
+      else
+	{
+	  i -= LSSBBO_BYTECOUNT_R0_BITS7_0;
+	  (*info->fprintf_func) (info->stream, "r0.b%ld", i);
+	}
+      break;
+    case 'c':
+      i = GET_INSN_FIELD (CB, opcode);
+      (*info->fprintf_func) (info->stream, "%ld", i);
+      break;
+    case 'w':
+      i = GET_INSN_FIELD (WAKEONSTATUS, opcode);
+      (*info->fprintf_func) (info->stream, "%ld", i);
+      break;
+    case 'x':
+      i = GET_INSN_FIELD (XFR_WBA, opcode);
+      (*info->fprintf_func) (info->stream, "%ld", i);
+      break;
+    default:
+      (*info->fprintf_func) (info->stream, "unknown");
+      break;
+    }
+  return 0;
+}
+
+/* pru_disassemble does all the work of disassembling a PRU
+   instruction opcode.  */
+static int
+pru_disassemble (bfd_vma address, unsigned long opcode,
+		   disassemble_info *info)
+{
+  const struct pru_opcode *op;
+
+  info->bytes_per_line = INSNLEN;
+  info->bytes_per_chunk = INSNLEN;
+  info->display_endian = info->endian;
+  info->insn_info_valid = 1;
+  info->branch_delay_insns = 0;
+  info->data_size = 0;
+  info->insn_type = dis_nonbranch;
+  info->target = 0;
+  info->target2 = 0;
+
+  /* Find the major opcode and use this to disassemble
+     the instruction and its arguments.  */
+  op = pru_find_opcode (opcode);
+
+  if (op != NULL)
+    {
+      (*info->fprintf_func) (info->stream, "%s", op->name);
+
+      const char *argstr = op->args;
+      if (argstr != NULL && *argstr != '\0')
+	{
+	  (*info->fprintf_func) (info->stream, "\t");
+	  while (*argstr != '\0')
+	    {
+	      pru_print_insn_arg (argstr, opcode, address, info);
+	      ++argstr;
+	    }
+	}
+    }
+  else
+    {
+      /* Handle undefined instructions.  */
+      info->insn_type = dis_noninsn;
+      (*info->fprintf_func) (info->stream, "0x%lx", opcode);
+    }
+  /* Tell the caller how far to advance the program counter.  */
+  return INSNLEN;
+}
+
+
+/* print_insn_pru is the main disassemble function for PRU. */
+int
+print_insn_pru (bfd_vma address, disassemble_info *info)
+{
+  bfd_byte buffer[INSNLEN];
+  int status;
+
+  status = (*info->read_memory_func) (address, buffer, INSNLEN, info);
+  if (status == 0)
+    {
+      unsigned long insn;
+      insn = (unsigned long) bfd_getl32 (buffer);
+      status = pru_disassemble (address, insn, info);
+    }
+  else
+    {
+      (*info->memory_error_func) (status, address, info);
+      status = -1;
+    }
+  return status;
+}
diff --git a/opcodes/pru-opc.c b/opcodes/pru-opc.c
new file mode 100644
index 0000000..39cba54
--- /dev/null
+++ b/opcodes/pru-opc.c
@@ -0,0 +1,217 @@
+/* Altera Nios II opcode list.
+   Copyright (C) 2012, 2013 Free Software Foundation, Inc.
+   Contributed by Nigel Gray (ngray@altera.com).
+   Contributed by Mentor Graphics, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* Source: http://processors.wiki.ti.com/index.php/Programmable_Realtime_Unit */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "opcode/pru.h"
+
+/* Register string table */
+
+#define DECLARE_REG(name, index)		\
+  { #name ".b0", (index), RSEL_7_0 },		\
+  { #name ".b1", (index), RSEL_15_8 },		\
+  { #name ".b2", (index), RSEL_23_16 },		\
+  { #name ".b3", (index), RSEL_31_24 },		\
+  { #name ".w0", (index), RSEL_15_0 },		\
+  { #name ".w1", (index), RSEL_23_8 },		\
+  { #name ".w2", (index), RSEL_31_16 },		\
+  { #name , (index), RSEL_31_0 }
+
+const struct pru_reg pru_regs[] = {
+  /* Standard register names.  */
+  DECLARE_REG (r0, 0),
+  DECLARE_REG (r1, 1),
+  DECLARE_REG (r2, 2),
+  DECLARE_REG (r3, 3),
+  DECLARE_REG (r4, 4),
+  DECLARE_REG (r5, 5),
+  DECLARE_REG (r6, 6),
+  DECLARE_REG (r7, 7),
+  DECLARE_REG (r8, 8),
+  DECLARE_REG (r9, 9),
+  DECLARE_REG (r10, 10),
+  DECLARE_REG (r11, 11),
+  DECLARE_REG (r12, 12),
+  DECLARE_REG (r13, 13),
+  DECLARE_REG (r14, 14),
+  DECLARE_REG (r15, 15),
+  DECLARE_REG (r16, 16),
+  DECLARE_REG (r17, 17),
+  DECLARE_REG (r18, 18),
+  DECLARE_REG (r19, 19),
+  DECLARE_REG (r20, 20),
+  DECLARE_REG (r21, 21),
+  DECLARE_REG (r22, 22),
+  DECLARE_REG (r23, 23),
+  DECLARE_REG (r24, 24),
+  DECLARE_REG (r25, 25),
+  DECLARE_REG (r26, 26),
+  DECLARE_REG (ra, 27),		/* return address */
+  DECLARE_REG (sp, 28),		/* stack pointer */
+  DECLARE_REG (fp, 29),		/* frame pointer */
+  DECLARE_REG (r30, 30),
+  DECLARE_REG (r31, 31),
+
+  /* Alternative names for special registers.  */
+  DECLARE_REG (r27, 27),
+  DECLARE_REG (r28, 28),
+  DECLARE_REG (r29, 29)
+};
+
+#define PRU_NUM_REGS \
+       ((sizeof pru_regs) / (sizeof (pru_regs[0])))
+const int pru_num_regs = PRU_NUM_REGS;
+
+#undef PRU_NUM_REGS
+
+/* This is the opcode table used by the PRU GNU as, disassembler
+   and soon GDB.  */
+const struct pru_opcode pru_opcodes[] =
+{
+  /* { name, args,
+       match, mask, pinfo, overflow_msg } */
+#define DECLARE_FORMAT1_OPCODE(str, subop) \
+  { #str, "d,s,b",\
+   OP_MATCH_ ## subop, OP_MASK_FMT1_OP | OP_MASK_SUBOP, 0, unsigned_immed8_overflow}
+
+  DECLARE_FORMAT1_OPCODE(add, ADD),
+  DECLARE_FORMAT1_OPCODE(adc, ADC),
+  DECLARE_FORMAT1_OPCODE(sub, SUB),
+  DECLARE_FORMAT1_OPCODE(suc, SUC),
+  DECLARE_FORMAT1_OPCODE(lsl, LSL),
+  DECLARE_FORMAT1_OPCODE(lsr, LSR),
+  DECLARE_FORMAT1_OPCODE(rsb, RSB),
+  DECLARE_FORMAT1_OPCODE(rsc, RSC),
+  DECLARE_FORMAT1_OPCODE(and, AND),
+  DECLARE_FORMAT1_OPCODE(or, OR),
+  DECLARE_FORMAT1_OPCODE(xor, XOR),
+  DECLARE_FORMAT1_OPCODE(min, MIN),
+  DECLARE_FORMAT1_OPCODE(max, MAX),
+  DECLARE_FORMAT1_OPCODE(clr, CLR),
+  DECLARE_FORMAT1_OPCODE(set, SET),
+
+  { "not", "d,s",
+   OP_MATCH_NOT | OP_MASK_IO,
+   OP_MASK_FMT1_OP | OP_MASK_SUBOP | OP_MASK_IO, 0, no_overflow},
+
+  { "jmp", "j",
+   OP_MATCH_JMP, OP_MASK_FMT2_OP | OP_MASK_SUBOP, 0, unsigned_immed16_overflow},
+  { "jal", "d,j",
+   OP_MATCH_JAL, OP_MASK_FMT2_OP | OP_MASK_SUBOP, 0, unsigned_immed16_overflow},
+  { "ldi", "d,W",
+   OP_MATCH_LDI, OP_MASK_FMT2_OP | OP_MASK_SUBOP, 0, unsigned_immed16_overflow},
+  { "halt", "",
+   OP_MATCH_HALT, OP_MASK_FMT2_OP | OP_MASK_SUBOP, 0, no_overflow},
+  { "slp", "w",
+   OP_MATCH_SLP, OP_MASK_FMT2_OP | OP_MASK_SUBOP, 0, no_overflow},
+
+  { "xin", "x,D,n",
+   OP_MATCH_XIN, OP_MASK_XFR_OP, 0, unsigned_immed8_overflow},
+  { "xout", "x,D,n",
+   OP_MATCH_XOUT, OP_MASK_XFR_OP, 0, unsigned_immed8_overflow},
+  { "xchg", "x,D,n",
+   OP_MATCH_XCHG, OP_MASK_XFR_OP, 0, unsigned_immed8_overflow},
+  { "sxin", "x,D,n",
+   OP_MATCH_SXIN, OP_MASK_XFR_OP, 0, unsigned_immed8_overflow},
+  { "sxout", "x,D,n",
+   OP_MATCH_SXOUT, OP_MASK_XFR_OP, 0, unsigned_immed8_overflow},
+  { "sxchg", "x,D,n",
+   OP_MATCH_SXCHG, OP_MASK_XFR_OP, 0, unsigned_immed8_overflow},
+
+  { "qbgt", "o,s,b",
+   OP_MATCH_QBGT, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+  { "qbge", "o,s,b",
+   OP_MATCH_QBGE, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+  { "qblt", "o,s,b",
+   OP_MATCH_QBLT, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+  { "qble", "o,s,b",
+   OP_MATCH_QBLE, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+  { "qbeq", "o,s,b",
+   OP_MATCH_QBEQ, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+  { "qbne", "o,s,b",
+   OP_MATCH_QBNE, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+  { "qba", "o",
+   OP_MATCH_QBA, OP_MASK_FMT4_OP | OP_MASK_CMP, 0, qbranch_target_overflow},
+
+  { "qbbs", "o,s,b",
+   OP_MATCH_QBBS, OP_MASK_FMT5_OP | OP_MASK_BCMP, 0, qbranch_target_overflow},
+  { "qbbc", "o,s,b",
+   OP_MATCH_QBBC, OP_MASK_FMT5_OP | OP_MASK_BCMP, 0, qbranch_target_overflow},
+
+  { "lbbo", "D,S,b,l",
+   OP_MATCH_LBBO, OP_MASK_FMT6AB_OP | OP_MASK_LOADSTORE, 0,
+   unsigned_immed8_overflow},
+  { "sbbo", "D,S,b,l",
+   OP_MATCH_SBBO, OP_MASK_FMT6AB_OP | OP_MASK_LOADSTORE, 0,
+   unsigned_immed8_overflow},
+  { "lbco", "D,c,b,l",
+   OP_MATCH_LBCO, OP_MASK_FMT6CD_OP | OP_MASK_LOADSTORE, 0,
+   unsigned_immed8_overflow},
+  { "sbco", "D,c,b,l",
+   OP_MATCH_SBCO, OP_MASK_FMT6CD_OP | OP_MASK_LOADSTORE, 0,
+   unsigned_immed8_overflow},
+
+  /* Fill in the default values for the real-instruction arguments.
+     The assembler will not do it! */
+  { "nop", "",
+   OP_MATCH_OR
+     | (RSEL_31_0 << OP_SH_RS2SEL) | (0 << OP_SH_RS2)
+     | (RSEL_31_0 << OP_SH_RS1SEL) | (0 << OP_SH_RS1)
+     | (RSEL_31_0 << OP_SH_RDSEL) | (0 << OP_SH_RD),
+   OP_MASK_FMT1_OP | OP_MASK_SUBOP
+     | OP_MASK_RS2SEL | OP_MASK_RS2 | OP_MASK_RS1SEL | OP_MASK_RS1
+     | OP_MASK_RDSEL | OP_MASK_RD | OP_MASK_IO,
+   PRU_INSN_MACRO, no_overflow},
+  { "mov", "d,s",
+   OP_MATCH_OR | (0 << OP_SH_IMM8) | OP_MASK_IO,
+   OP_MASK_FMT1_OP | OP_MASK_SUBOP | OP_MASK_IMM8 | OP_MASK_IO,
+   PRU_INSN_MACRO, no_overflow},
+  { "ret", "",
+   OP_MATCH_JMP
+     | (RSEL_31_0 << OP_SH_RS2SEL) | (27 << OP_SH_RS2),
+   OP_MASK_FMT2_OP | OP_MASK_SUBOP
+     | OP_MASK_RS2SEL | OP_MASK_RS2 | OP_MASK_IO,
+   PRU_INSN_MACRO, unsigned_immed16_overflow},
+  { "call", "j",
+   OP_MATCH_JAL
+     | (RSEL_31_0 << OP_SH_RDSEL) | (27 << OP_SH_RD),
+   OP_MASK_FMT2_OP | OP_MASK_SUBOP
+     | OP_MASK_RDSEL | OP_MASK_RD,
+   PRU_INSN_MACRO, unsigned_immed16_overflow},
+
+  { "fill", "D,n",
+   OP_MATCH_XIN | (254 << OP_SH_XFR_WBA),
+   OP_MASK_XFR_OP | OP_MASK_XFR_WBA,
+   PRU_INSN_MACRO, unsigned_immed8_overflow},
+  { "zero", "D,n",
+   OP_MATCH_XIN | (255 << OP_SH_XFR_WBA),
+   OP_MASK_XFR_OP | OP_MASK_XFR_WBA,
+   PRU_INSN_MACRO, unsigned_immed8_overflow},
+};
+
+#define PRU_NUM_OPCODES \
+       ((sizeof pru_opcodes) / (sizeof (pru_opcodes[0])))
+const int bfd_pru_num_opcodes = PRU_NUM_OPCODES;
+
+#undef PRU_NUM_OPCODES
diff --git a/readline/support/config.sub b/readline/support/config.sub
index d07267e..9b6f5dd 100755
--- a/readline/support/config.sub
+++ b/readline/support/config.sub
@@ -277,6 +277,7 @@ case $basic_machine in
 	| or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pru \
 	| pyramid \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
@@ -360,6 +361,7 @@ case $basic_machine in
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pru-* \
 	| pyramid-* \
 	| romp-* | rs6000-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
-- 
2.0.0

